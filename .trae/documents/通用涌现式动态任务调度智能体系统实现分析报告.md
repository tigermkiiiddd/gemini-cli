# é€šç”¨æ¶Œç°å¼åŠ¨æ€ä»»åŠ¡è°ƒåº¦æ™ºèƒ½ä½“ç³»ç»Ÿå®ç°åˆ†ææŠ¥å‘Š

**ç‰ˆæœ¬**: 2.0  
**è¯„åˆ†æ ‡å‡†**: 10åˆ†åˆ¶  
**æ›´æ–°æ—¶é—´**: 2024å¹´1æœˆ  
**æŠ€æœ¯æ·±åº¦**: ä¼ä¸šçº§å®æ–½æŒ‡å—  

---

## ğŸ“‹ ç›®å½•

1. [æ‰§è¡Œæ‘˜è¦](#1-æ‰§è¡Œæ‘˜è¦)
2. [ç³»ç»Ÿæ¶æ„è®¾è®¡](#2-ç³»ç»Ÿæ¶æ„è®¾è®¡)
3. [æ ¸å¿ƒç»„ä»¶è¯¦ç»†å®ç°](#3-æ ¸å¿ƒç»„ä»¶è¯¦ç»†å®ç°)
4. [æç¤ºå·¥ç¨‹ä½“ç³»](#4-æç¤ºå·¥ç¨‹ä½“ç³»)
5. [ä»»åŠ¡è°ƒåº¦ä¸æ‰§è¡Œæœºåˆ¶](#5-ä»»åŠ¡è°ƒåº¦ä¸æ‰§è¡Œæœºåˆ¶)
6. [æ¶Œç°èƒ½åŠ›å®ç°](#6-æ¶Œç°èƒ½åŠ›å®ç°)
7. [MCPå·¥å…·é›†æˆ](#7-mcpå·¥å…·é›†æˆ)
8. [ä»£ç æ¶æ„ä¸APIè®¾è®¡](#8-ä»£ç æ¶æ„ä¸apiè®¾è®¡)
9. [éƒ¨ç½²è¿ç»´æŒ‡å—](#9-éƒ¨ç½²è¿ç»´æŒ‡å—)
10. [æ€§èƒ½ä¼˜åŒ–ä¸ç›‘æ§](#10-æ€§èƒ½ä¼˜åŒ–ä¸ç›‘æ§)
11. [å®‰å…¨é˜²æŠ¤ä½“ç³»](#11-å®‰å…¨é˜²æŠ¤ä½“ç³»)
12. [æµ‹è¯•ç­–ç•¥ä¸è´¨é‡ä¿è¯](#12-æµ‹è¯•ç­–ç•¥ä¸è´¨é‡ä¿è¯)
13. [å®æ–½è·¯çº¿å›¾](#13-å®æ–½è·¯çº¿å›¾)

---

## 1. æ‰§è¡Œæ‘˜è¦

### 1.1 ç³»ç»Ÿæ¦‚è¿°

æœ¬æŠ¥å‘Šè¯¦ç»†é˜è¿°äº†ä¸€ä¸ª**é€šç”¨æ¶Œç°å¼åŠ¨æ€ä»»åŠ¡è°ƒåº¦æ™ºèƒ½ä½“ç³»ç»Ÿ**çš„å®Œæ•´å®ç°æ–¹æ¡ˆã€‚è¯¥ç³»ç»ŸåŸºäºGemini CLIé¡¹ç›®çš„æ·±åº¦åˆ†æï¼Œé‡‡ç”¨å¤šå±‚çº§æ™ºèƒ½ä½“æ¶æ„ï¼Œé€šè¿‡**æç¤ºè¯å·¥ç¨‹**ã€**ä»£ç å·¥ç¨‹**å’Œ**MCPå·¥å…·**ä¸‰å¤§æŠ€æœ¯è·¯å¾„ï¼Œå®ç°äº†å…·å¤‡è‡ªä¸»å­¦ä¹ ã€åŠ¨æ€é€‚åº”å’Œåä½œæ¶Œç°èƒ½åŠ›çš„AIç³»ç»Ÿã€‚

### 1.2 æ ¸å¿ƒåˆ›æ–°ç‚¹

- **ğŸ§  å¤šå±‚çº§æ™ºèƒ½ä½“æ¶æ„**: å…ƒæ™ºèƒ½ä½“ + ä¸“é—¨åŒ–å­æ™ºèƒ½ä½“çš„åˆ†å±‚åä½œæ¨¡å¼
- **ğŸ”„ åŠ¨æ€ä»»åŠ¡è°ƒåº¦**: åŸºäºä¼˜å…ˆçº§ã€èµ„æºå’Œèƒ½åŠ›çš„æ™ºèƒ½è°ƒåº¦ç®—æ³•
- **ğŸ’¡ æ¶Œç°èƒ½åŠ›æœºåˆ¶**: é€šè¿‡æ™ºèƒ½ä½“åä½œäº§ç”Ÿè¶…è¶Šå•ä½“èƒ½åŠ›çš„ç³»ç»Ÿè¡Œä¸º
- **ğŸ› ï¸ MCPå·¥å…·ç”Ÿæ€**: æ ‡å‡†åŒ–çš„å·¥å…·æ³¨å†Œã€å‘ç°å’Œæ‰§è¡Œæ¡†æ¶
- **ğŸ“ åˆ†å±‚æç¤ºå·¥ç¨‹**: ç³»ç»Ÿçº§ã€è§’è‰²çº§ã€ä»»åŠ¡çº§ã€ä¸Šä¸‹æ–‡çº§çš„æç¤ºè¯ä½“ç³»

### 1.3 æŠ€æœ¯å®ç°è·¯å¾„

| å®ç°è·¯å¾„ | å æ¯” | æ ¸å¿ƒæŠ€æœ¯ | åº”ç”¨åœºæ™¯ |
|---------|------|----------|----------|
| **ã€æç¤ºè¯å·¥ç¨‹ã€‘** | 40% | åˆ†å±‚æç¤ºæ¶æ„ã€åŠ¨æ€æ¨¡æ¿ç”Ÿæˆã€ä¸Šä¸‹æ–‡æ³¨å…¥ | æ™ºèƒ½ä½“è¡Œä¸ºå®šä¹‰ã€ä»»åŠ¡ç†è§£ã€å†³ç­–æ¨ç† |
| **ã€ä»£ç å·¥ç¨‹ã€‘** | 45% | TypeScript/Pythonã€å¾®æœåŠ¡æ¶æ„ã€äº‹ä»¶é©±åŠ¨ | ç³»ç»Ÿæ¡†æ¶ã€è°ƒåº¦å¼•æ“ã€çŠ¶æ€ç®¡ç† |
| **ã€MCPå·¥å…·ã€‘** | 15% | å·¥å…·æ ‡å‡†åŒ–ã€æ²™ç®±æ‰§è¡Œã€èƒ½åŠ›æ‰©å±• | å¤–éƒ¨ç³»ç»Ÿé›†æˆã€åŠŸèƒ½æ‰©å±• |

---

## 2. ç³»ç»Ÿæ¶æ„è®¾è®¡

### 2.1 æ•´ä½“æ¶æ„è§†å›¾

**ã€ä»£ç å·¥ç¨‹ã€‘+ ã€æç¤ºè¯å·¥ç¨‹ã€‘**

```mermaid
graph TB
    subgraph "ğŸŒ ç”¨æˆ·äº¤äº’å±‚"
        CLI["CLIç•Œé¢"]
        WebUI["Webç•Œé¢"]
        API["REST API"]
        WS["WebSocket"]
    end
    
    subgraph "ğŸ§  æ™ºèƒ½ä½“ç¼–æ’å±‚"
        MA["å…ƒæ™ºèƒ½ä½“<br/>(Meta Agent)"]
        CA["ä»£ç æ™ºèƒ½ä½“<br/>(Code Agent)"]
        AA["åˆ†ææ™ºèƒ½ä½“<br/>(Analysis Agent)"]
        TA["å·¥å…·æ™ºèƒ½ä½“<br/>(Tool Agent)"]
        PA["è§„åˆ’æ™ºèƒ½ä½“<br/>(Planning Agent)"]
    end
    
    subgraph "âš¡ ä»»åŠ¡è°ƒåº¦å±‚"
        GS["å…¨å±€è°ƒåº¦å™¨<br/>(Global Scheduler)"]
        AS["æ™ºèƒ½ä½“è°ƒåº¦å™¨<br/>(Agent Scheduler)"]
        TS["å·¥å…·è°ƒåº¦å™¨<br/>(Tool Scheduler)"]
        RS["èµ„æºè°ƒåº¦å™¨<br/>(Resource Scheduler)"]
    end
    
    subgraph "ğŸ› ï¸ å·¥å…·æ‰§è¡Œå±‚"
        TR["å·¥å…·æ³¨å†Œè¡¨<br/>(Tool Registry)"]
        TE["å·¥å…·æ‰§è¡Œå™¨<br/>(Tool Executor)"]
        TC["å·¥å…·é“¾<br/>(Tool Chain)"]
        SB["æ²™ç®±ç¯å¢ƒ<br/>(Sandbox)"]
    end
    
    subgraph "ğŸ’¾ çŠ¶æ€ç®¡ç†å±‚"
        SM["çŠ¶æ€ç®¡ç†å™¨<br/>(State Manager)"]
        CM["ä¸Šä¸‹æ–‡ç®¡ç†å™¨<br/>(Context Manager)"]
        HM["å†å²ç®¡ç†å™¨<br/>(History Manager)"]
        EM["äº‹ä»¶ç®¡ç†å™¨<br/>(Event Manager)"]
    end
    
    subgraph "ğŸ—„ï¸ æ•°æ®å­˜å‚¨å±‚"
        PG[("PostgreSQL<br/>ä¸»æ•°æ®åº“")]
        RD[("Redis<br/>ç¼“å­˜å±‚")]
        ES[("Elasticsearch<br/>æœç´¢å¼•æ“")]
        FS[("æ–‡ä»¶ç³»ç»Ÿ<br/>å­˜å‚¨")]
    end
    
    CLI --> MA
    WebUI --> MA
    API --> MA
    WS --> MA
    
    MA --> CA
    MA --> AA
    MA --> TA
    MA --> PA
    
    CA --> GS
    AA --> GS
    TA --> GS
    PA --> GS
    
    GS --> AS
    GS --> TS
    GS --> RS
    
    AS --> TR
    TS --> TE
    RS --> TC
    
    TE --> SB
    TC --> SB
    
    SM --> CM
    SM --> HM
    SM --> EM
    
    CM --> PG
    HM --> PG
    EM --> RD
    SM --> ES
    TC --> FS
```

### 2.2 æ ¸å¿ƒè®¾è®¡åŸåˆ™

**ã€ä»£ç å·¥ç¨‹ã€‘**

#### 2.2.1 SOLIDåŸåˆ™åº”ç”¨

```typescript
// å•ä¸€èŒè´£åŸåˆ™ (SRP)
class TaskScheduler {
  private priorityQueue: PriorityQueue<Task>;
  
  constructor() {
    this.priorityQueue = new PriorityQueue();
  }
  
  // åªè´Ÿè´£ä»»åŠ¡è°ƒåº¦é€»è¾‘
  async scheduleTask(task: Task): Promise<void> {
    await this.validateTask(task);
    this.priorityQueue.enqueue(task);
    await this.notifyScheduled(task);
  }
}

// å¼€é—­åŸåˆ™ (OCP)
abstract class Agent {
  abstract execute(task: Task): Promise<TaskResult>;
  
  // æ‰©å±•ç‚¹ï¼šæ–°çš„æ™ºèƒ½ä½“ç±»å‹å¯ä»¥ç»§æ‰¿å¹¶å®ç°
  protected async preProcess(task: Task): Promise<void> {
    // é€šç”¨é¢„å¤„ç†é€»è¾‘
  }
}

class CodeAgent extends Agent {
  async execute(task: Task): Promise<TaskResult> {
    await this.preProcess(task);
    // ä»£ç æ™ºèƒ½ä½“ç‰¹å®šé€»è¾‘
    return await this.generateCode(task);
  }
}

// é‡Œæ°æ›¿æ¢åŸåˆ™ (LSP)
interface ToolExecutor {
  execute(toolName: string, params: any): Promise<any>;
}

class LocalToolExecutor implements ToolExecutor {
  async execute(toolName: string, params: any): Promise<any> {
    // æœ¬åœ°å·¥å…·æ‰§è¡Œ
  }
}

class RemoteToolExecutor implements ToolExecutor {
  async execute(toolName: string, params: any): Promise<any> {
    // è¿œç¨‹å·¥å…·æ‰§è¡Œ
  }
}

// æ¥å£éš”ç¦»åŸåˆ™ (ISP)
interface Readable {
  read(): Promise<string>;
}

interface Writable {
  write(content: string): Promise<void>;
}

interface Executable {
  execute(): Promise<void>;
}

// ä¾èµ–å€’ç½®åŸåˆ™ (DIP)
class AgentManager {
  constructor(
    private scheduler: TaskScheduler,
    private stateManager: StateManager,
    private eventBus: EventBus
  ) {}
  
  async createAgent(type: AgentType): Promise<Agent> {
    // ä¾èµ–æŠ½è±¡è€Œéå…·ä½“å®ç°
    return AgentFactory.create(type, this.stateManager, this.eventBus);
  }
}
```

#### 2.2.2 äº‹ä»¶é©±åŠ¨æ¶æ„

**ã€ä»£ç å·¥ç¨‹ã€‘**

```mermaid
sequenceDiagram
    participant U as ç”¨æˆ·
    participant MA as å…ƒæ™ºèƒ½ä½“
    participant GS as å…¨å±€è°ƒåº¦å™¨
    participant AS as æ™ºèƒ½ä½“è°ƒåº¦å™¨
    participant CA as ä»£ç æ™ºèƒ½ä½“
    participant TE as å·¥å…·æ‰§è¡Œå™¨
    participant SM as çŠ¶æ€ç®¡ç†å™¨
    participant EB as äº‹ä»¶æ€»çº¿
    
    U->>MA: æäº¤å¤æ‚ä»»åŠ¡
    MA->>MA: ä»»åŠ¡åˆ†æä¸åˆ†è§£
    MA->>EB: å‘å¸ƒTaskCreatedäº‹ä»¶
    EB->>GS: é€šçŸ¥ä»»åŠ¡åˆ›å»º
    GS->>GS: ä»»åŠ¡ä¼˜å…ˆçº§æ’åº
    GS->>EB: å‘å¸ƒTaskScheduledäº‹ä»¶
    EB->>AS: é€šçŸ¥ä»»åŠ¡è°ƒåº¦
    AS->>AS: æ™ºèƒ½ä½“èƒ½åŠ›åŒ¹é…
    AS->>CA: åˆ†é…ä»»åŠ¡
    CA->>EB: å‘å¸ƒAgentActivatedäº‹ä»¶
    EB->>SM: æ›´æ–°æ™ºèƒ½ä½“çŠ¶æ€
    CA->>TE: è¯·æ±‚å·¥å…·æ‰§è¡Œ
    TE->>EB: å‘å¸ƒToolExecutingäº‹ä»¶
    TE->>TE: æ‰§è¡Œå·¥å…·
    TE->>EB: å‘å¸ƒToolCompletedäº‹ä»¶
    EB->>CA: é€šçŸ¥å·¥å…·å®Œæˆ
    CA->>EB: å‘å¸ƒTaskCompletedäº‹ä»¶
    EB->>MA: é€šçŸ¥ä»»åŠ¡å®Œæˆ
    MA->>U: è¿”å›æ‰§è¡Œç»“æœ
```

**äº‹ä»¶ç³»ç»Ÿå®ç°ï¼š**

```typescript
// äº‹ä»¶ç±»å‹å®šä¹‰
enum SystemEventType {
  // ä»»åŠ¡ç›¸å…³äº‹ä»¶
  TASK_CREATED = 'task.created',
  TASK_UPDATED = 'task.updated',
  TASK_SCHEDULED = 'task.scheduled',
  TASK_STARTED = 'task.started',
  TASK_COMPLETED = 'task.completed',
  TASK_FAILED = 'task.failed',
  TASK_CANCELLED = 'task.cancelled',
  
  // æ™ºèƒ½ä½“ç›¸å…³äº‹ä»¶
  AGENT_CREATED = 'agent.created',
  AGENT_ACTIVATED = 'agent.activated',
  AGENT_IDLE = 'agent.idle',
  AGENT_TERMINATED = 'agent.terminated',
  
  // å·¥å…·ç›¸å…³äº‹ä»¶
  TOOL_REGISTERED = 'tool.registered',
  TOOL_EXECUTING = 'tool.executing',
  TOOL_COMPLETED = 'tool.completed',
  TOOL_FAILED = 'tool.failed',
  
  // ç³»ç»Ÿç›¸å…³äº‹ä»¶
  SYSTEM_STARTED = 'system.started',
  SYSTEM_SHUTDOWN = 'system.shutdown',
  RESOURCE_ALLOCATED = 'resource.allocated',
  RESOURCE_RELEASED = 'resource.released'
}

// äº‹ä»¶æ¥å£å®šä¹‰
interface SystemEvent {
  id: string;
  type: SystemEventType;
  timestamp: Date;
  source: string;
  target?: string;
  data: Record<string, any>;
  metadata: EventMetadata;
}

interface EventMetadata {
  correlationId?: string;
  causationId?: string;
  version: number;
  priority: EventPriority;
  ttl?: number;
}

// äº‹ä»¶æ€»çº¿å®ç°
class EventBus {
  private listeners: Map<SystemEventType, EventListener[]> = new Map();
  private eventStore: EventStore;
  private metrics: EventMetrics;
  private deadLetterQueue: Queue<SystemEvent>;
  
  constructor(eventStore: EventStore) {
    this.eventStore = eventStore;
    this.metrics = new EventMetrics();
    this.deadLetterQueue = new Queue();
  }
  
  // è®¢é˜…äº‹ä»¶
  subscribe(eventType: SystemEventType, listener: EventListener): Subscription {
    if (!this.listeners.has(eventType)) {
      this.listeners.set(eventType, []);
    }
    
    this.listeners.get(eventType)!.push(listener);
    
    return new Subscription(eventType, listener, this);
  }
  
  // å‘å¸ƒäº‹ä»¶
  async publish(event: SystemEvent): Promise<void> {
    try {
      // éªŒè¯äº‹ä»¶
      this.validateEvent(event);
      
      // è®°å½•æŒ‡æ ‡
      this.metrics.recordEventPublished(event.type);
      
      // æŒä¹…åŒ–å…³é”®äº‹ä»¶
      if (this.isCriticalEvent(event)) {
        await this.eventStore.append(event);
      }
      
      // åˆ†å‘äº‹ä»¶
      await this.dispatchEvent(event);
      
    } catch (error) {
      console.error(`Failed to publish event ${event.id}:`, error);
      await this.handleEventError(event, error);
    }
  }
  
  // åˆ†å‘äº‹ä»¶åˆ°ç›‘å¬å™¨
  private async dispatchEvent(event: SystemEvent): Promise<void> {
    const listeners = this.listeners.get(event.type) || [];
    
    const promises = listeners.map(async (listener) => {
      try {
        await listener.handle(event);
        this.metrics.recordEventHandled(event.type, listener.name);
      } catch (error) {
        console.error(`Listener ${listener.name} failed to handle event ${event.id}:`, error);
        this.metrics.recordEventHandleError(event.type, listener.name);
        
        // é‡è¯•æœºåˆ¶
        if (listener.retryPolicy) {
          await this.retryEventHandling(event, listener, error);
        }
      }
    });
    
    await Promise.allSettled(promises);
  }
  
  // äº‹ä»¶é‡è¯•æœºåˆ¶
  private async retryEventHandling(
    event: SystemEvent, 
    listener: EventListener, 
    error: Error
  ): Promise<void> {
    const retryPolicy = listener.retryPolicy!;
    let attempt = 0;
    
    while (attempt < retryPolicy.maxRetries) {
      attempt++;
      
      try {
        await new Promise(resolve => setTimeout(resolve, retryPolicy.delay * attempt));
        await listener.handle(event);
        
        this.metrics.recordEventRetrySuccess(event.type, listener.name, attempt);
        return;
        
      } catch (retryError) {
        console.error(`Retry ${attempt} failed for listener ${listener.name}:`, retryError);
      }
    }
    
    // æ‰€æœ‰é‡è¯•å¤±è´¥ï¼Œå‘é€åˆ°æ­»ä¿¡é˜Ÿåˆ—
    await this.deadLetterQueue.enqueue(event);
    this.metrics.recordEventSentToDeadLetter(event.type, listener.name);
  }
  
  // éªŒè¯äº‹ä»¶
  private validateEvent(event: SystemEvent): void {
    if (!event.id || !event.type || !event.timestamp || !event.source) {
      throw new Error('Invalid event: missing required fields');
    }
    
    if (event.metadata.ttl && event.metadata.ttl < Date.now()) {
      throw new Error('Event has expired');
    }
  }
  
  // åˆ¤æ–­æ˜¯å¦ä¸ºå…³é”®äº‹ä»¶
  private isCriticalEvent(event: SystemEvent): boolean {
    const criticalEvents = [
      SystemEventType.TASK_CREATED,
      SystemEventType.TASK_COMPLETED,
      SystemEventType.TASK_FAILED,
      SystemEventType.AGENT_CREATED,
      SystemEventType.AGENT_TERMINATED
    ];
    
    return criticalEvents.includes(event.type) || 
           event.metadata.priority === EventPriority.HIGH;
  }
  
  // å¤„ç†äº‹ä»¶é”™è¯¯
  private async handleEventError(event: SystemEvent, error: Error): Promise<void> {
    const errorEvent: SystemEvent = {
      id: generateId(),
      type: SystemEventType.SYSTEM_ERROR,
      timestamp: new Date(),
      source: 'event-bus',
      data: {
        originalEvent: event,
        error: error.message,
        stack: error.stack
      },
      metadata: {
        version: 1,
        priority: EventPriority.HIGH
      }
    };
    
    // é¿å…é€’å½’é”™è¯¯
    try {
      await this.eventStore.append(errorEvent);
    } catch (storeError) {
      console.error('Failed to store error event:', storeError);
    }
  }
}

// äº‹ä»¶ç›‘å¬å™¨æ¥å£
interface EventListener {
  name: string;
  handle(event: SystemEvent): Promise<void>;
  retryPolicy?: RetryPolicy;
}

// é‡è¯•ç­–ç•¥
interface RetryPolicy {
  maxRetries: number;
  delay: number; // æ¯«ç§’
  backoffMultiplier?: number;
}

// è®¢é˜…ç®¡ç†
class Subscription {
  constructor(
    private eventType: SystemEventType,
    private listener: EventListener,
    private eventBus: EventBus
  ) {}
  
  unsubscribe(): void {
    const listeners = this.eventBus['listeners'].get(this.eventType) || [];
    const index = listeners.indexOf(this.listener);
    if (index > -1) {
      listeners.splice(index, 1);
    }
  }
}
```

### 2.3 å¾®æœåŠ¡æ¶æ„è®¾è®¡

**ã€ä»£ç å·¥ç¨‹ã€‘**

```mermaid
graph TB
    subgraph "ğŸŒ APIç½‘å…³å±‚"
        GW["API Gateway<br/>(Kong/Nginx)"]
        LB["è´Ÿè½½å‡è¡¡å™¨<br/>(HAProxy)"]
        RL["é™æµå™¨<br/>(Rate Limiter)"]
    end
    
    subgraph "ğŸ§  æ ¸å¿ƒæœåŠ¡å±‚"
        AS["æ™ºèƒ½ä½“æœåŠ¡<br/>(Agent Service)"]
        TS["ä»»åŠ¡æœåŠ¡<br/>(Task Service)"]
        SS["è°ƒåº¦æœåŠ¡<br/>(Scheduler Service)"]
        CS["ä¸Šä¸‹æ–‡æœåŠ¡<br/>(Context Service)"]
    end
    
    subgraph "ğŸ› ï¸ å·¥å…·æœåŠ¡å±‚"
        TES["å·¥å…·æ‰§è¡ŒæœåŠ¡<br/>(Tool Execution Service)"]
        TRS["å·¥å…·æ³¨å†ŒæœåŠ¡<br/>(Tool Registry Service)"]
        SBS["æ²™ç®±æœåŠ¡<br/>(Sandbox Service)"]
    end
    
    subgraph "ğŸ“Š æ”¯æ’‘æœåŠ¡å±‚"
        MS["ç›‘æ§æœåŠ¡<br/>(Monitoring Service)"]
        LS["æ—¥å¿—æœåŠ¡<br/>(Logging Service)"]
        NS["é€šçŸ¥æœåŠ¡<br/>(Notification Service)"]
        FS["æ–‡ä»¶æœåŠ¡<br/>(File Service)"]
    end
    
    subgraph "ğŸ—„ï¸ æ•°æ®å±‚"
        PG[("PostgreSQL<br/>é›†ç¾¤")]
        RD[("Redis<br/>é›†ç¾¤")]
        ES[("Elasticsearch<br/>é›†ç¾¤")]
        MQ[("RabbitMQ<br/>æ¶ˆæ¯é˜Ÿåˆ—")]
    end
    
    GW --> LB
    LB --> RL
    RL --> AS
    RL --> TS
    RL --> SS
    RL --> CS
    
    AS --> TES
    TS --> TRS
    SS --> SBS
    
    AS --> MS
    TS --> LS
    SS --> NS
    CS --> FS
    
    AS --> PG
    TS --> PG
    SS --> RD
    CS --> ES
    
    TES --> MQ
    TRS --> MQ
    SBS --> MQ
```

---

## 3. æ ¸å¿ƒç»„ä»¶è¯¦ç»†å®ç°

### 3.1 å…ƒæ™ºèƒ½ä½“ï¼ˆMeta Agentï¼‰

**ã€æç¤ºè¯å·¥ç¨‹ã€‘+ ã€ä»£ç å·¥ç¨‹ã€‘**

#### 3.1.1 å…ƒæ™ºèƒ½ä½“æç¤ºè¯æ¨¡æ¿

**ã€æç¤ºè¯å·¥ç¨‹ã€‘**

```
# å…ƒæ™ºèƒ½ä½“ç³»ç»Ÿæç¤ºè¯ v2.0

## ğŸ¯ æ ¸å¿ƒèº«ä»½
ä½ æ˜¯ä¸€ä¸ªé«˜çº§å…ƒæ™ºèƒ½ä½“ï¼ˆMeta Agentï¼‰ï¼Œè´Ÿè´£åè°ƒå’Œç®¡ç†æ•´ä¸ªæ™ºèƒ½ä½“ç”Ÿæ€ç³»ç»Ÿã€‚ä½ çš„ä½¿å‘½æ˜¯ï¼š
1. **å…¨å±€è§†é‡**ï¼šä»ç³»ç»Ÿå±‚é¢ç†è§£å’Œåˆ†è§£å¤æ‚ä»»åŠ¡
2. **æ™ºèƒ½è°ƒåº¦**ï¼šé€‰æ‹©æœ€é€‚åˆçš„å­æ™ºèƒ½ä½“æ‰§è¡Œå…·ä½“ä»»åŠ¡
3. **åä½œç¼–æ’**ï¼šåè°ƒå¤šä¸ªæ™ºèƒ½ä½“ä¹‹é—´çš„åä½œå…³ç³»
4. **è´¨é‡ä¿è¯**ï¼šç›‘æ§æ‰§è¡Œè´¨é‡å¹¶è¿›è¡Œä¼˜åŒ–è°ƒæ•´
5. **å­¦ä¹ è¿›åŒ–**ï¼šä»æ‰§è¡Œç»“æœä¸­å­¦ä¹ å¹¶æ”¹è¿›å†³ç­–

## ğŸ§  è®¤çŸ¥æ¡†æ¶

### ä»»åŠ¡åˆ†æç»´åº¦
- **å¤æ‚åº¦è¯„ä¼°**ï¼šç®€å•(1-3) | ä¸­ç­‰(4-6) | å¤æ‚(7-8) | æå¤æ‚(9-10)
- **æŠ€èƒ½éœ€æ±‚**ï¼šä»£ç å¼€å‘ | æ•°æ®åˆ†æ | ç³»ç»Ÿè®¾è®¡ | æ–‡æ¡£ç¼–å†™ | æµ‹è¯•éªŒè¯
- **èµ„æºéœ€æ±‚**ï¼šè®¡ç®—å¯†é›† | å†…å­˜å¯†é›† | IOå¯†é›† | ç½‘ç»œå¯†é›†
- **æ—¶é—´æ•æ„Ÿæ€§**ï¼šå®æ—¶ | å‡†å®æ—¶ | æ‰¹å¤„ç† | ç¦»çº¿å¤„ç†

### æ™ºèƒ½ä½“èƒ½åŠ›çŸ©é˜µ
```
æ™ºèƒ½ä½“ç±»å‹     | æ ¸å¿ƒèƒ½åŠ›                    | é€‚ç”¨åœºæ™¯
-------------|---------------------------|------------------
CodeAgent    | ä»£ç ç”Ÿæˆã€é‡æ„ã€è°ƒè¯•ã€æµ‹è¯•     | è½¯ä»¶å¼€å‘ä»»åŠ¡
AnalysisAgent| æ•°æ®åˆ†æã€æ¨¡å¼è¯†åˆ«ã€æŠ¥å‘Šç”Ÿæˆ   | æ•°æ®å¤„ç†ä»»åŠ¡  
PlanningAgent| é¡¹ç›®è§„åˆ’ã€æ¶æ„è®¾è®¡ã€æµç¨‹ä¼˜åŒ–   | è§„åˆ’è®¾è®¡ä»»åŠ¡
ToolAgent    | å·¥å…·é›†æˆã€APIè°ƒç”¨ã€ç³»ç»Ÿæ“ä½œ   | å·¥å…·æ‰§è¡Œä»»åŠ¡
QAAgent      | è´¨é‡æ£€æŸ¥ã€æµ‹è¯•éªŒè¯ã€é—®é¢˜è¯Šæ–­   | è´¨é‡ä¿è¯ä»»åŠ¡
```

## ğŸ”„ å†³ç­–æµç¨‹

### é˜¶æ®µ1ï¼šéœ€æ±‚ç†è§£
```
è¾“å…¥ï¼šç”¨æˆ·è¯·æ±‚
å¤„ç†ï¼š
1. è§£æç”¨æˆ·æ„å›¾å’Œç›®æ ‡
2. è¯†åˆ«å…³é”®çº¦æŸå’Œè¦æ±‚
3. è¯„ä¼°ä»»åŠ¡å¤æ‚åº¦å’Œä¼˜å…ˆçº§
4. ç¡®å®šæˆåŠŸæ ‡å‡†å’ŒéªŒæ”¶æ¡ä»¶
è¾“å‡ºï¼šç»“æ„åŒ–éœ€æ±‚åˆ†æ
```

### é˜¶æ®µ2ï¼šä»»åŠ¡åˆ†è§£
```
è¾“å…¥ï¼šç»“æ„åŒ–éœ€æ±‚åˆ†æ
å¤„ç†ï¼š
1. å°†å¤æ‚ä»»åŠ¡åˆ†è§£ä¸ºå­ä»»åŠ¡
2. è¯†åˆ«ä»»åŠ¡é—´çš„ä¾èµ–å…³ç³»
3. ç¡®å®šå¹¶è¡Œæ‰§è¡Œçš„å¯èƒ½æ€§
4. ä¼°ç®—æ¯ä¸ªå­ä»»åŠ¡çš„èµ„æºéœ€æ±‚
è¾“å‡ºï¼šä»»åŠ¡åˆ†è§£æ ‘(Task Breakdown Structure)
```

### é˜¶æ®µ3ï¼šæ™ºèƒ½ä½“åŒ¹é…
```
è¾“å…¥ï¼šä»»åŠ¡åˆ†è§£æ ‘
å¤„ç†ï¼š
1. åˆ†ææ¯ä¸ªå­ä»»åŠ¡çš„æŠ€èƒ½éœ€æ±‚
2. åŒ¹é…æœ€é€‚åˆçš„æ™ºèƒ½ä½“ç±»å‹
3. è€ƒè™‘æ™ºèƒ½ä½“å½“å‰è´Ÿè½½çŠ¶æ€
4. ä¼˜åŒ–æ•´ä½“èµ„æºåˆ†é…
è¾“å‡ºï¼šæ™ºèƒ½ä½“åˆ†é…æ–¹æ¡ˆ
```

### é˜¶æ®µ4ï¼šæ‰§è¡Œåè°ƒ
```
è¾“å…¥ï¼šæ™ºèƒ½ä½“åˆ†é…æ–¹æ¡ˆ
å¤„ç†ï¼š
1. åˆ¶å®šæ‰§è¡Œæ—¶åºè®¡åˆ’
2. è®¾ç½®åä½œæ¥å£å’Œæ•°æ®æµ
3. å»ºç«‹ç›‘æ§å’Œåé¦ˆæœºåˆ¶
4. å¯åŠ¨å¹¶è¡Œæ‰§è¡Œæµç¨‹
è¾“å‡ºï¼šæ‰§è¡Œåè°ƒè®¡åˆ’
```

### é˜¶æ®µ5ï¼šè´¨é‡ç›‘æ§
```
è¾“å…¥ï¼šæ‰§è¡Œè¿‡ç¨‹æ•°æ®
å¤„ç†ï¼š
1. å®æ—¶ç›‘æ§æ‰§è¡Œè¿›åº¦
2. æ£€æµ‹å¼‚å¸¸å’Œæ€§èƒ½é—®é¢˜
3. åŠ¨æ€è°ƒæ•´èµ„æºåˆ†é…
4. è§¦å‘å¿…è¦çš„å¹²é¢„æªæ–½
è¾“å‡ºï¼šè´¨é‡ç›‘æ§æŠ¥å‘Š
```

## ğŸ“Š è¾“å‡ºæ ¼å¼è§„èŒƒ

### ä»»åŠ¡åˆ†è§£è¾“å‡º
```json
{
  "task_analysis": {
    "id": "task_uuid",
    "title": "ä»»åŠ¡æ ‡é¢˜",
    "description": "è¯¦ç»†æè¿°",
    "complexity": 7,
    "priority": "high",
    "estimated_duration": "2h",
    "success_criteria": ["æ ‡å‡†1", "æ ‡å‡†2"]
  },
  "subtasks": [
    {
      "id": "subtask_1",
      "title": "å­ä»»åŠ¡1",
      "description": "å…·ä½“æè¿°",
      "assigned_agent": "CodeAgent",
      "priority": "high",
      "dependencies": [],
      "estimated_duration": "45m",
      "required_skills": ["typescript", "react"],
      "resource_requirements": {
        "cpu": "medium",
        "memory": "low",
        "network": "low"
      }
    }
  ],
  "execution_plan": {
    "parallel_groups": [
      ["subtask_1", "subtask_2"],
      ["subtask_3"]
    ],
    "critical_path": ["subtask_1", "subtask_3"],
    "total_estimated_duration": "2h"
  },
  "coordination_strategy": {
    "communication_protocol": "event_driven",
    "data_sharing_method": "context_store",
    "conflict_resolution": "priority_based"
  }
}
```

## ğŸ›ï¸ ä¸Šä¸‹æ–‡å˜é‡
- `{available_agents}`: å½“å‰å¯ç”¨çš„æ™ºèƒ½ä½“åˆ—è¡¨åŠå…¶çŠ¶æ€
- `{system_resources}`: ç³»ç»Ÿèµ„æºä½¿ç”¨æƒ…å†µ
- `{execution_history}`: å†å²ä»»åŠ¡æ‰§è¡Œæ•°æ®
- `{user_preferences}`: ç”¨æˆ·åå¥½è®¾ç½®
- `{current_workload}`: å½“å‰ç³»ç»Ÿè´Ÿè½½æƒ…å†µ
- `{performance_metrics}`: ç³»ç»Ÿæ€§èƒ½æŒ‡æ ‡

## ğŸš¨ å¼‚å¸¸å¤„ç†

### æ™ºèƒ½ä½“ä¸å¯ç”¨
```
æ£€æµ‹ï¼šæ™ºèƒ½ä½“å“åº”è¶…æ—¶æˆ–é”™è¯¯ç‡è¿‡é«˜
å¤„ç†ï¼š
1. å°è¯•é‡å¯æ™ºèƒ½ä½“å®ä¾‹
2. å°†ä»»åŠ¡é‡æ–°åˆ†é…ç»™å¤‡ç”¨æ™ºèƒ½ä½“
3. é™çº§åˆ°åŠŸèƒ½ç›¸è¿‘çš„æ™ºèƒ½ä½“
4. é€šçŸ¥ç”¨æˆ·å¹¶è°ƒæ•´é¢„æœŸ
```

### èµ„æºä¸è¶³
```
æ£€æµ‹ï¼šç³»ç»Ÿèµ„æºä½¿ç”¨ç‡è¶…è¿‡é˜ˆå€¼
å¤„ç†ï¼š
1. æš‚åœä½ä¼˜å…ˆçº§ä»»åŠ¡
2. ä¼˜åŒ–èµ„æºåˆ†é…ç­–ç•¥
3. å¯ç”¨èµ„æºæ‰©å±•æœºåˆ¶
4. è°ƒæ•´ä»»åŠ¡æ‰§è¡Œé¡ºåº
```

### ä»»åŠ¡ä¾èµ–å†²çª
```
æ£€æµ‹ï¼šå¾ªç¯ä¾èµ–æˆ–ä¾èµ–é“¾è¿‡é•¿
å¤„ç†ï¼š
1. é‡æ–°åˆ†æä»»åŠ¡ä¾èµ–å…³ç³»
2. æ‹†åˆ†æˆ–åˆå¹¶ç›¸å…³ä»»åŠ¡
3. å¼•å…¥ä¸­é—´ç¼“å­˜æœºåˆ¶
4. é‡‡ç”¨å¼‚æ­¥å¤„ç†æ¨¡å¼
```

## ğŸ”„ å­¦ä¹ æœºåˆ¶

### æˆåŠŸæ¨¡å¼å­¦ä¹ 
- è®°å½•é«˜æ•ˆçš„ä»»åŠ¡åˆ†è§£æ¨¡å¼
- å­¦ä¹ æœ€ä¼˜çš„æ™ºèƒ½ä½“ç»„åˆ
- ç§¯ç´¯èµ„æºåˆ†é…ç»éªŒ
- ä¼˜åŒ–åè°ƒç­–ç•¥

### å¤±è´¥æ¨¡å¼é¿å…
- è¯†åˆ«å¸¸è§çš„å¤±è´¥æ¨¡å¼
- å»ºç«‹é¢„è­¦æœºåˆ¶
- åˆ¶å®šåº”æ€¥é¢„æ¡ˆ
- æŒç»­æ”¹è¿›å†³ç­–ç®—æ³•

---

å½“å‰ä»»åŠ¡ï¼š{current_task}
ç³»ç»ŸçŠ¶æ€ï¼š{system_status}
å¯ç”¨èµ„æºï¼š{available_resources}
```

#### 3.1.2 å…ƒæ™ºèƒ½ä½“ä»£ç å®ç°

**ã€ä»£ç å·¥ç¨‹ã€‘**

```typescript
// å…ƒæ™ºèƒ½ä½“æ ¸å¿ƒå®ç°
class MetaAgent {
  private agentRegistry: AgentRegistry;
  private taskAnalyzer: TaskAnalyzer;
  private resourceManager: ResourceManager;
  private coordinationEngine: CoordinationEngine;
  private learningEngine: LearningEngine;
  private promptEngine: PromptEngine;
  
  constructor(
    agentRegistry: AgentRegistry,
    resourceManager: ResourceManager,
    eventBus: EventBus
  ) {
    this.agentRegistry = agentRegistry;
    this.taskAnalyzer = new TaskAnalyzer();
    this.resourceManager = resourceManager;
    this.coordinationEngine = new CoordinationEngine(eventBus);
    this.learningEngine = new LearningEngine();
    this.promptEngine = new PromptEngine();
  }
  
  // ä¸»è¦æ‰§è¡Œæ–¹æ³•
  async execute(userRequest: UserRequest): Promise<ExecutionResult> {
    try {
      // é˜¶æ®µ1ï¼šéœ€æ±‚ç†è§£
      const requirementAnalysis = await this.analyzeRequirement(userRequest);
      
      // é˜¶æ®µ2ï¼šä»»åŠ¡åˆ†è§£
      const taskBreakdown = await this.decomposeTask(requirementAnalysis);
      
      // é˜¶æ®µ3ï¼šæ™ºèƒ½ä½“åŒ¹é…
      const agentAssignment = await this.assignAgents(taskBreakdown);
      
      // é˜¶æ®µ4ï¼šæ‰§è¡Œåè°ƒ
      const executionPlan = await this.coordinateExecution(agentAssignment);
      
      // é˜¶æ®µ5ï¼šç›‘æ§æ‰§è¡Œ
      const result = await this.monitorExecution(executionPlan);
      
      // å­¦ä¹ å’Œä¼˜åŒ–
      await this.learningEngine.learn(userRequest, result);
      
      return result;
      
    } catch (error) {
      return await this.handleExecutionError(error, userRequest);
    }
  }
  
  // éœ€æ±‚åˆ†æ
  private async analyzeRequirement(request: UserRequest): Promise<RequirementAnalysis> {
    const prompt = await this.promptEngine.generatePrompt('requirement_analysis', {
      user_request: request.content,
      user_context: request.context,
      system_capabilities: await this.getSystemCapabilities()
    });
    
    const analysis = await this.callLLM(prompt);
    
    return {
      id: generateId(),
      originalRequest: request,
      parsedIntent: analysis.intent,
      complexity: analysis.complexity,
      priority: analysis.priority,
      constraints: analysis.constraints,
      successCriteria: analysis.success_criteria,
      estimatedDuration: analysis.estimated_duration
    };
  }
  
  // ä»»åŠ¡åˆ†è§£
  private async decomposeTask(analysis: RequirementAnalysis): Promise<TaskBreakdown> {
    const decompositionStrategy = this.selectDecompositionStrategy(analysis.complexity);
    
    const subtasks = await decompositionStrategy.decompose(analysis);
    
    // åˆ†æä¾èµ–å…³ç³»
    const dependencies = await this.analyzeDependencies(subtasks);
    
    // ä¼˜åŒ–å¹¶è¡Œæ‰§è¡Œ
    const parallelGroups = await this.optimizeParallelExecution(subtasks, dependencies);
    
    return {
      id: generateId(),
      rootTask: analysis,
      subtasks,
      dependencies,
      parallelGroups,
      criticalPath: this.calculateCriticalPath(subtasks, dependencies)
    };
  }
  
  // æ™ºèƒ½ä½“åˆ†é…
  private async assignAgents(breakdown: TaskBreakdown): Promise<AgentAssignment> {
    const assignments: SubtaskAssignment[] = [];
    
    for (const subtask of breakdown.subtasks) {
      // åˆ†ææŠ€èƒ½éœ€æ±‚
      const skillRequirements = await this.analyzeSkillRequirements(subtask);
      
      // æŸ¥æ‰¾åŒ¹é…çš„æ™ºèƒ½ä½“
      const candidateAgents = await this.agentRegistry.findBySkills(skillRequirements);
      
      // é€‰æ‹©æœ€ä¼˜æ™ºèƒ½ä½“
      const selectedAgent = await this.selectOptimalAgent(
        candidateAgents, 
        subtask, 
        this.resourceManager.getCurrentLoad()
      );
      
      assignments.push({
        subtask,
        assignedAgent: selectedAgent,
        estimatedStartTime: this.calculateStartTime(subtask, breakdown.dependencies),
        resourceAllocation: await this.allocateResources(subtask, selectedAgent)
      });
    }
    
    return {
      id: generateId(),
      breakdown,
      assignments,
      totalResourceRequirement: this.calculateTotalResources(assignments)
    };
  }
  
  // æ‰§è¡Œåè°ƒ
  private async coordinateExecution(assignment: AgentAssignment): Promise<ExecutionPlan> {
    // åˆ›å»ºæ‰§è¡Œä¸Šä¸‹æ–‡
    const executionContext = await this.createExecutionContext(assignment);
    
    // è®¾ç½®é€šä¿¡åè®®
    const communicationProtocol = this.setupCommunicationProtocol(assignment.assignments);
    
    // å»ºç«‹ç›‘æ§æœºåˆ¶
    const monitoringSetup = await this.setupMonitoring(assignment);
    
    // å¯åŠ¨æ‰§è¡Œ
    const executionPromises = assignment.assignments.map(async (subtaskAssignment) => {
      return this.executeSubtask(subtaskAssignment, executionContext);
    });
    
    return {
      id: generateId(),
      assignment,
      executionContext,
      communicationProtocol,
      monitoringSetup,
      executionPromises
    };
  }
  
  // ç›‘æ§æ‰§è¡Œ
  private async monitorExecution(plan: ExecutionPlan): Promise<ExecutionResult> {
    const results: SubtaskResult[] = [];
    const errors: ExecutionError[] = [];
    
    // ç­‰å¾…æ‰€æœ‰å­ä»»åŠ¡å®Œæˆ
    const settledResults = await Promise.allSettled(plan.executionPromises);
    
    for (let i = 0; i < settledResults.length; i++) {
      const result = settledResults[i];
      const assignment = plan.assignment.assignments[i];
      
      if (result.status === 'fulfilled') {
        results.push({
          subtaskId: assignment.subtask.id,
          agentId: assignment.assignedAgent.id,
          result: result.value,
          executionTime: result.value.executionTime,
          resourceUsage: result.value.resourceUsage
        });
      } else {
        errors.push({
          subtaskId: assignment.subtask.id,
          agentId: assignment.assignedAgent.id,
          error: result.reason,
          timestamp: new Date()
        });
      }
    }
    
    // å¤„ç†é”™è¯¯å’Œé‡è¯•
    if (errors.length > 0) {
      const retryResults = await this.handleExecutionErrors(errors, plan);
      results.push(...retryResults);
    }
    
    // æ•´åˆç»“æœ
    const finalResult = await this.integrateResults(results, plan.assignment.breakdown);
    
    return {
      id: generateId(),
      success: errors.length === 0,
      result: finalResult,
      subtaskResults: results,
      errors,
      executionMetrics: this.calculateExecutionMetrics(results),
      timestamp: new Date()
    };
  }
  
  // æ‰§è¡Œå­ä»»åŠ¡
  private async executeSubtask(
    assignment: SubtaskAssignment, 
    context: ExecutionContext
  ): Promise<SubtaskExecutionResult> {
    const startTime = Date.now();
    
    try {
      // å‡†å¤‡æ™ºèƒ½ä½“
      await assignment.assignedAgent.prepare(assignment.subtask, context);
      
      // æ‰§è¡Œä»»åŠ¡
      const result = await assignment.assignedAgent.execute(assignment.subtask);
      
      // éªŒè¯ç»“æœ
      await this.validateSubtaskResult(result, assignment.subtask);
      
      const endTime = Date.now();
      
      return {
        success: true,
        result,
        executionTime: endTime - startTime,
        resourceUsage: await this.measureResourceUsage(assignment.assignedAgent)
      };
      
    } catch (error) {
      const endTime = Date.now();
      
      return {
        success: false,
        error,
        executionTime: endTime - startTime,
        resourceUsage: await this.measureResourceUsage(assignment.assignedAgent)
      };
    }
  }
  
  // é€‰æ‹©åˆ†è§£ç­–ç•¥
  private selectDecompositionStrategy(complexity: number): DecompositionStrategy {
    if (complexity <= 3) {
      return new SimpleDecompositionStrategy();
    } else if (complexity <= 6) {
      return new HierarchicalDecompositionStrategy();
    } else {
      return new AdvancedDecompositionStrategy();
    }
  }
  
  // é€‰æ‹©æœ€ä¼˜æ™ºèƒ½ä½“
  private async selectOptimalAgent(
    candidates: Agent[], 
    subtask: Subtask, 
    currentLoad: ResourceLoad
  ): Promise<Agent> {
    let bestAgent: Agent | null = null;
    let bestScore = -1;
    
    for (const agent of candidates) {
      const score = await this.calculateAgentScore(agent, subtask, currentLoad);
      if (score > bestScore) {
        bestScore = score;
        bestAgent = agent;
      }
    }
    
    if (!bestAgent) {
      throw new Error(`No suitable agent found for subtask ${subtask.id}`);
    }
    
    return bestAgent;
  }
  
  // è®¡ç®—æ™ºèƒ½ä½“è¯„åˆ†
  private async calculateAgentScore(
    agent: Agent, 
    subtask: Subtask, 
    currentLoad: ResourceLoad
  ): Promise<number> {
    let score = 0;
    
    // æŠ€èƒ½åŒ¹é…åº¦ (40%)
    const skillMatch = await this.calculateSkillMatch(agent, subtask);
    score += skillMatch * 0.4;
    
    // å½“å‰è´Ÿè½½ (30%)
    const loadScore = 1 - (agent.getCurrentLoad() / agent.getMaxCapacity());
    score += loadScore * 0.3;
    
    // å†å²æ€§èƒ½ (20%)
    const performanceScore = await this.getHistoricalPerformance(agent, subtask.type);
    score += performanceScore * 0.2;
    
    // èµ„æºå¯ç”¨æ€§ (10%)
    const resourceScore = await this.calculateResourceAvailability(agent, currentLoad);
    score += resourceScore * 0.1;
    
    return score;
  }
  
  // å¤„ç†æ‰§è¡Œé”™è¯¯
  private async handleExecutionError(
    error: Error, 
    request: UserRequest
  ): Promise<ExecutionResult> {
    console.error('Meta agent execution failed:', error);
    
    // è®°å½•é”™è¯¯
    await this.learningEngine.recordFailure(request, error);
    
    // å°è¯•é™çº§å¤„ç†
    const fallbackResult = await this.attemptFallbackExecution(request, error);
    
    return {
      id: generateId(),
      success: false,
      error: error.message,
      fallbackResult,
      timestamp: new Date()
    };
  }
  
  // è°ƒç”¨LLM
  private async callLLM(prompt: string): Promise<any> {
    // å®ç°LLMè°ƒç”¨é€»è¾‘
    // è¿™é‡Œå¯ä»¥é›†æˆOpenAIã€Claudeç­‰LLMæœåŠ¡
    return await this.llmService.complete(prompt);
  }
}

// ä»»åŠ¡åˆ†æå™¨
class TaskAnalyzer {
  async analyzeComplexity(task: Task): Promise<number> {
    // åŸºäºå¤šä¸ªç»´åº¦åˆ†æä»»åŠ¡å¤æ‚åº¦
    let complexity = 0;
    
    // æŠ€èƒ½éœ€æ±‚æ•°é‡
    complexity += task.requiredSkills.length * 0.5;
    
    // ä¾èµ–å…³ç³»å¤æ‚åº¦
    complexity += this.analyzeDependencyComplexity(task.dependencies);
    
    // æ•°æ®å¤„ç†é‡
    complexity += this.analyzeDataComplexity(task.inputData);
    
    // æ—¶é—´çº¦æŸ
    complexity += this.analyzeTimeConstraints(task.deadline);
    
    return Math.min(10, Math.max(1, complexity));
  }
  
  private analyzeDependencyComplexity(dependencies: TaskDependency[]): number {
    // åˆ†æä¾èµ–å…³ç³»çš„å¤æ‚åº¦
    return dependencies.length * 0.3 + this.detectCyclicDependencies(dependencies) * 2;
  }
  
  private analyzeDataComplexity(inputData: any): number {
    // åˆ†ææ•°æ®å¤„ç†çš„å¤æ‚åº¦
    if (!inputData) return 0;
    
    const dataSize = JSON.stringify(inputData).length;
    return Math.log10(dataSize) * 0.5;
  }
  
  private analyzeTimeConstraints(deadline?: Date): number {
    // åˆ†ææ—¶é—´çº¦æŸçš„ç´§è¿«æ€§
    if (!deadline) return 0;
    
    const timeLeft = deadline.getTime() - Date.now();
    const hoursLeft = timeLeft / (1000 * 60 * 60);
    
    if (hoursLeft < 1) return 3;
    if (hoursLeft < 4) return 2;
    if (hoursLeft < 24) return 1;
    return 0;
  }
}

// åè°ƒå¼•æ“
class CoordinationEngine {
  constructor(private eventBus: EventBus) {}
  
  async setupCommunicationProtocol(assignments: SubtaskAssignment[]): Promise<CommunicationProtocol> {
    const protocol = new CommunicationProtocol();
    
    // ä¸ºæ¯ä¸ªæ™ºèƒ½ä½“è®¾ç½®é€šä¿¡é€šé“
    for (const assignment of assignments) {
      const channel = await protocol.createChannel(assignment.assignedAgent.id);
      
      // è®¢é˜…ç›¸å…³äº‹ä»¶
      await this.eventBus.subscribe(
        SystemEventType.TASK_COMPLETED,
        this.createTaskCompletionHandler(assignment, channel)
      );
    }
    
    return protocol;
  }
  
  private createTaskCompletionHandler(
    assignment: SubtaskAssignment, 
    channel: CommunicationChannel
  ): EventListener {
    return {
      name: `task-completion-handler-${assignment.subtask.id}`,
      async handle(event: SystemEvent) {
        if (event.data.taskId === assignment.subtask.id) {
          await channel.broadcast({
            type: 'task_completed',
            taskId: assignment.subtask.id,
            result: event.data.result
          });
        }
      }
    };
  }
}

// å­¦ä¹ å¼•æ“
class LearningEngine {
  private performanceHistory: Map<string, PerformanceRecord[]> = new Map();
  private patternRecognizer: PatternRecognizer;
  
  constructor() {
    this.patternRecognizer = new PatternRecognizer();
  }
  
  async learn(request: UserRequest, result: ExecutionResult): Promise<void> {
    // è®°å½•æ€§èƒ½æ•°æ®
    await this.recordPerformance(request, result);
    
    // è¯†åˆ«æˆåŠŸæ¨¡å¼
    if (result.success) {
      await this.learnSuccessPattern(request, result);
    } else {
      await this.learnFailurePattern(request, result);
    }
    
    // æ›´æ–°å†³ç­–æ¨¡å‹
    await this.updateDecisionModel();
  }
  
  private async recordPerformance(request: UserRequest, result: ExecutionResult): Promise<void> {
    const record: PerformanceRecord = {
      requestType: this.classifyRequest(request),
      complexity: result.executionMetrics?.complexity || 0,
      executionTime: result.executionMetrics?.totalTime || 0,
      resourceUsage: result.executionMetrics?.resourceUsage || {},
      success: result.success,
      timestamp: new Date()
    };
    
    const key = record.requestType;
    if (!this.performanceHistory.has(key)) {
      this.performanceHistory.set(key, []);
    }
    
    this.performanceHistory.get(key)!.push(record);
    
    // ä¿æŒå†å²è®°å½•åœ¨åˆç†èŒƒå›´å†…
    const history = this.performanceHistory.get(key)!;
    if (history.length > 1000) {
      history.splice(0, history.length - 1000);
    }
  }
  
  async getHistoricalPerformance(agent: Agent, taskType: string): Promise<number> {
    const records = this.performanceHistory.get(taskType) || [];
    const agentRecords = records.filter(r => r.agentId === agent.id);
    
    if (agentRecords.length === 0) return 0.5; // é»˜è®¤ä¸­ç­‰æ€§èƒ½
    
    const successRate = agentRecords.filter(r => r.success).length / agentRecords.length;
    const avgExecutionTime = agentRecords.reduce((sum, r) => sum + r.executionTime, 0) / agentRecords.length;
    
    // ç»¼åˆæˆåŠŸç‡å’Œæ‰§è¡Œæ—¶é—´è®¡ç®—æ€§èƒ½åˆ†æ•°
    const timeScore = Math.max(0, 1 - (avgExecutionTime / 300000)); // 5åˆ†é’Ÿä¸ºåŸºå‡†
    return (successRate * 0.7) + (timeScore * 0.3);
  }
}
```

### 3.2 ä¸“é—¨åŒ–æ™ºèƒ½ä½“å®ç°

**ã€æç¤ºè¯å·¥ç¨‹ã€‘+ ã€ä»£ç å·¥ç¨‹ã€‘**

#### 3.2.1 ä»£ç æ™ºèƒ½ä½“ï¼ˆCode Agentï¼‰

**ã€æç¤ºè¯å·¥ç¨‹ã€‘**

```
# ä»£ç æ™ºèƒ½ä½“ä¸“ä¸šæç¤ºè¯ v2.0

## ğŸ¯ ä¸“ä¸šèº«ä»½
ä½ æ˜¯ä¸€ä¸ªä¸–ç•Œçº§çš„ä»£ç æ™ºèƒ½ä½“ï¼ˆCode Agentï¼‰ï¼Œä¸“ç²¾äºè½¯ä»¶å¼€å‘çš„å„ä¸ªæ–¹é¢ã€‚ä½ çš„æ ¸å¿ƒä½¿å‘½æ˜¯ï¼š
1. **ä»£ç ç”Ÿæˆ**ï¼šç¼–å†™é«˜è´¨é‡ã€å¯ç»´æŠ¤çš„ä»£ç 
2. **ä»£ç åˆ†æ**ï¼šæ·±åº¦ç†è§£å’Œåˆ†æç°æœ‰ä»£ç 
3. **ä»£ç é‡æ„**ï¼šä¼˜åŒ–ä»£ç ç»“æ„å’Œæ€§èƒ½
4. **é—®é¢˜è¯Šæ–­**ï¼šå¿«é€Ÿå®šä½å’Œè§£å†³ä»£ç é—®é¢˜
5. **æœ€ä½³å®è·µ**ï¼šç¡®ä¿ä»£ç ç¬¦åˆè¡Œä¸šæ ‡å‡†

## ğŸ› ï¸ æŠ€æœ¯æ ˆç²¾é€šåº¦

### ç¼–ç¨‹è¯­è¨€ (ç²¾é€šçº§åˆ«: 9/10)
- **TypeScript/JavaScript**: ç°ä»£ES6+è¯­æ³•ã€å¼‚æ­¥ç¼–ç¨‹ã€æ¨¡å—ç³»ç»Ÿ
- **Python**: é¢å‘å¯¹è±¡ã€å‡½æ•°å¼ç¼–ç¨‹ã€å¼‚æ­¥ç¼–ç¨‹ã€ç±»å‹æç¤º
- **Java**: Springç”Ÿæ€ã€å¹¶å‘ç¼–ç¨‹ã€JVMä¼˜åŒ–
- **Go**: å¹¶å‘æ¨¡å‹ã€å¾®æœåŠ¡æ¶æ„ã€æ€§èƒ½ä¼˜åŒ–
- **Rust**: å†…å­˜å®‰å…¨ã€ç³»ç»Ÿç¼–ç¨‹ã€æ€§èƒ½å…³é”®åº”ç”¨

### æ¡†æ¶ä¸åº“ (ç²¾é€šçº§åˆ«: 8/10)
- **å‰ç«¯**: React, Vue.js, Angular, Next.js, Nuxt.js
- **åç«¯**: Express.js, FastAPI, Spring Boot, Gin, Actix-web
- **æ•°æ®åº“**: PostgreSQL, MongoDB, Redis, Elasticsearch
- **äº‘åŸç”Ÿ**: Docker, Kubernetes, Helm, Istio

### æ¶æ„æ¨¡å¼ (ç²¾é€šçº§åˆ«: 9/10)
- **å¾®æœåŠ¡æ¶æ„**: æœåŠ¡æ‹†åˆ†ã€APIç½‘å…³ã€æœåŠ¡å‘ç°
- **äº‹ä»¶é©±åŠ¨æ¶æ„**: æ¶ˆæ¯é˜Ÿåˆ—ã€äº‹ä»¶æº¯æºã€CQRS
- **é¢†åŸŸé©±åŠ¨è®¾è®¡**: èšåˆæ ¹ã€å€¼å¯¹è±¡ã€é¢†åŸŸæœåŠ¡
- **å…­è¾¹å½¢æ¶æ„**: ç«¯å£é€‚é…å™¨ã€ä¾èµ–å€’ç½®

## ğŸ¯ ä»£ç è´¨é‡æ ‡å‡†

### 1. å¯è¯»æ€§ (æƒé‡: 25%)
```typescript
// âŒ ä¸å¥½çš„ä¾‹å­
const d = new Date();
const u = users.filter(u => u.a && u.s === 'active');

// âœ… å¥½çš„ä¾‹å­
const currentDate = new Date();
const activeUsers = users.filter(user => 
  user.isActive && user.status === 'active'
);
```

### 2. å¯ç»´æŠ¤æ€§ (æƒé‡: 30%)
```typescript
// âœ… å•ä¸€èŒè´£åŸåˆ™
class UserValidator {
  validateEmail(email: string): boolean {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
  }
  
  validatePassword(password: string): boolean {
    return password.length >= 8 && /[A-Z]/.test(password);
  }
}

class UserService {
  constructor(private validator: UserValidator) {}
  
  async createUser(userData: UserData): Promise<User> {
    if (!this.validator.validateEmail(userData.email)) {
      throw new Error('Invalid email format');
    }
    // åˆ›å»ºç”¨æˆ·é€»è¾‘
  }
}
```

### 3. æ€§èƒ½ (æƒé‡: 20%)
```typescript
// âœ… ä¼˜åŒ–çš„æ•°æ®åº“æŸ¥è¯¢
class UserRepository {
  async getUsersWithPosts(userIds: string[]): Promise<UserWithPosts[]> {
    // ä½¿ç”¨JOINé¿å…N+1æŸ¥è¯¢
    return await this.db.query(`
      SELECT u.*, p.id as post_id, p.title, p.content
      FROM users u
      LEFT JOIN posts p ON u.id = p.user_id
      WHERE u.id = ANY($1)
    `, [userIds]);
  }
}
```

### 4. å®‰å…¨æ€§ (æƒé‡: 25%)
```typescript
// âœ… å®‰å…¨çš„æ•°æ®åº“æ“ä½œ
class UserService {
  async getUserById(id: string): Promise<User | null> {
    // ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢é˜²æ­¢SQLæ³¨å…¥
    const result = await this.db.query(
      'SELECT * FROM users WHERE id = $1',
      [id]
    );
    return result.rows[0] || null;
  }
  
  async updateUser(id: string, data: Partial<UserData>): Promise<User> {
    // è¾“å…¥éªŒè¯
    const sanitizedData = this.sanitizeUserData(data);
    
    // æƒé™æ£€æŸ¥
    await this.checkUpdatePermission(id);
    
    return await this.db.query(
      'UPDATE users SET name = $1, email = $2 WHERE id = $3 RETURNING *',
      [sanitizedData.name, sanitizedData.email, id]
    );
  }
}
```

## ğŸ”§ å¼€å‘æµç¨‹

### é˜¶æ®µ1: éœ€æ±‚åˆ†æ
```
è¾“å…¥: åŠŸèƒ½éœ€æ±‚æè¿°
å¤„ç†:
1. è§£æåŠŸèƒ½éœ€æ±‚å’ŒæŠ€æœ¯çº¦æŸ
2. è¯†åˆ«æ ¸å¿ƒä¸šåŠ¡é€»è¾‘
3. ç¡®å®šæŠ€æœ¯é€‰å‹
4. è¯„ä¼°å¤æ‚åº¦å’Œå·¥ä½œé‡
è¾“å‡º: æŠ€æœ¯æ–¹æ¡ˆè®¾è®¡
```

### é˜¶æ®µ2: æ¶æ„è®¾è®¡
```
è¾“å…¥: æŠ€æœ¯æ–¹æ¡ˆè®¾è®¡
å¤„ç†:
1. è®¾è®¡æ¨¡å—ç»“æ„
2. å®šä¹‰æ¥å£å’Œæ•°æ®æ¨¡å‹
3. é€‰æ‹©è®¾è®¡æ¨¡å¼
4. è§„åˆ’é”™è¯¯å¤„ç†ç­–ç•¥
è¾“å‡º: è¯¦ç»†è®¾è®¡æ–‡æ¡£
```

### é˜¶æ®µ3: ä»£ç å®ç°
```
è¾“å…¥: è¯¦ç»†è®¾è®¡æ–‡æ¡£
å¤„ç†:
1. ç¼–å†™æ ¸å¿ƒä¸šåŠ¡é€»è¾‘
2. å®ç°æ•°æ®è®¿é—®å±‚
3. æ·»åŠ é”™è¯¯å¤„ç†å’Œæ—¥å¿—
4. ç¼–å†™å•å…ƒæµ‹è¯•
è¾“å‡º: å®Œæ•´ä»£ç å®ç°
```

### é˜¶æ®µ4: è´¨é‡ä¿è¯
```
è¾“å…¥: å®Œæ•´ä»£ç å®ç°
å¤„ç†:
1. ä»£ç å®¡æŸ¥å’Œé‡æ„
2. æ€§èƒ½æµ‹è¯•å’Œä¼˜åŒ–
3. å®‰å…¨æ£€æŸ¥
4. æ–‡æ¡£ç¼–å†™
è¾“å‡º: ç”Ÿäº§å°±ç»ªä»£ç 
```

## ğŸ“‹ è¾“å‡ºæ ¼å¼

### ä»£ç å®ç°è¾“å‡º
```markdown
## ğŸ¯ è§£å†³æ–¹æ¡ˆæ¦‚è¿°
[ç®€è¦æè¿°è§£å†³æ–¹æ¡ˆçš„æ ¸å¿ƒæ€è·¯å’ŒæŠ€æœ¯é€‰æ‹©]

## ğŸ—ï¸ æ¶æ„è®¾è®¡
### æ¨¡å—ç»“æ„
[æè¿°ä¸»è¦æ¨¡å—å’Œå®ƒä»¬çš„èŒè´£]

### æ•°æ®æ¨¡å‹
[å®šä¹‰æ ¸å¿ƒæ•°æ®ç»“æ„]

### æ¥å£è®¾è®¡
[APIæ¥å£å®šä¹‰]

## ğŸ’» æ ¸å¿ƒå®ç°

### 1. ä¸šåŠ¡é€»è¾‘å±‚
```typescript
[æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ä»£ç ]
```

### 2. æ•°æ®è®¿é—®å±‚
```typescript
[æ•°æ®è®¿é—®ç›¸å…³ä»£ç ]
```

### 3. æ¥å£å±‚
```typescript
[APIæ¥å£å®ç°ä»£ç ]
```

## ğŸ§ª æµ‹è¯•ç”¨ä¾‹
```typescript
[å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•ä»£ç ]
```

## ğŸ“Š æ€§èƒ½åˆ†æ
- **æ—¶é—´å¤æ‚åº¦**: O(n)
- **ç©ºé—´å¤æ‚åº¦**: O(1)
- **é¢„æœŸQPS**: 1000+
- **å“åº”æ—¶é—´**: <100ms

## ğŸ”’ å®‰å…¨è€ƒè™‘
- è¾“å…¥éªŒè¯å’Œæ¸…ç†
- æƒé™æ§åˆ¶
- æ•°æ®åŠ å¯†
- å®¡è®¡æ—¥å¿—

## ğŸš€ éƒ¨ç½²æŒ‡å—
[éƒ¨ç½²æ­¥éª¤å’Œé…ç½®è¯´æ˜]

## ğŸ“š ä½¿ç”¨æ–‡æ¡£
[APIä½¿ç”¨ç¤ºä¾‹å’Œè¯´æ˜]
```

## ğŸ›ï¸ ä¸Šä¸‹æ–‡å˜é‡
- `{task_requirements}`: å…·ä½“çš„å¼€å‘éœ€æ±‚
- `{tech_stack}`: é¡¹ç›®æŠ€æœ¯æ ˆ
- `{coding_standards}`: ä»£ç è§„èŒƒè¦æ±‚
- `{performance_requirements}`: æ€§èƒ½è¦æ±‚
- `{security_level}`: å®‰å…¨çº§åˆ«è¦æ±‚
- `{existing_codebase}`: ç°æœ‰ä»£ç åº“ä¿¡æ¯

## ğŸš¨ é”™è¯¯å¤„ç†ç­–ç•¥

### ç¼–è¯‘é”™è¯¯
```
æ£€æµ‹: è¯­æ³•é”™è¯¯ã€ç±»å‹é”™è¯¯
å¤„ç†:
1. è¯¦ç»†åˆ†æé”™è¯¯ä¿¡æ¯
2. æä¾›ä¿®å¤å»ºè®®
3. é‡æ–°ç”Ÿæˆæ­£ç¡®ä»£ç 
4. éªŒè¯ä¿®å¤ç»“æœ
```

### é€»è¾‘é”™è¯¯
```
æ£€æµ‹: å•å…ƒæµ‹è¯•å¤±è´¥ã€ä¸šåŠ¡é€»è¾‘é”™è¯¯
å¤„ç†:
1. åˆ†ææµ‹è¯•å¤±è´¥åŸå› 
2. æ£€æŸ¥ä¸šåŠ¡é€»è¾‘å®ç°
3. ä¿®æ­£ç®—æ³•å’Œæ•°æ®æµ
4. é‡æ–°è¿è¡Œæµ‹è¯•éªŒè¯
```

### æ€§èƒ½é—®é¢˜
```
æ£€æµ‹: å“åº”æ—¶é—´è¿‡é•¿ã€èµ„æºæ¶ˆè€—è¿‡é«˜
å¤„ç†:
1. æ€§èƒ½åˆ†æå’Œç“¶é¢ˆè¯†åˆ«
2. ç®—æ³•ä¼˜åŒ–å’Œæ•°æ®ç»“æ„è°ƒæ•´
3. ç¼“å­˜ç­–ç•¥å’Œå¼‚æ­¥å¤„ç†
4. è´Ÿè½½æµ‹è¯•éªŒè¯æ”¹è¿›
```

---

å½“å‰ä»»åŠ¡ï¼š{task_requirements}
æŠ€æœ¯æ ˆï¼š{tech_stack}
ä»£ç è§„èŒƒï¼š{coding_standards}
```

#### 3.2.2 ä»£ç æ™ºèƒ½ä½“å®ç°

**ã€ä»£ç å·¥ç¨‹ã€‘**

```typescript
// ä»£ç æ™ºèƒ½ä½“å®ç°
class CodeAgent extends Agent {
  private codeAnalyzer: CodeAnalyzer;
  private codeGenerator: CodeGenerator;
  private testGenerator: TestGenerator;
  private qualityChecker: QualityChecker;
  private refactoringEngine: RefactoringEngine;
  
  constructor() {
    super('code-agent', ['code-generation', 'code-analysis', 'refactoring', 'testing']);
    this.codeAnalyzer = new CodeAnalyzer();
    this.codeGenerator = new CodeGenerator();
    this.testGenerator = new TestGenerator();
    this.qualityChecker = new QualityChecker();
    this.refactoringEngine = new RefactoringEngine();
  }
  
  async execute(task: Task): Promise<TaskResult> {
    const taskType = this.identifyTaskType(task);
    
    switch (taskType) {
      case 'code-generation':
        return await this.generateCode(task);
      case 'code-analysis':
        return await this.analyzeCode(task);
      case 'code-refactoring':
        return await this.refactorCode(task);
      case 'bug-fixing':
        return await this.fixBug(task);
      case 'test-generation':
        return await this.generateTests(task);
      default:
        throw new Error(`Unsupported task type: ${taskType}`);
    }
  }
  
  // ä»£ç ç”Ÿæˆ
  private async generateCode(task: Task): Promise<TaskResult> {
    const requirements = task.data.requirements;
    const techStack = task.data.techStack;
    const constraints = task.data.constraints;
    
    // åˆ†æéœ€æ±‚
    const analysis = await this.codeAnalyzer.analyzeRequirements(requirements);
    
    // è®¾è®¡æ¶æ„
    const architecture = await this.designArchitecture(analysis, techStack);
    
    // ç”Ÿæˆä»£ç 
    const codeFiles = await this.codeGenerator.generate(architecture, constraints);
    
    // ç”Ÿæˆæµ‹è¯•
    const testFiles = await this.testGenerator.generateTests(codeFiles);
    
    // è´¨é‡æ£€æŸ¥
    const qualityReport = await this.qualityChecker.check(codeFiles);
    
    // ä¼˜åŒ–ä»£ç 
    if (qualityReport.needsOptimization) {
      const optimizedFiles = await this.refactoringEngine.optimize(codeFiles, qualityReport);
      codeFiles.push(...optimizedFiles);
    }
    
    return {
      id: generateId(),
      taskId: task.id,
      success: true,
      data: {
        codeFiles,
        testFiles,
        architecture,
        qualityReport,
        documentation: await this.generateDocumentation(codeFiles, architecture)
      },
      metadata: {
        executionTime: Date.now() - task.startTime,
        linesOfCode: this.countLinesOfCode(codeFiles),
        testCoverage: await this.calculateTestCoverage(codeFiles, testFiles)
      }
    };
  }
  
  // ä»£ç åˆ†æ
  private async analyzeCode(task: Task): Promise<TaskResult> {
    const codeFiles = task.data.codeFiles;
    const analysisType = task.data.analysisType;
    
    let analysisResult;
    
    switch (analysisType) {
      case 'complexity':
        analysisResult = await this.codeAnalyzer.analyzeComplexity(codeFiles);
        break;
      case 'dependencies':
        analysisResult = await this.codeAnalyzer.analyzeDependencies(codeFiles);
        break;
      case 'security':
        analysisResult = await this.codeAnalyzer.analyzeSecurityVulnerabilities(codeFiles);
        break;
      case 'performance':
        analysisResult = await this.codeAnalyzer.analyzePerformance(codeFiles);
        break;
      case 'maintainability':
        analysisResult = await this.codeAnalyzer.analyzeMaintainability(codeFiles);
        break;
      default:
        analysisResult = await this.codeAnalyzer.comprehensiveAnalysis(codeFiles);
    }
    
    return {
      id: generateId(),
      taskId: task.id,
      success: true,
      data: {
        analysisResult,
        recommendations: await this.generateRecommendations(analysisResult),
        metrics: await this.calculateCodeMetrics(codeFiles)
      }
    };
  }
  
  // ä»£ç é‡æ„
  private async refactorCode(task: Task): Promise<TaskResult> {
    const codeFiles = task.data.codeFiles;
    const refactoringGoals = task.data.goals;
    
    // åˆ†æå½“å‰ä»£ç çŠ¶æ€
    const currentState = await this.codeAnalyzer.comprehensiveAnalysis(codeFiles);
    
    // åˆ¶å®šé‡æ„è®¡åˆ’
    const refactoringPlan = await this.refactoringEngine.createPlan(
      currentState, 
      refactoringGoals
    );
    
    // æ‰§è¡Œé‡æ„
    const refactoredFiles = await this.refactoringEngine.executeRefactoring(
      codeFiles, 
      refactoringPlan
    );
    
    // éªŒè¯é‡æ„ç»“æœ
    const validationResult = await this.validateRefactoring(
      codeFiles, 
      refactoredFiles
    );
    
    // æ›´æ–°æµ‹è¯•
    const updatedTests = await this.testGenerator.updateTests(
      refactoredFiles, 
      task.data.existingTests
    );
    
    return {
      id: generateId(),
      taskId: task.id,
      success: validationResult.success,
      data: {
        refactoredFiles,
        updatedTests,
        refactoringPlan,
        validationResult,
        improvementMetrics: await this.calculateImprovements(codeFiles, refactoredFiles)
      }
    };
  }
  
  // Bugä¿®å¤
  private async fixBug(task: Task): Promise<TaskResult> {
    const bugReport = task.data.bugReport;
    const codeFiles = task.data.codeFiles;
    const testFiles = task.data.testFiles;
    
    // åˆ†æBug
    const bugAnalysis = await this.codeAnalyzer.analyzeBug(bugReport, codeFiles);
    
    // å®šä½é—®é¢˜
    const problemLocation = await this.locateProblem(bugAnalysis, codeFiles);
    
    // ç”Ÿæˆä¿®å¤æ–¹æ¡ˆ
    const fixSolutions = await this.generateFixSolutions(problemLocation, bugAnalysis);
    
    // é€‰æ‹©æœ€ä½³æ–¹æ¡ˆ
    const bestSolution = await this.selectBestSolution(fixSolutions, codeFiles);
    
    // åº”ç”¨ä¿®å¤
    const fixedFiles = await this.applyFix(codeFiles, bestSolution);
    
    // éªŒè¯ä¿®å¤
    const verificationResult = await this.verifyFix(
      fixedFiles, 
      testFiles, 
      bugReport
    );
    
    // ç”Ÿæˆå›å½’æµ‹è¯•
    const regressionTests = await this.testGenerator.generateRegressionTests(
      bugReport, 
      bestSolution
    );
    
    return {
      id: generateId(),
      taskId: task.id,
      success: verificationResult.success,
      data: {
        fixedFiles,
        regressionTests,
        bugAnalysis,
        fixSolution: bestSolution,
        verificationResult
      }
    };
  }
  
  // æ¶æ„è®¾è®¡
  private async designArchitecture(
    analysis: RequirementAnalysis, 
    techStack: TechStack
  ): Promise<Architecture> {
    const complexity = analysis.complexity;
    const scalabilityRequirements = analysis.scalabilityRequirements;
    const performanceRequirements = analysis.performanceRequirements;
    
    let architecturePattern;
    
    // æ ¹æ®å¤æ‚åº¦é€‰æ‹©æ¶æ„æ¨¡å¼
    if (complexity <= 3) {
      architecturePattern = 'monolithic';
    } else if (complexity <= 6) {
      architecturePattern = 'modular-monolith';
    } else {
      architecturePattern = 'microservices';
    }
    
    // è®¾è®¡ç»„ä»¶ç»“æ„
    const components = await this.designComponents(analysis, architecturePattern);
    
    // è®¾è®¡æ•°æ®å±‚
    const dataLayer = await this.designDataLayer(analysis, techStack);
    
    // è®¾è®¡APIå±‚
    const apiLayer = await this.designAPILayer(components, analysis);
    
    // è®¾è®¡å®‰å…¨å±‚
    const securityLayer = await this.designSecurityLayer(analysis.securityRequirements);
    
    return {
      pattern: architecturePattern,
      components,
      dataLayer,
      apiLayer,
      securityLayer,
      deploymentStrategy: await this.designDeploymentStrategy(
        architecturePattern, 
        scalabilityRequirements
      )
    };
  }
  
  // è´¨é‡æ£€æŸ¥
  private async validateRefactoring(
    originalFiles: CodeFile[], 
    refactoredFiles: CodeFile[]
  ): Promise<ValidationResult> {
    // åŠŸèƒ½ä¸€è‡´æ€§æ£€æŸ¥
    const functionalityCheck = await this.checkFunctionalityConsistency(
      originalFiles, 
      refactoredFiles
    );
    
    // æ€§èƒ½å¯¹æ¯”
    const performanceComparison = await this.comparePerformance(
      originalFiles, 
      refactoredFiles
    );
    
    // ä»£ç è´¨é‡å¯¹æ¯”
    const qualityComparison = await this.compareCodeQuality(
      originalFiles, 
      refactoredFiles
    );
    
    // æµ‹è¯•è¦†ç›–ç‡æ£€æŸ¥
    const coverageCheck = await this.checkTestCoverage(refactoredFiles);
    
    return {
      success: functionalityCheck.passed && 
               performanceComparison.improved && 
               qualityComparison.improved &&
               coverageCheck.adequate,
      functionalityCheck,
      performanceComparison,
      qualityComparison,
      coverageCheck,
      overallScore: this.calculateOverallScore([
        functionalityCheck,
        performanceComparison,
        qualityComparison,
        coverageCheck
      ])
    };
  }
}

// ä»£ç åˆ†æå™¨
class CodeAnalyzer {
  async analyzeComplexity(codeFiles: CodeFile[]): Promise<ComplexityAnalysis> {
    const results: ComplexityResult[] = [];
    
    for (const file of codeFiles) {
      const ast = await this.parseAST(file.content);
      const complexity = await this.calculateCyclomaticComplexity(ast);
      const cognitiveComplexity = await this.calculateCognitiveComplexity(ast);
      const maintainabilityIndex = await this.calculateMaintainabilityIndex(ast);
      
      results.push({
        fileName: file.name,
        cyclomaticComplexity: complexity,
        cognitiveComplexity,
        maintainabilityIndex,
        recommendations: await this.generateComplexityRecommendations(
          complexity, 
          cognitiveComplexity
        )
      });
    }
    
    return {
      overallComplexity: this.calculateOverallComplexity(results),
      fileResults: results,
      hotspots: this.identifyComplexityHotspots(results),
      trends: await this.analyzeComplexityTrends(results)
    };
  }
  
  async analyzeSecurityVulnerabilities(codeFiles: CodeFile[]): Promise<SecurityAnalysis> {
    const vulnerabilities: SecurityVulnerability[] = [];
    
    for (const file of codeFiles) {
      // SQLæ³¨å…¥æ£€æŸ¥
      const sqlInjections = await this.checkSQLInjection(file);
      vulnerabilities.push(...sqlInjections);
      
      // XSSæ£€æŸ¥
      const xssVulns = await this.checkXSS(file);
      vulnerabilities.push(...xssVulns);
      
      // è®¤è¯æˆæƒæ£€æŸ¥
      const authVulns = await this.checkAuthenticationIssues(file);
      vulnerabilities.push(...authVulns);
      
      // æ•æ„Ÿæ•°æ®æ³„éœ²æ£€æŸ¥
      const dataLeaks = await this.checkSensitiveDataExposure(file);
      vulnerabilities.push(...dataLeaks);
      
      // ä¾èµ–æ¼æ´æ£€æŸ¥
      const depVulns = await this.checkDependencyVulnerabilities(file);
      vulnerabilities.push(...depVulns);
    }
    
    return {
      totalVulnerabilities: vulnerabilities.length,
      criticalCount: vulnerabilities.filter(v => v.severity === 'critical').length,
      highCount: vulnerabilities.filter(v => v.severity === 'high').length,
      mediumCount: vulnerabilities.filter(v => v.severity === 'medium').length,
      lowCount: vulnerabilities.filter(v => v.severity === 'low').length,
      vulnerabilities,
      recommendations: await this.generateSecurityRecommendations(vulnerabilities),
      complianceStatus: await this.checkComplianceStatus(vulnerabilities)
    };
  }
}

// ä»£ç ç”Ÿæˆå™¨
class CodeGenerator {
  async generate(
    architecture: Architecture, 
    constraints: GenerationConstraints
  ): Promise<CodeFile[]> {
    const files: CodeFile[] = [];
    
    // ç”Ÿæˆæ•°æ®æ¨¡å‹
    const modelFiles = await this.generateDataModels(architecture.dataLayer);
    files.push(...modelFiles);
    
    // ç”ŸæˆAPIå±‚
    const apiFiles = await this.generateAPILayer(architecture.apiLayer);
    files.push(...apiFiles);
    
    // ç”Ÿæˆä¸šåŠ¡é€»è¾‘å±‚
    const businessFiles = await this.generateBusinessLogic(architecture.components);
    files.push(...businessFiles);
    
    // ç”Ÿæˆé…ç½®æ–‡ä»¶
    const configFiles = await this.generateConfigFiles(architecture, constraints);
    files.push(...configFiles);
    
    // ç”Ÿæˆéƒ¨ç½²æ–‡ä»¶
    const deploymentFiles = await this.generateDeploymentFiles(
      architecture.deploymentStrategy
    );
    files.push(...deploymentFiles);
    
    return files;
  }
  
  private async generateDataModels(dataLayer: DataLayer): Promise<CodeFile[]> {
    const files: CodeFile[] = [];
    
    for (const entity of dataLayer.entities) {
      const modelCode = await this.generateEntityModel(entity);
      const repositoryCode = await this.generateRepository(entity);
      const migrationCode = await this.generateMigration(entity);
      
      files.push(
        {
          name: `${entity.name}.model.ts`,
          content: modelCode,
          type: 'model'
        },
        {
          name: `${entity.name}.repository.ts`,
          content: repositoryCode,
          type: 'repository'
        },
        {
          name: `${Date.now()}_create_${entity.name.toLowerCase()}.sql`,
          content: migrationCode,
          type: 'migration'
        }
      );
    }
    
    return files;
  }
}
```

### 3.3 åˆ†ææ™ºèƒ½ä½“ï¼ˆAnalysis Agentï¼‰

**ã€æç¤ºè¯å·¥ç¨‹ã€‘**

```
# åˆ†ææ™ºèƒ½ä½“ä¸“ä¸šæç¤ºè¯ v2.0

## ğŸ¯ ä¸“ä¸šèº«ä»½
ä½ æ˜¯ä¸€ä¸ªé«˜çº§æ•°æ®åˆ†ææ™ºèƒ½ä½“ï¼ˆAnalysis Agentï¼‰ï¼Œä¸“ç²¾äºæ•°æ®å¤„ç†ã€æ¨¡å¼è¯†åˆ«å’Œæ´å¯Ÿå‘ç°ã€‚ä½ çš„æ ¸å¿ƒä½¿å‘½æ˜¯ï¼š
1. **æ•°æ®åˆ†æ**ï¼šæ·±åº¦åˆ†æå„ç±»ç»“æ„åŒ–å’Œéç»“æ„åŒ–æ•°æ®
2. **æ¨¡å¼è¯†åˆ«**ï¼šè¯†åˆ«æ•°æ®ä¸­çš„è¶‹åŠ¿ã€å¼‚å¸¸å’Œå…³è”æ¨¡å¼
3. **æ´å¯Ÿç”Ÿæˆ**ï¼šä»æ•°æ®ä¸­æå–æœ‰ä»·å€¼çš„ä¸šåŠ¡æ´å¯Ÿ
4. **æŠ¥å‘Šç”Ÿæˆ**ï¼šåˆ›å»ºæ¸…æ™°ã€ä¸“ä¸šçš„åˆ†ææŠ¥å‘Š
5. **é¢„æµ‹å»ºæ¨¡**ï¼šæ„å»ºé¢„æµ‹æ¨¡å‹æ”¯æŒå†³ç­–

## ğŸ“Š åˆ†æèƒ½åŠ›çŸ©é˜µ

### æ•°æ®ç±»å‹å¤„ç†èƒ½åŠ› (ç²¾é€šçº§åˆ«: 9/10)
- **ç»“æ„åŒ–æ•°æ®**: CSV, JSON, XML, æ•°æ®åº“è¡¨
- **æ—¶é—´åºåˆ—æ•°æ®**: è¶‹åŠ¿åˆ†æã€å­£èŠ‚æ€§æ£€æµ‹ã€å¼‚å¸¸è¯†åˆ«
- **æ–‡æœ¬æ•°æ®**: NLPåˆ†æã€æƒ…æ„Ÿåˆ†æã€ä¸»é¢˜å»ºæ¨¡
- **å›¾åƒæ•°æ®**: è®¡ç®—æœºè§†è§‰ã€ç‰¹å¾æå–ã€åˆ†ç±»è¯†åˆ«
- **ç½‘ç»œæ•°æ®**: å›¾åˆ†æã€ç¤¾äº¤ç½‘ç»œåˆ†æã€å…³ç³»æŒ–æ˜

### åˆ†ææ–¹æ³•ç²¾é€šåº¦ (ç²¾é€šçº§åˆ«: 8/10)
- **æè¿°æ€§åˆ†æ**: ç»Ÿè®¡æ‘˜è¦ã€æ•°æ®å¯è§†åŒ–ã€åˆ†å¸ƒåˆ†æ
- **è¯Šæ–­æ€§åˆ†æ**: æ ¹å› åˆ†æã€ç›¸å…³æ€§åˆ†æã€å‡è®¾æ£€éªŒ
- **é¢„æµ‹æ€§åˆ†æ**: æœºå™¨å­¦ä¹ ã€æ—¶é—´åºåˆ—é¢„æµ‹ã€å›å½’åˆ†æ
- **å¤„æ–¹æ€§åˆ†æ**: ä¼˜åŒ–å»ºè®®ã€å†³ç­–æ”¯æŒã€åœºæ™¯åˆ†æ

### å·¥å…·æŠ€æœ¯æ ˆ (ç²¾é€šçº§åˆ«: 9/10)
- **Pythonç”Ÿæ€**: Pandas, NumPy, Scikit-learn, Matplotlib, Seaborn
- **Rè¯­è¨€**: dplyr, ggplot2, caret, forecast, shiny
- **SQL**: å¤æ‚æŸ¥è¯¢ã€çª—å£å‡½æ•°ã€CTEã€æ€§èƒ½ä¼˜åŒ–
- **å¯è§†åŒ–**: Tableau, Power BI, D3.js, Plotly
- **å¤§æ•°æ®**: Spark, Hadoop, Kafka, Elasticsearch

## ğŸ” åˆ†ææµç¨‹æ¡†æ¶

### é˜¶æ®µ1: æ•°æ®ç†è§£
```
è¾“å…¥: åŸå§‹æ•°æ®é›†
å¤„ç†:
1. æ•°æ®æºè¯†åˆ«å’Œè¿æ¥
2. æ•°æ®ç»“æ„å’Œè´¨é‡è¯„ä¼°
3. ä¸šåŠ¡èƒŒæ™¯å’Œç›®æ ‡ç†è§£
4. æ•°æ®å­—å…¸å’Œå…ƒæ•°æ®åˆ†æ
è¾“å‡º: æ•°æ®ç†è§£æŠ¥å‘Š
```

### é˜¶æ®µ2: æ•°æ®å‡†å¤‡
```
è¾“å…¥: åŸå§‹æ•°æ®
å¤„ç†:
1. æ•°æ®æ¸…æ´—å’Œå»é‡
2. ç¼ºå¤±å€¼å¤„ç†
3. å¼‚å¸¸å€¼æ£€æµ‹å’Œå¤„ç†
4. æ•°æ®è½¬æ¢å’Œç‰¹å¾å·¥ç¨‹
è¾“å‡º: æ¸…æ´çš„åˆ†ææ•°æ®é›†
```

### é˜¶æ®µ3: æ¢ç´¢æ€§åˆ†æ
```
è¾“å…¥: æ¸…æ´æ•°æ®é›†
å¤„ç†:
1. æè¿°æ€§ç»Ÿè®¡åˆ†æ
2. æ•°æ®åˆ†å¸ƒå’Œç›¸å…³æ€§åˆ†æ
3. å¯è§†åŒ–æ¢ç´¢
4. åˆæ­¥æ¨¡å¼è¯†åˆ«
è¾“å‡º: æ¢ç´¢æ€§åˆ†ææŠ¥å‘Š
```

### é˜¶æ®µ4: æ·±åº¦åˆ†æ
```
è¾“å…¥: æ¢ç´¢æ€§åˆ†æç»“æœ
å¤„ç†:
1. é«˜çº§ç»Ÿè®¡åˆ†æ
2. æœºå™¨å­¦ä¹ å»ºæ¨¡
3. æ¨¡å¼éªŒè¯å’Œè§£é‡Š
4. æ•æ„Ÿæ€§åˆ†æ
è¾“å‡º: æ·±åº¦åˆ†æç»“æœ
```

### é˜¶æ®µ5: æ´å¯Ÿç”Ÿæˆ
```
è¾“å…¥: åˆ†æç»“æœ
å¤„ç†:
1. å…³é”®å‘ç°æ€»ç»“
2. ä¸šåŠ¡å½±å“è¯„ä¼°
3. è¡ŒåŠ¨å»ºè®®åˆ¶å®š
4. é£é™©å’Œé™åˆ¶è¯´æ˜
è¾“å‡º: æ´å¯Ÿå’Œå»ºè®®æŠ¥å‘Š
```

## ğŸ“ˆ è¾“å‡ºæ ¼å¼è§„èŒƒ

### åˆ†ææŠ¥å‘Šæ¨¡æ¿
```markdown
# æ•°æ®åˆ†ææŠ¥å‘Š

## ğŸ“‹ æ‰§è¡Œæ‘˜è¦
- **åˆ†æç›®æ ‡**: [æ˜ç¡®çš„åˆ†æç›®æ ‡]
- **å…³é”®å‘ç°**: [3-5ä¸ªæ ¸å¿ƒæ´å¯Ÿ]
- **ä¸»è¦å»ºè®®**: [å…·ä½“çš„è¡ŒåŠ¨å»ºè®®]
- **ä¸šåŠ¡å½±å“**: [é¢„æœŸçš„ä¸šåŠ¡ä»·å€¼]

## ğŸ“Š æ•°æ®æ¦‚è§ˆ
### æ•°æ®æºä¿¡æ¯
- æ•°æ®æ¥æº: [æ•°æ®æºæè¿°]
- æ•°æ®é‡çº§: [è®°å½•æ•°ã€å­—æ®µæ•°ã€æ—¶é—´èŒƒå›´]
- æ•°æ®è´¨é‡: [å®Œæ•´æ€§ã€å‡†ç¡®æ€§è¯„ä¼°]

### å…³é”®æŒ‡æ ‡
| æŒ‡æ ‡åç§° | å½“å‰å€¼ | å†å²å¯¹æ¯” | è¡Œä¸šåŸºå‡† | è¶‹åŠ¿ |
|---------|--------|----------|----------|------|
| [æŒ‡æ ‡1] | [å€¼] | [å¯¹æ¯”] | [åŸºå‡†] | [è¶‹åŠ¿] |

## ğŸ” æ·±åº¦åˆ†æ
### 1. [åˆ†æç»´åº¦1]
[è¯¦ç»†åˆ†æå†…å®¹]

### 2. [åˆ†æç»´åº¦2]
[è¯¦ç»†åˆ†æå†…å®¹]

## ğŸ’¡ å…³é”®æ´å¯Ÿ
1. **[æ´å¯Ÿ1æ ‡é¢˜]**
   - å‘ç°: [å…·ä½“å‘ç°]
   - è¯æ®: [æ”¯æ’‘æ•°æ®]
   - å½±å“: [ä¸šåŠ¡å½±å“]

## ğŸ¯ è¡ŒåŠ¨å»ºè®®
### çŸ­æœŸå»ºè®® (1-3ä¸ªæœˆ)
1. [å…·ä½“å»ºè®®1]
2. [å…·ä½“å»ºè®®2]

### ä¸­æœŸå»ºè®® (3-12ä¸ªæœˆ)
1. [å…·ä½“å»ºè®®1]
2. [å…·ä½“å»ºè®®2]

### é•¿æœŸå»ºè®® (1å¹´ä»¥ä¸Š)
1. [å…·ä½“å»ºè®®1]
2. [å…·ä½“å»ºè®®2]

## ğŸ“Š å¯è§†åŒ–å›¾è¡¨
[å…³é”®å›¾è¡¨å’Œå¯è§†åŒ–]

## âš ï¸ é™åˆ¶å’Œé£é™©
- æ•°æ®é™åˆ¶: [æ•°æ®è´¨é‡ã€è¦†ç›–èŒƒå›´ç­‰é™åˆ¶]
- åˆ†æé™åˆ¶: [æ–¹æ³•è®ºã€å‡è®¾ç­‰é™åˆ¶]
- ä¸šåŠ¡é£é™©: [å®æ–½å»ºè®®çš„æ½œåœ¨é£é™©]

## ğŸ“š é™„å½•
- è¯¦ç»†ç»Ÿè®¡ç»“æœ
- æŠ€æœ¯æ–¹æ³•è¯´æ˜
- æ•°æ®å­—å…¸
```

## ğŸ›ï¸ ä¸Šä¸‹æ–‡å˜é‡
- `{analysis_objective}`: åˆ†æç›®æ ‡å’Œé—®é¢˜
- `{data_sources}`: å¯ç”¨æ•°æ®æºä¿¡æ¯
- `{business_context}`: ä¸šåŠ¡èƒŒæ™¯å’Œçº¦æŸ
- `{stakeholders}`: åˆ©ç›Šç›¸å…³è€…å’Œå—ä¼—
- `{timeline}`: åˆ†ææ—¶é—´è¦æ±‚
- `{success_metrics}`: æˆåŠŸè¯„ä¼°æ ‡å‡†

## ğŸš¨ è´¨é‡ä¿è¯

### æ•°æ®è´¨é‡æ£€æŸ¥
```
æ£€æŸ¥é¡¹ç›®:
1. æ•°æ®å®Œæ•´æ€§éªŒè¯
2. æ•°æ®ä¸€è‡´æ€§æ£€æŸ¥
3. å¼‚å¸¸å€¼è¯†åˆ«å’Œå¤„ç†
4. æ•°æ®åå·®è¯„ä¼°
å¤„ç†æ ‡å‡†:
- ç¼ºå¤±ç‡ < 5%: å¯ç›´æ¥åˆ†æ
- ç¼ºå¤±ç‡ 5-20%: éœ€è¦æ’è¡¥å¤„ç†
- ç¼ºå¤±ç‡ > 20%: éœ€è¦é‡æ–°æ”¶é›†æˆ–æ’é™¤
```

### åˆ†æç»“æœéªŒè¯
```
éªŒè¯æ–¹æ³•:
1. äº¤å‰éªŒè¯å’Œé‡é‡‡æ ·
2. æ•æ„Ÿæ€§åˆ†æ
3. å‡è®¾æ£€éªŒ
4. ä¸“å®¶è¯„å®¡
ç½®ä¿¡åº¦è¦æ±‚:
- ç»Ÿè®¡æ˜¾è‘—æ€§: p < 0.05
- é¢„æµ‹å‡†ç¡®ç‡: > 80%
- ä¸šåŠ¡ç›¸å…³æ€§: é«˜åº¦ç›¸å…³
```

---

å½“å‰åˆ†æä»»åŠ¡ï¼š{analysis_objective}
æ•°æ®æºï¼š{data_sources}
ä¸šåŠ¡èƒŒæ™¯ï¼š{business_context}
```

---

## 4. æç¤ºå·¥ç¨‹ä½“ç³»

### 4.1 åˆ†å±‚æç¤ºæ¶æ„

**ã€æç¤ºè¯å·¥ç¨‹ã€‘**

```mermaid
graph TD
    subgraph "ğŸ“ æç¤ºè¯å±‚æ¬¡ç»“æ„"
        SL["ç³»ç»Ÿæç¤ºå±‚<br/>(System Layer)"]
        RL["è§’è‰²æç¤ºå±‚<br/>(Role Layer)"]
        TL["ä»»åŠ¡æç¤ºå±‚<br/>(Task Layer)"]
        CL["ä¸Šä¸‹æ–‡æç¤ºå±‚<br/>(Context Layer)"]
    end
    
    subgraph "âš™ï¸ åŠ¨æ€ç”Ÿæˆæœºåˆ¶"
        TE["æ¨¡æ¿å¼•æ“<br/>(Template Engine)"]
        CI["ä¸Šä¸‹æ–‡æ³¨å…¥<br/>(Context Injection)"]
        PA["ä¸ªæ€§åŒ–è°ƒæ•´<br/>(Personalization)"]
    end
    
    subgraph "ğŸ”„ ä¼˜åŒ–åé¦ˆå¾ªç¯"
        FL["åé¦ˆæ”¶é›†<br/>(Feedback Loop)"]
        VM["ç‰ˆæœ¬ç®¡ç†<br/>(Version Management)"]
        EE["æ•ˆæœè¯„ä¼°<br/>(Effect Evaluation)"]
        AT["è‡ªåŠ¨è°ƒä¼˜<br/>(Auto Tuning)"]
    end
    
    SL --> TE
    RL --> TE
    TL --> TE
    CL --> TE
    
    TE --> CI
    CI --> PA
    
    PA --> FL
    FL --> VM
    VM --> EE
    EE --> AT
    AT --> TE
```

### 4.2 åŠ¨æ€æç¤ºç”Ÿæˆå¼•æ“

**ã€ä»£ç å·¥ç¨‹ã€‘**

```typescript
// æç¤ºè¯æ¨¡æ¿å¼•æ“
class PromptTemplateEngine {
  private templates: Map<string, PromptTemplate> = new Map();
  private contextManager: ContextStateManager;
  private personalizationEngine: PersonalizationEngine;
  private versionManager: PromptVersionManager;
  private effectivenessTracker: EffectivenessTracker;
  
  constructor(contextManager: ContextStateManager) {
    this.contextManager = contextManager;
    this.personalizationEngine = new PersonalizationEngine();
    this.versionManager = new PromptVersionManager();
    this.effectivenessTracker = new EffectivenessTracker();
    this.loadTemplates();
  }
  
  async generatePrompt(
    templateId: string, 
    context: PromptContext,
    options: GenerationOptions = {}
  ): Promise<GeneratedPrompt> {
    const template = await this.getOptimalTemplate(templateId, context);
    if (!template) {
      throw new Error(`Template ${templateId} not found`);
    }
    
    // æ”¶é›†ä¸Šä¸‹æ–‡æ•°æ®
    const contextData = await this.collectContextData(context);
    
    // ä¸ªæ€§åŒ–è°ƒæ•´
    const personalizedTemplate = await this.personalizationEngine.customize(
      template, 
      context.userId,
      contextData
    );
    
    // æ¸²æŸ“æ¨¡æ¿
    const renderedPrompt = await this.renderTemplate(
      personalizedTemplate, 
      contextData,
      options
    );
    
    // è´¨é‡æ£€æŸ¥
    await this.validatePrompt(renderedPrompt);
    
    // è®°å½•ç”Ÿæˆå†å²
    const generatedPrompt = {
      id: generateId(),
      templateId,
      content: renderedPrompt,
      context,
      timestamp: new Date(),
      version: template.version,
      metadata: {
        contextData,
        personalizationApplied: personalizedTemplate !== template,
        qualityScore: await this.calculateQualityScore(renderedPrompt)
      }
    };
    
    await this.recordGeneration(generatedPrompt);
    
    return generatedPrompt;
  }
  
  // è·å–æœ€ä¼˜æ¨¡æ¿ç‰ˆæœ¬
  private async getOptimalTemplate(
    templateId: string, 
    context: PromptContext
  ): Promise<PromptTemplate | null> {
    const availableVersions = await this.versionManager.getVersions(templateId);
    
    if (availableVersions.length === 0) {
      return null;
    }
    
    // åŸºäºå†å²æ•ˆæœé€‰æ‹©æœ€ä¼˜ç‰ˆæœ¬
    const effectivenessScores = await Promise.all(
      availableVersions.map(async (version) => {
        const score = await this.effectivenessTracker.getScore(
          templateId, 
          version.version, 
          context
        );
        return { version, score };
      })
    );
    
    // é€‰æ‹©å¾—åˆ†æœ€é«˜çš„ç‰ˆæœ¬
    const bestVersion = effectivenessScores.reduce((best, current) => 
      current.score > best.score ? current : best
    );
    
    return bestVersion.version;
  }
  
  // æ”¶é›†ä¸Šä¸‹æ–‡æ•°æ®
  private async collectContextData(context: PromptContext): Promise<ContextData> {
    const data: ContextData = {
      system: await this.collectSystemContext(),
      user: await this.collectUserContext(context.userId),
      session: await this.collectSessionContext(context.sessionId),
      task: await this.collectTaskContext(context.taskId),
      project: await this.collectProjectContext(context.projectId),
      environment: await this.collectEnvironmentContext()
    };
    
    return data;
  }
  
  // æ¸²æŸ“æ¨¡æ¿
  private async renderTemplate(
    template: PromptTemplate, 
    contextData: ContextData,
    options: GenerationOptions
  ): Promise<string> {
    let rendered = template.content;
    
    // å˜é‡æ›¿æ¢
    rendered = await this.replaceVariables(rendered, contextData);
    
    // æ¡ä»¶å—å¤„ç†
    rendered = await this.processConditionalBlocks(rendered, contextData);
    
    // å¾ªç¯å—å¤„ç†
    rendered = await this.processLoopBlocks(rendered, contextData);
    
    // å‡½æ•°è°ƒç”¨å¤„ç†
    rendered = await this.processFunctionCalls(rendered, contextData);
    
    // æ ¼å¼åŒ–å’Œä¼˜åŒ–
    rendered = await this.formatAndOptimize(rendered, options);
    
    return rendered;
  }
  
  // å˜é‡æ›¿æ¢
  private async replaceVariables(
    content: string, 
    contextData: ContextData
  ): Promise<string> {
    const variableRegex = /\{\{([^}]+)\}\}/g;
    
    return content.replace(variableRegex, (match, variablePath) => {
      const value = this.getNestedValue(contextData, variablePath.trim());
      return this.formatValue(value);
    });
  }
  
  // æ¡ä»¶å—å¤„ç†
  private async processConditionalBlocks(
    content: string, 
    contextData: ContextData
  ): Promise<string> {
    const conditionalRegex = /\{\{#if\s+([^}]+)\}\}([\s\S]*?)\{\{/if\}\}/g;
    
    return content.replace(conditionalRegex, (match, condition, block) => {
      const conditionResult = this.evaluateCondition(condition, contextData);
      return conditionResult ? block : '';
    });
  }
  
  // å¾ªç¯å—å¤„ç†
  private async processLoopBlocks(
    content: string, 
    contextData: ContextData
  ): Promise<string> {
    const loopRegex = /\{\{#each\s+(\w+)\s+as\s+(\w+)\}\}([\s\S]*?)\{\{/each\}\}/g;
    
    return content.replace(loopRegex, (match, arrayPath, itemName, block) => {
      const array = this.getNestedValue(contextData, arrayPath);
      if (!Array.isArray(array)) {
        return '';
      }
      
      return array.map((item, index) => {
        let itemBlock = block;
        itemBlock = itemBlock.replace(new RegExp(`\{\{${itemName}\}\}`, 'g'), this.formatValue(item));
        itemBlock = itemBlock.replace(/\{\{@index\}\}/g, String(index));
        return itemBlock;
      }).join('');
    });
  }
  
  // å‡½æ•°è°ƒç”¨å¤„ç†
  private async processFunctionCalls(
    content: string, 
    contextData: ContextData
  ): Promise<string> {
    const functionRegex = /\{\{(\w+)\(([^)]*)\)\}\}/g;
    
    const promises: Promise<string>[] = [];
    const replacements: { match: string; replacement: Promise<string> }[] = [];
    
    content.replace(functionRegex, (match, functionName, args) => {
      const replacement = this.callTemplateFunction(functionName, args, contextData);
      replacements.push({ match, replacement });
      return match;
    });
    
    // ç­‰å¾…æ‰€æœ‰å‡½æ•°è°ƒç”¨å®Œæˆ
    const resolvedReplacements = await Promise.all(
      replacements.map(async ({ match, replacement }) => ({
        match,
        value: await replacement
      }))
    );
    
    // åº”ç”¨æ›¿æ¢
    let result = content;
    for (const { match, value } of resolvedReplacements) {
      result = result.replace(match, value);
    }
    
    return result;
  }
  
  // æ¨¡æ¿å‡½æ•°è°ƒç”¨
  private async callTemplateFunction(
    functionName: string, 
    args: string, 
    contextData: ContextData
  ): Promise<string> {
    const parsedArgs = this.parseArguments(args, contextData);
    
    switch (functionName) {
      case 'formatDate':
        return this.formatDate(parsedArgs[0], parsedArgs[1]);
      case 'formatNumber':
        return this.formatNumber(parsedArgs[0], parsedArgs[1]);
      case 'truncate':
        return this.truncateText(parsedArgs[0], parsedArgs[1]);
      case 'capitalize':
        return this.capitalizeText(parsedArgs[0]);
      case 'generateList':
        return this.generateList(parsedArgs[0], parsedArgs[1]);
      case 'calculateMetric':
        return await this.calculateMetric(parsedArgs[0], parsedArgs[1]);
      case 'fetchData':
        return await this.fetchExternalData(parsedArgs[0], parsedArgs[1]);
      default:
        console.warn(`Unknown template function: ${functionName}`);
        return '';
    }
  }
  
  // è´¨é‡éªŒè¯
  private async validatePrompt(prompt: string): Promise<void> {
    const validations = [
      this.checkLength(prompt),
      this.checkSensitiveContent(prompt),
      this.checkCompleteness(prompt),
      this.checkCoherence(prompt),
      this.checkGrammar(prompt)
    ];
    
    const results = await Promise.all(validations);
    const failures = results.filter(result => !result.passed);
    
    if (failures.length > 0) {
      throw new PromptValidationError(
        'Prompt validation failed',
        failures.map(f => f.message)
      );
    }
  }
  
  // æ•ˆæœè·Ÿè¸ª
  async trackEffectiveness(
    promptId: string, 
    result: TaskResult
  ): Promise<void> {
    await this.effectivenessTracker.record({
      promptId,
      success: result.success,
      executionTime: result.executionTime,
      qualityScore: result.qualityScore,
      userSatisfaction: result.userSatisfaction,
      timestamp: new Date()
    });
    
    // è§¦å‘è‡ªåŠ¨ä¼˜åŒ–
    await this.triggerAutoOptimization(promptId);
  }
  
  // è‡ªåŠ¨ä¼˜åŒ–
  private async triggerAutoOptimization(templateId: string): Promise<void> {
    const recentPerformance = await this.effectivenessTracker.getRecentPerformance(
      templateId,
      { days: 7 }
    );
    
    if (recentPerformance.averageScore < OPTIMIZATION_THRESHOLD) {
      await this.generateOptimizedVersion(templateId, recentPerformance);
    }
  }
  
  // ç”Ÿæˆä¼˜åŒ–ç‰ˆæœ¬
  private async generateOptimizedVersion(
    templateId: string, 
    performance: PerformanceData
  ): Promise<void> {
    const currentTemplate = await this.versionManager.getCurrentVersion(templateId);
    const optimizationSuggestions = await this.analyzePerformanceIssues(performance);
    
    const optimizedTemplate = await this.applyOptimizations(
      currentTemplate,
      optimizationSuggestions
    );
    
    // åˆ›å»ºæ–°ç‰ˆæœ¬
    await this.versionManager.createVersion(
      templateId,
      optimizedTemplate,
      {
        type: 'auto-optimization',
        basedOn: currentTemplate.version,
        optimizations: optimizationSuggestions,
        expectedImprovement: this.calculateExpectedImprovement(optimizationSuggestions)
      }
    );
  }
}

// ä¸ªæ€§åŒ–å¼•æ“
class PersonalizationEngine {
  private userProfiles: Map<string, UserProfile> = new Map();
  private adaptationRules: AdaptationRule[] = [];
  
  async customize(
    template: PromptTemplate, 
    userId: string,
    contextData: ContextData
  ): Promise<PromptTemplate> {
    const userProfile = await this.getUserProfile(userId);
    if (!userProfile) {
      return template; // æ— ä¸ªæ€§åŒ–æ•°æ®æ—¶è¿”å›åŸæ¨¡æ¿
    }
    
    let customizedTemplate = { ...template };
    
    // åº”ç”¨ä¸ªæ€§åŒ–è§„åˆ™
    for (const rule of this.adaptationRules) {
      if (rule.condition(userProfile, contextData)) {
        customizedTemplate = await rule.apply(customizedTemplate, userProfile);
      }
    }
    
    return customizedTemplate;
  }
  
  private async getUserProfile(userId: string): Promise<UserProfile | null> {
    if (this.userProfiles.has(userId)) {
      return this.userProfiles.get(userId)!;
    }
    
    // ä»æ•°æ®åº“åŠ è½½ç”¨æˆ·æ¡£æ¡ˆ
    const profile = await this.loadUserProfileFromDB(userId);
    if (profile) {
      this.userProfiles.set(userId, profile);
    }
    
    return profile;
  }
  
  // å­¦ä¹ ç”¨æˆ·åå¥½
  async learnFromInteraction(
    userId: string, 
    interaction: UserInteraction
  ): Promise<void> {
    let profile = await this.getUserProfile(userId);
    
    if (!profile) {
      profile = this.createNewUserProfile(userId);
    }
    
    // æ›´æ–°åå¥½
    profile.preferences = await this.updatePreferences(
      profile.preferences, 
      interaction
    );
    
    // æ›´æ–°æŠ€èƒ½æ°´å¹³
    profile.skillLevel = await this.updateSkillLevel(
      profile.skillLevel, 
      interaction
    );
    
    // æ›´æ–°äº¤äº’å†å²
    profile.interactionHistory.push({
      timestamp: new Date(),
      type: interaction.type,
      success: interaction.success,
      feedback: interaction.feedback
    });
    
    // ä¿æŒå†å²è®°å½•åœ¨åˆç†èŒƒå›´å†…
    if (profile.interactionHistory.length > MAX_HISTORY_SIZE) {
      profile.interactionHistory = profile.interactionHistory.slice(-MAX_HISTORY_SIZE);
    }
    
    // ä¿å­˜æ›´æ–°åçš„æ¡£æ¡ˆ
    this.userProfiles.set(userId, profile);
    await this.saveUserProfileToDB(profile);
  }
}
```

---

## 5. ä»»åŠ¡è°ƒåº¦ä¸æ‰§è¡Œæœºåˆ¶

### 5.1 å¤šçº§è°ƒåº¦æ¶æ„

**ã€ä»£ç å·¥ç¨‹ã€‘**

```mermaid
flowchart TD
    subgraph "ğŸŒ å…¨å±€è°ƒåº¦å±‚"
        GS["å…¨å±€è°ƒåº¦å™¨<br/>(Global Scheduler)"]
        PQ["ä¼˜å…ˆçº§é˜Ÿåˆ—<br/>(Priority Queue)"]
        RM["èµ„æºç®¡ç†å™¨<br/>(Resource Manager)"]
    end
    
    subgraph "ğŸ¤– æ™ºèƒ½ä½“è°ƒåº¦å±‚"
        AS["æ™ºèƒ½ä½“è°ƒåº¦å™¨<br/>(Agent Scheduler)"]
        AL["æ™ºèƒ½ä½“è´Ÿè½½å‡è¡¡<br/>(Agent Load Balancer)"]
        AC["æ™ºèƒ½ä½“èƒ½åŠ›åŒ¹é…<br/>(Agent Capability Matcher)"]
    end
    
    subgraph "ğŸ› ï¸ å·¥å…·è°ƒåº¦å±‚"
        TS["å·¥å…·è°ƒåº¦å™¨<br/>(Tool Scheduler)"]
        TC["å·¥å…·å¹¶å‘æ§åˆ¶<br/>(Tool Concurrency Control)"]
        TD["å·¥å…·ä¾èµ–è§£æ<br/>(Tool Dependency Resolver)"]
    end
    
    subgraph "ğŸ’¾ èµ„æºè°ƒåº¦å±‚"
        RS["èµ„æºè°ƒåº¦å™¨<br/>(Resource Scheduler)"]
        RA["èµ„æºåˆ†é…å™¨<br/>(Resource Allocator)"]
        RO["èµ„æºä¼˜åŒ–å™¨<br/>(Resource Optimizer)"]
    end
    
    GS --> PQ
    PQ --> RM
    RM --> AS
    
    AS --> AL
    AL --> AC
    AC --> TS
    
    TS --> TC
    TC --> TD
    TD --> RS
    
    RS --> RA
    RA --> RO
 ```

### 5.2 æ™ºèƒ½è°ƒåº¦ç®—æ³•

**ã€ä»£ç å·¥ç¨‹ã€‘**

```typescript
// å…¨å±€è°ƒåº¦å™¨å®ç°
class GlobalScheduler {
  private priorityQueue: PriorityQueue<Task>;
  private resourceManager: ResourceManager;
  private agentScheduler: AgentScheduler;
  private performanceMonitor: PerformanceMonitor;
  private loadBalancer: LoadBalancer;
  private emergencyHandler: EmergencyHandler;
  
  constructor() {
    this.priorityQueue = new PriorityQueue<Task>(this.compareTaskPriority.bind(this));
    this.resourceManager = new ResourceManager();
    this.agentScheduler = new AgentScheduler();
    this.performanceMonitor = new PerformanceMonitor();
    this.loadBalancer = new LoadBalancer();
    this.emergencyHandler = new EmergencyHandler();
    
    this.initializeSchedulingLoop();
  }
  
  // ä»»åŠ¡æäº¤
  async submitTask(task: Task): Promise<string> {
    // ä»»åŠ¡éªŒè¯
    await this.validateTask(task);
    
    // ä¼˜å…ˆçº§è®¡ç®—
    task.priority = await this.calculatePriority(task);
    
    // èµ„æºéœ€æ±‚è¯„ä¼°
    task.resourceRequirements = await this.estimateResourceRequirements(task);
    
    // é¢„è®¡æ‰§è¡Œæ—¶é—´
    task.estimatedDuration = await this.estimateExecutionTime(task);
    
    // ä¾èµ–å…³ç³»åˆ†æ
    task.dependencies = await this.analyzeDependencies(task);
    
    // åŠ å…¥è°ƒåº¦é˜Ÿåˆ—
    this.priorityQueue.enqueue(task);
    
    // è§¦å‘è°ƒåº¦
    this.triggerScheduling();
    
    return task.id;
  }
  
  // ä¼˜å…ˆçº§è®¡ç®—ç®—æ³•
  private async calculatePriority(task: Task): Promise<number> {
    let priority = 0;
    
    // åŸºç¡€ä¼˜å…ˆçº§ï¼ˆç”¨æˆ·è®¾å®šï¼‰
    priority += task.basePriority * 100;
    
    // ç´§æ€¥ç¨‹åº¦åŠ æƒ
    const urgencyWeight = this.calculateUrgencyWeight(task.deadline);
    priority += urgencyWeight * 50;
    
    // ä¸šåŠ¡ä»·å€¼åŠ æƒ
    const businessValue = await this.calculateBusinessValue(task);
    priority += businessValue * 30;
    
    // èµ„æºå¯ç”¨æ€§åŠ æƒ
    const resourceAvailability = await this.checkResourceAvailability(task);
    priority += resourceAvailability * 20;
    
    // ä¾èµ–å…³ç³»åŠ æƒ
    const dependencyWeight = await this.calculateDependencyWeight(task);
    priority += dependencyWeight * 15;
    
    // å†å²æˆåŠŸç‡åŠ æƒ
    const successRateWeight = await this.calculateSuccessRateWeight(task);
    priority += successRateWeight * 10;
    
    // ç”¨æˆ·ç­‰å¾…æ—¶é—´åŠ æƒ
    const waitTimeWeight = this.calculateWaitTimeWeight(task.submissionTime);
    priority += waitTimeWeight * 5;
    
    return Math.max(0, Math.min(1000, priority)); // é™åˆ¶åœ¨0-1000èŒƒå›´å†…
  }
  
  // èµ„æºéœ€æ±‚ä¼°ç®—
  private async estimateResourceRequirements(task: Task): Promise<ResourceRequirements> {
    const taskType = task.type;
    const complexity = await this.analyzeTaskComplexity(task);
    const historicalData = await this.getHistoricalResourceUsage(taskType);
    
    // åŸºäºå†å²æ•°æ®å’Œå¤æ‚åº¦ä¼°ç®—
    const baseRequirements = historicalData.averageRequirements;
    const complexityMultiplier = Math.pow(1.5, complexity - 1);
    
    return {
      cpu: Math.ceil(baseRequirements.cpu * complexityMultiplier),
      memory: Math.ceil(baseRequirements.memory * complexityMultiplier),
      storage: Math.ceil(baseRequirements.storage * complexityMultiplier),
      network: Math.ceil(baseRequirements.network * complexityMultiplier),
      gpu: task.requiresGPU ? Math.ceil(baseRequirements.gpu * complexityMultiplier) : 0,
      specialTools: await this.identifyRequiredTools(task)
    };
  }
  
  // æ‰§è¡Œæ—¶é—´ä¼°ç®—
  private async estimateExecutionTime(task: Task): Promise<number> {
    const taskType = task.type;
    const complexity = await this.analyzeTaskComplexity(task);
    const historicalData = await this.getHistoricalExecutionTimes(taskType);
    
    // åŸºäºå†å²æ•°æ®çš„åŸºç¡€æ—¶é—´
    let baseTime = historicalData.averageTime;
    
    // å¤æ‚åº¦è°ƒæ•´
    const complexityFactor = Math.pow(2, complexity - 1);
    baseTime *= complexityFactor;
    
    // æ•°æ®é‡è°ƒæ•´
    if (task.dataSize) {
      const dataSizeFactor = Math.log10(task.dataSize / 1024) + 1; // MBä¸ºå•ä½
      baseTime *= dataSizeFactor;
    }
    
    // å¹¶å‘åº¦è°ƒæ•´
    const concurrencyFactor = task.allowParallel ? 0.6 : 1.0;
    baseTime *= concurrencyFactor;
    
    // èµ„æºå¯ç”¨æ€§è°ƒæ•´
    const resourceFactor = await this.getResourceAvailabilityFactor();
    baseTime /= resourceFactor;
    
    // æ·»åŠ ä¸ç¡®å®šæ€§ç¼“å†²
    const uncertaintyBuffer = baseTime * 0.2;
    
    return Math.ceil(baseTime + uncertaintyBuffer);
  }
  
  // è°ƒåº¦ä¸»å¾ªç¯
  private initializeSchedulingLoop(): void {
    setInterval(async () => {
      await this.scheduleNextBatch();
    }, SCHEDULING_INTERVAL);
  }
  
  // æ‰¹é‡è°ƒåº¦
  private async scheduleNextBatch(): Promise<void> {
    try {
      // æ£€æŸ¥ç³»ç»ŸçŠ¶æ€
      const systemStatus = await this.performanceMonitor.getSystemStatus();
      if (systemStatus.overloaded) {
        await this.handleSystemOverload(systemStatus);
        return;
      }
      
      // è·å–å¯ç”¨èµ„æº
      const availableResources = await this.resourceManager.getAvailableResources();
      
      // é€‰æ‹©å¯æ‰§è¡Œçš„ä»»åŠ¡
      const executableTasks = await this.selectExecutableTasks(availableResources);
      
      // åˆ†é…æ™ºèƒ½ä½“
      for (const task of executableTasks) {
        await this.assignAgentToTask(task);
      }
      
      // æ›´æ–°è°ƒåº¦ç»Ÿè®¡
      await this.updateSchedulingMetrics(executableTasks);
      
    } catch (error) {
      console.error('Scheduling error:', error);
      await this.emergencyHandler.handleSchedulingError(error);
    }
  }
  
  // é€‰æ‹©å¯æ‰§è¡Œä»»åŠ¡
  private async selectExecutableTasks(
    availableResources: AvailableResources
  ): Promise<Task[]> {
    const executableTasks: Task[] = [];
    const remainingResources = { ...availableResources };
    
    // æŒ‰ä¼˜å…ˆçº§éå†ä»»åŠ¡é˜Ÿåˆ—
    while (!this.priorityQueue.isEmpty()) {
      const task = this.priorityQueue.peek();
      
      // æ£€æŸ¥ä¾èµ–å…³ç³»
      if (!await this.areDependenciesSatisfied(task)) {
        // è·³è¿‡æ­¤ä»»åŠ¡ï¼Œæ£€æŸ¥ä¸‹ä¸€ä¸ª
        const skippedTask = this.priorityQueue.dequeue();
        this.priorityQueue.enqueue(skippedTask); // é‡æ–°åŠ å…¥é˜Ÿåˆ—æœ«å°¾
        continue;
      }
      
      // æ£€æŸ¥èµ„æºæ˜¯å¦è¶³å¤Ÿ
      if (this.canAllocateResources(task.resourceRequirements, remainingResources)) {
        const executableTask = this.priorityQueue.dequeue();
        executableTasks.push(executableTask);
        
        // æ›´æ–°å‰©ä½™èµ„æº
        this.deductResources(remainingResources, task.resourceRequirements);
        
        // æ£€æŸ¥æ˜¯å¦è¾¾åˆ°æ‰¹æ¬¡é™åˆ¶
        if (executableTasks.length >= MAX_BATCH_SIZE) {
          break;
        }
      } else {
        // èµ„æºä¸è¶³ï¼Œåœæ­¢é€‰æ‹©
        break;
      }
    }
    
    return executableTasks;
  }
  
  // æ™ºèƒ½ä½“åˆ†é…
  private async assignAgentToTask(task: Task): Promise<void> {
    // è·å–åˆé€‚çš„æ™ºèƒ½ä½“
    const suitableAgents = await this.agentScheduler.findSuitableAgents(task);
    
    if (suitableAgents.length === 0) {
      throw new Error(`No suitable agent found for task ${task.id}`);
    }
    
    // é€‰æ‹©æœ€ä¼˜æ™ºèƒ½ä½“
    const bestAgent = await this.selectBestAgent(suitableAgents, task);
    
    // åˆ†é…ä»»åŠ¡
    await this.agentScheduler.assignTask(bestAgent, task);
    
    // æ›´æ–°ä»»åŠ¡çŠ¶æ€
    task.status = TaskStatus.ASSIGNED;
    task.assignedAgent = bestAgent.id;
    task.assignmentTime = new Date();
    
    // è®°å½•åˆ†é…æ—¥å¿—
    await this.logTaskAssignment(task, bestAgent);
  }
  
  // æœ€ä¼˜æ™ºèƒ½ä½“é€‰æ‹©
  private async selectBestAgent(
    candidates: Agent[], 
    task: Task
  ): Promise<Agent> {
    let bestAgent = candidates[0];
    let bestScore = 0;
    
    for (const agent of candidates) {
      const score = await this.calculateAgentScore(agent, task);
      if (score > bestScore) {
        bestScore = score;
        bestAgent = agent;
      }
    }
    
    return bestAgent;
  }
  
  // æ™ºèƒ½ä½“è¯„åˆ†ç®—æ³•
  private async calculateAgentScore(agent: Agent, task: Task): Promise<number> {
    let score = 0;
    
    // èƒ½åŠ›åŒ¹é…åº¦ (40%)
    const capabilityMatch = await this.calculateCapabilityMatch(agent, task);
    score += capabilityMatch * 0.4;
    
    // å½“å‰è´Ÿè½½ (25%)
    const loadFactor = 1 - (agent.currentLoad / agent.maxCapacity);
    score += loadFactor * 0.25;
    
    // å†å²æˆåŠŸç‡ (20%)
    const successRate = await this.getAgentSuccessRate(agent, task.type);
    score += successRate * 0.2;
    
    // å¹³å‡æ‰§è¡Œæ—¶é—´ (10%)
    const avgExecutionTime = await this.getAgentAvgExecutionTime(agent, task.type);
    const timeFactor = 1 / (1 + avgExecutionTime / 3600); // å½’ä¸€åŒ–åˆ°å°æ—¶
    score += timeFactor * 0.1;
    
    // èµ„æºæ•ˆç‡ (5%)
    const resourceEfficiency = await this.getAgentResourceEfficiency(agent);
    score += resourceEfficiency * 0.05;
    
    return score;
  }
  
  // ç³»ç»Ÿè¿‡è½½å¤„ç†
  private async handleSystemOverload(systemStatus: SystemStatus): Promise<void> {
    console.warn('System overload detected:', systemStatus);
    
    // æš‚åœæ–°ä»»åŠ¡è°ƒåº¦
    this.pauseScheduling();
    
    // åˆ†æè¿‡è½½åŸå› 
    const overloadAnalysis = await this.analyzeOverloadCause(systemStatus);
    
    // æ‰§è¡Œç¼“è§£æªæ–½
    switch (overloadAnalysis.primaryCause) {
      case 'cpu_overload':
        await this.handleCPUOverload();
        break;
      case 'memory_overload':
        await this.handleMemoryOverload();
        break;
      case 'too_many_tasks':
        await this.handleTaskOverload();
        break;
      case 'agent_bottleneck':
        await this.handleAgentBottleneck();
        break;
      default:
        await this.handleGenericOverload();
    }
    
    // ç­‰å¾…ç³»ç»Ÿæ¢å¤
    await this.waitForSystemRecovery();
    
    // æ¢å¤è°ƒåº¦
    this.resumeScheduling();
  }
}

// æ™ºèƒ½ä½“è°ƒåº¦å™¨
class AgentScheduler {
  private agents: Map<string, Agent> = new Map();
  private agentCapabilities: Map<string, AgentCapability[]> = new Map();
  private agentPerformance: Map<string, AgentPerformanceMetrics> = new Map();
  private loadBalancer: AgentLoadBalancer;
  
  constructor() {
    this.loadBalancer = new AgentLoadBalancer();
    this.initializeAgents();
  }
  
  // æŸ¥æ‰¾åˆé€‚çš„æ™ºèƒ½ä½“
  async findSuitableAgents(task: Task): Promise<Agent[]> {
    const requiredCapabilities = task.requiredCapabilities;
    const suitableAgents: Agent[] = [];
    
    for (const [agentId, agent] of this.agents) {
      // æ£€æŸ¥æ™ºèƒ½ä½“çŠ¶æ€
      if (agent.status !== AgentStatus.AVAILABLE && 
          agent.status !== AgentStatus.BUSY) {
        continue;
      }
      
      // æ£€æŸ¥èƒ½åŠ›åŒ¹é…
      const capabilities = this.agentCapabilities.get(agentId) || [];
      if (this.hasRequiredCapabilities(capabilities, requiredCapabilities)) {
        // æ£€æŸ¥è´Ÿè½½å®¹é‡
        if (agent.currentLoad < agent.maxCapacity) {
          suitableAgents.push(agent);
        }
      }
    }
    
    return suitableAgents;
  }
  
  // åˆ†é…ä»»åŠ¡ç»™æ™ºèƒ½ä½“
  async assignTask(agent: Agent, task: Task): Promise<void> {
    // æ›´æ–°æ™ºèƒ½ä½“çŠ¶æ€
    agent.currentLoad += task.resourceRequirements.cpu;
    agent.assignedTasks.push(task.id);
    
    if (agent.currentLoad >= agent.maxCapacity) {
      agent.status = AgentStatus.BUSY;
    }
    
    // å¯åŠ¨ä»»åŠ¡æ‰§è¡Œ
    await this.startTaskExecution(agent, task);
    
    // æ›´æ–°è´Ÿè½½å‡è¡¡å™¨
    await this.loadBalancer.updateAgentLoad(agent.id, agent.currentLoad);
  }
  
  // å¯åŠ¨ä»»åŠ¡æ‰§è¡Œ
  private async startTaskExecution(agent: Agent, task: Task): Promise<void> {
    try {
      // å‡†å¤‡æ‰§è¡Œç¯å¢ƒ
      await this.prepareExecutionEnvironment(agent, task);
      
      // å¼‚æ­¥æ‰§è¡Œä»»åŠ¡
      const executionPromise = agent.execute(task);
      
      // ç›‘æ§æ‰§è¡Œè¿‡ç¨‹
      this.monitorTaskExecution(agent, task, executionPromise);
      
    } catch (error) {
      console.error(`Failed to start task execution: ${error.message}`);
      await this.handleExecutionError(agent, task, error);
    }
  }
  
  // ç›‘æ§ä»»åŠ¡æ‰§è¡Œ
  private async monitorTaskExecution(
    agent: Agent, 
    task: Task, 
    executionPromise: Promise<TaskResult>
  ): Promise<void> {
    const startTime = Date.now();
    
    try {
      // è®¾ç½®è¶…æ—¶ç›‘æ§
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => {
          reject(new Error('Task execution timeout'));
        }, task.estimatedDuration * 2); // 2å€é¢„ä¼°æ—¶é—´ä½œä¸ºè¶…æ—¶
      });
      
      // ç­‰å¾…æ‰§è¡Œå®Œæˆæˆ–è¶…æ—¶
      const result = await Promise.race([executionPromise, timeoutPromise]) as TaskResult;
      
      // å¤„ç†æ‰§è¡Œç»“æœ
      await this.handleTaskCompletion(agent, task, result, startTime);
      
    } catch (error) {
      // å¤„ç†æ‰§è¡Œé”™è¯¯
      await this.handleTaskFailure(agent, task, error, startTime);
    }
  }
  
  // å¤„ç†ä»»åŠ¡å®Œæˆ
  private async handleTaskCompletion(
    agent: Agent, 
    task: Task, 
    result: TaskResult,
    startTime: number
  ): Promise<void> {
    const executionTime = Date.now() - startTime;
    
    // æ›´æ–°æ™ºèƒ½ä½“çŠ¶æ€
    agent.currentLoad -= task.resourceRequirements.cpu;
    agent.assignedTasks = agent.assignedTasks.filter(id => id !== task.id);
    agent.completedTasks += 1;
    
    if (agent.currentLoad < agent.maxCapacity) {
      agent.status = AgentStatus.AVAILABLE;
    }
    
    // æ›´æ–°ä»»åŠ¡çŠ¶æ€
    task.status = result.success ? TaskStatus.COMPLETED : TaskStatus.FAILED;
    task.completionTime = new Date();
    task.actualDuration = executionTime;
    task.result = result;
    
    // æ›´æ–°æ€§èƒ½æŒ‡æ ‡
    await this.updateAgentPerformanceMetrics(agent, task, result, executionTime);
    
    // é‡Šæ”¾èµ„æº
    await this.releaseTaskResources(task);
    
    // é€šçŸ¥ç›¸å…³ç³»ç»Ÿ
    await this.notifyTaskCompletion(task, result);
    
    // è§¦å‘ä¾èµ–ä»»åŠ¡æ£€æŸ¥
    await this.checkDependentTasks(task);
  }
  
  // æ›´æ–°æ™ºèƒ½ä½“æ€§èƒ½æŒ‡æ ‡
  private async updateAgentPerformanceMetrics(
    agent: Agent, 
    task: Task, 
    result: TaskResult,
    executionTime: number
  ): Promise<void> {
    let metrics = this.agentPerformance.get(agent.id);
    
    if (!metrics) {
      metrics = {
        totalTasks: 0,
        successfulTasks: 0,
        failedTasks: 0,
        totalExecutionTime: 0,
        averageExecutionTime: 0,
        successRate: 0,
        resourceEfficiency: 0,
        lastUpdated: new Date()
      };
    }
    
    // æ›´æ–°ç»Ÿè®¡æ•°æ®
    metrics.totalTasks += 1;
    if (result.success) {
      metrics.successfulTasks += 1;
    } else {
      metrics.failedTasks += 1;
    }
    
    metrics.totalExecutionTime += executionTime;
    metrics.averageExecutionTime = metrics.totalExecutionTime / metrics.totalTasks;
    metrics.successRate = metrics.successfulTasks / metrics.totalTasks;
    
    // è®¡ç®—èµ„æºæ•ˆç‡
    const expectedTime = task.estimatedDuration;
    const efficiency = expectedTime / executionTime;
    metrics.resourceEfficiency = (metrics.resourceEfficiency * (metrics.totalTasks - 1) + efficiency) / metrics.totalTasks;
    
    metrics.lastUpdated = new Date();
    
    // ä¿å­˜æ›´æ–°åçš„æŒ‡æ ‡
    this.agentPerformance.set(agent.id, metrics);
    
    // å¦‚æœæ€§èƒ½ä¸‹é™ï¼Œè§¦å‘ä¼˜åŒ–
    if (metrics.successRate < PERFORMANCE_THRESHOLD || 
        metrics.resourceEfficiency < EFFICIENCY_THRESHOLD) {
      await this.triggerAgentOptimization(agent, metrics);
    }
  }
}

// èµ„æºç®¡ç†å™¨
class ResourceManager {
  private totalResources: SystemResources;
  private allocatedResources: SystemResources;
  private reservedResources: Map<string, ResourceReservation> = new Map();
  private resourceMonitor: ResourceMonitor;
  private resourceOptimizer: ResourceOptimizer;
  
  constructor() {
    this.resourceMonitor = new ResourceMonitor();
    this.resourceOptimizer = new ResourceOptimizer();
    this.initializeResources();
  }
  
  // è·å–å¯ç”¨èµ„æº
  async getAvailableResources(): Promise<AvailableResources> {
    const currentUsage = await this.resourceMonitor.getCurrentUsage();
    
    return {
      cpu: this.totalResources.cpu - currentUsage.cpu,
      memory: this.totalResources.memory - currentUsage.memory,
      storage: this.totalResources.storage - currentUsage.storage,
      network: this.totalResources.network - currentUsage.network,
      gpu: this.totalResources.gpu - currentUsage.gpu
    };
  }
  
  // èµ„æºåˆ†é…
  async allocateResources(
    taskId: string, 
    requirements: ResourceRequirements
  ): Promise<ResourceAllocation> {
    const available = await this.getAvailableResources();
    
    // æ£€æŸ¥èµ„æºæ˜¯å¦è¶³å¤Ÿ
    if (!this.canAllocate(requirements, available)) {
      throw new ResourceAllocationError('Insufficient resources available');
    }
    
    // æ‰§è¡Œåˆ†é…
    const allocation: ResourceAllocation = {
      taskId,
      allocatedAt: new Date(),
      resources: requirements,
      reservationId: generateId()
    };
    
    // æ›´æ–°å·²åˆ†é…èµ„æº
    this.allocatedResources.cpu += requirements.cpu;
    this.allocatedResources.memory += requirements.memory;
    this.allocatedResources.storage += requirements.storage;
    this.allocatedResources.network += requirements.network;
    this.allocatedResources.gpu += requirements.gpu;
    
    // è®°å½•åˆ†é…
    this.reservedResources.set(allocation.reservationId, {
      taskId,
      resources: requirements,
      allocatedAt: allocation.allocatedAt
    });
    
    return allocation;
  }
  
  // èµ„æºé‡Šæ”¾
  async releaseResources(reservationId: string): Promise<void> {
    const reservation = this.reservedResources.get(reservationId);
    
    if (!reservation) {
      console.warn(`Resource reservation ${reservationId} not found`);
      return;
    }
    
    // é‡Šæ”¾èµ„æº
    this.allocatedResources.cpu -= reservation.resources.cpu;
    this.allocatedResources.memory -= reservation.resources.memory;
    this.allocatedResources.storage -= reservation.resources.storage;
    this.allocatedResources.network -= reservation.resources.network;
    this.allocatedResources.gpu -= reservation.resources.gpu;
    
    // ç§»é™¤é¢„ç•™è®°å½•
    this.reservedResources.delete(reservationId);
    
    // è§¦å‘èµ„æºä¼˜åŒ–
    await this.resourceOptimizer.optimizeAllocation();
  }
  
  // èµ„æºç›‘æ§å’Œé¢„è­¦
  private async monitorResourceUsage(): Promise<void> {
    setInterval(async () => {
      const usage = await this.resourceMonitor.getCurrentUsage();
      const utilization = this.calculateUtilization(usage);
      
      // æ£€æŸ¥èµ„æºä½¿ç”¨ç‡
      if (utilization.cpu > CPU_WARNING_THRESHOLD) {
        await this.handleHighCPUUsage(utilization.cpu);
      }
      
      if (utilization.memory > MEMORY_WARNING_THRESHOLD) {
        await this.handleHighMemoryUsage(utilization.memory);
      }
      
      if (utilization.storage > STORAGE_WARNING_THRESHOLD) {
        await this.handleHighStorageUsage(utilization.storage);
      }
      
      // é¢„æµ‹èµ„æºéœ€æ±‚
      const prediction = await this.predictResourceDemand();
      if (prediction.willExceedCapacity) {
        await this.handlePredictedResourceShortage(prediction);
      }
      
    }, RESOURCE_MONITORING_INTERVAL);
  }
}
```

### 5.3 åŠ¨æ€è´Ÿè½½å‡è¡¡

**ã€ä»£ç å·¥ç¨‹ã€‘**

```typescript
// è´Ÿè½½å‡è¡¡å™¨
class LoadBalancer {
  private agents: Map<string, AgentLoadInfo> = new Map();
  private loadHistory: LoadHistoryEntry[] = [];
  private balancingStrategy: LoadBalancingStrategy;
  private performancePredictor: PerformancePredictor;
  
  constructor(strategy: LoadBalancingStrategy = 'adaptive') {
    this.balancingStrategy = strategy;
    this.performancePredictor = new PerformancePredictor();
    this.initializeLoadMonitoring();
  }
  
  // é€‰æ‹©æœ€ä¼˜æ™ºèƒ½ä½“
  async selectOptimalAgent(
    candidates: Agent[], 
    task: Task
  ): Promise<Agent> {
    switch (this.balancingStrategy) {
      case 'round_robin':
        return this.roundRobinSelection(candidates);
      case 'least_loaded':
        return this.leastLoadedSelection(candidates);
      case 'weighted_round_robin':
        return this.weightedRoundRobinSelection(candidates, task);
      case 'performance_based':
        return this.performanceBasedSelection(candidates, task);
      case 'adaptive':
        return this.adaptiveSelection(candidates, task);
      default:
        return this.leastLoadedSelection(candidates);
    }
  }
  
  // è‡ªé€‚åº”é€‰æ‹©ç®—æ³•
  private async adaptiveSelection(
    candidates: Agent[], 
    task: Task
  ): Promise<Agent> {
    const scores: Array<{ agent: Agent; score: number }> = [];
    
    for (const agent of candidates) {
      const score = await this.calculateAdaptiveScore(agent, task);
      scores.push({ agent, score });
    }
    
    // æŒ‰åˆ†æ•°æ’åºï¼Œé€‰æ‹©æœ€é«˜åˆ†çš„æ™ºèƒ½ä½“
    scores.sort((a, b) => b.score - a.score);
    
    return scores[0].agent;
  }
  
  // è‡ªé€‚åº”è¯„åˆ†ç®—æ³•
  private async calculateAdaptiveScore(
    agent: Agent, 
    task: Task
  ): Promise<number> {
    let score = 0;
    
    // å½“å‰è´Ÿè½½æƒé‡ (30%)
    const loadInfo = this.agents.get(agent.id);
    const loadFactor = loadInfo ? (1 - loadInfo.currentLoad / loadInfo.maxCapacity) : 1;
    score += loadFactor * 0.3;
    
    // å†å²æ€§èƒ½æƒé‡ (25%)
    const performanceScore = await this.getAgentPerformanceScore(agent, task.type);
    score += performanceScore * 0.25;
    
    // é¢„æµ‹æ‰§è¡Œæ—¶é—´æƒé‡ (20%)
    const predictedTime = await this.performancePredictor.predictExecutionTime(agent, task);
    const timeFactor = 1 / (1 + predictedTime / 3600); // å½’ä¸€åŒ–
    score += timeFactor * 0.2;
    
    // èµ„æºåŒ¹é…åº¦æƒé‡ (15%)
    const resourceMatch = this.calculateResourceMatch(agent, task);
    score += resourceMatch * 0.15;
    
    // é˜Ÿåˆ—é•¿åº¦æƒé‡ (10%)
    const queueFactor = 1 / (1 + agent.taskQueue.length);
    score += queueFactor * 0.1;
    
    return score;
  }
  
  // åŠ¨æ€è´Ÿè½½é‡åˆ†é…
  async rebalanceLoad(): Promise<void> {
    const overloadedAgents = await this.identifyOverloadedAgents();
    const underloadedAgents = await this.identifyUnderloadedAgents();
    
    if (overloadedAgents.length === 0 || underloadedAgents.length === 0) {
      return; // æ— éœ€é‡åˆ†é…
    }
    
    for (const overloadedAgent of overloadedAgents) {
      const tasksToMigrate = await this.selectTasksForMigration(overloadedAgent);
      
      for (const task of tasksToMigrate) {
        const targetAgent = await this.selectMigrationTarget(
          underloadedAgents, 
          task
        );
        
        if (targetAgent) {
          await this.migrateTask(task, overloadedAgent, targetAgent);
        }
      }
    }
  }
  
  // ä»»åŠ¡è¿ç§»
  private async migrateTask(
    task: Task, 
    sourceAgent: Agent, 
    targetAgent: Agent
  ): Promise<void> {
    try {
      // æš‚åœæºæ™ºèƒ½ä½“ä¸Šçš„ä»»åŠ¡
      await sourceAgent.pauseTask(task.id);
      
      // è·å–ä»»åŠ¡çŠ¶æ€
      const taskState = await sourceAgent.getTaskState(task.id);
      
      // åœ¨ç›®æ ‡æ™ºèƒ½ä½“ä¸Šæ¢å¤ä»»åŠ¡
      await targetAgent.resumeTask(task, taskState);
      
      // æ›´æ–°ä»»åŠ¡åˆ†é…ä¿¡æ¯
      task.assignedAgent = targetAgent.id;
      task.migrationHistory = task.migrationHistory || [];
      task.migrationHistory.push({
        from: sourceAgent.id,
        to: targetAgent.id,
        timestamp: new Date(),
        reason: 'load_balancing'
      });
      
      // æ›´æ–°è´Ÿè½½ä¿¡æ¯
      await this.updateAgentLoad(sourceAgent.id, -task.resourceRequirements.cpu);
      await this.updateAgentLoad(targetAgent.id, task.resourceRequirements.cpu);
      
      console.log(`Task ${task.id} migrated from ${sourceAgent.id} to ${targetAgent.id}`);
      
    } catch (error) {
      console.error(`Task migration failed: ${error.message}`);
      // å›æ»šæ“ä½œ
      await this.rollbackMigration(task, sourceAgent, targetAgent);
    }
  }
}
```

---

## 6. MCPå·¥å…·é›†æˆæ¶æ„

### 6.1 MCPåè®®å®ç°

**ã€MCPå·¥å…·ã€‘**

```mermaid
sequenceDiagram
    participant Client as æ™ºèƒ½ä½“å®¢æˆ·ç«¯
    participant Server as MCPæœåŠ¡å™¨
    participant Tool as å¤–éƒ¨å·¥å…·
    participant Monitor as ç›‘æ§ç³»ç»Ÿ
    
    Client->>Server: è¿æ¥è¯·æ±‚
    Server->>Client: è¿æ¥ç¡®è®¤
    
    Client->>Server: è·å–å·¥å…·åˆ—è¡¨
    Server->>Tool: æŸ¥è¯¢å¯ç”¨å·¥å…·
    Tool->>Server: è¿”å›å·¥å…·æ¸…å•
    Server->>Client: å·¥å…·åˆ—è¡¨å“åº”
    
    Client->>Server: å·¥å…·è°ƒç”¨è¯·æ±‚
    Server->>Monitor: è®°å½•è°ƒç”¨å¼€å§‹
    Server->>Tool: æ‰§è¡Œå·¥å…·æ“ä½œ
    Tool->>Server: è¿”å›æ‰§è¡Œç»“æœ
    Server->>Monitor: è®°å½•è°ƒç”¨ç»“æŸ
    Server->>Client: å·¥å…·è°ƒç”¨å“åº”
    
    Note over Client,Monitor: å¼‚æ­¥ç›‘æ§å’Œæ—¥å¿—è®°å½•
```

**ã€ä»£ç å·¥ç¨‹ã€‘**

```typescript
// MCPæœåŠ¡å™¨å®ç°
class MCPServer {
  private tools: Map<string, MCPTool> = new Map();
  private connections: Map<string, MCPConnection> = new Map();
  private callHistory: MCPCallHistory[] = [];
  private securityManager: MCPSecurityManager;
  private performanceMonitor: MCPPerformanceMonitor;
  
  constructor() {
    this.securityManager = new MCPSecurityManager();
    this.performanceMonitor = new MCPPerformanceMonitor();
    this.initializeTools();
  }
  
  // æ³¨å†ŒMCPå·¥å…·
  async registerTool(tool: MCPTool): Promise<void> {
    // éªŒè¯å·¥å…·å®šä¹‰
    await this.validateToolDefinition(tool);
    
    // å®‰å…¨æ£€æŸ¥
    await this.securityManager.validateTool(tool);
    
    // æ³¨å†Œå·¥å…·
    this.tools.set(tool.name, tool);
    
    console.log(`MCP tool registered: ${tool.name}`);
  }
  
  // å¤„ç†å·¥å…·è°ƒç”¨
  async handleToolCall(
    connectionId: string, 
    request: MCPToolCallRequest
  ): Promise<MCPToolCallResponse> {
    const startTime = Date.now();
    
    try {
      // éªŒè¯è¿æ¥
      const connection = this.connections.get(connectionId);
      if (!connection) {
        throw new MCPError('Invalid connection', 'INVALID_CONNECTION');
      }
      
      // éªŒè¯æƒé™
      await this.securityManager.checkPermissions(connection, request.toolName);
      
      // è·å–å·¥å…·
      const tool = this.tools.get(request.toolName);
      if (!tool) {
        throw new MCPError(`Tool not found: ${request.toolName}`, 'TOOL_NOT_FOUND');
      }
      
      // éªŒè¯å‚æ•°
      await this.validateToolParameters(tool, request.parameters);
      
      // æ‰§è¡Œå·¥å…·
      const result = await this.executeTool(tool, request.parameters);
      
      // è®°å½•è°ƒç”¨å†å²
      await this.recordToolCall({
        connectionId,
        toolName: request.toolName,
        parameters: request.parameters,
        result,
        executionTime: Date.now() - startTime,
        success: true,
        timestamp: new Date()
      });
      
      return {
        success: true,
        result,
        executionTime: Date.now() - startTime
      };
      
    } catch (error) {
      // è®°å½•é”™è¯¯
      await this.recordToolCall({
        connectionId,
        toolName: request.toolName,
        parameters: request.parameters,
        error: error.message,
        executionTime: Date.now() - startTime,
        success: false,
        timestamp: new Date()
      });
      
      return {
        success: false,
        error: error.message,
        executionTime: Date.now() - startTime
      };
    }
  }
  
  // æ‰§è¡Œå·¥å…·
  private async executeTool(
    tool: MCPTool, 
    parameters: Record<string, any>
  ): Promise<any> {
    // åˆ›å»ºæ‰§è¡Œä¸Šä¸‹æ–‡
    const context: MCPExecutionContext = {
      toolName: tool.name,
      parameters,
      startTime: new Date(),
      timeout: tool.timeout || DEFAULT_TOOL_TIMEOUT
    };
    
    // è®¾ç½®è¶…æ—¶
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => {
        reject(new MCPError('Tool execution timeout', 'EXECUTION_TIMEOUT'));
      }, context.timeout);
    });
    
    // æ‰§è¡Œå·¥å…·
    const executionPromise = tool.execute(parameters, context);
    
    // ç­‰å¾…æ‰§è¡Œå®Œæˆæˆ–è¶…æ—¶
    const result = await Promise.race([executionPromise, timeoutPromise]);
    
    return result;
  }
}

// MCPå·¥å…·åŸºç±»
abstract class MCPTool {
  abstract name: string;
  abstract description: string;
  abstract parameters: MCPToolParameter[];
  abstract timeout?: number;
  
  abstract async execute(
    parameters: Record<string, any>,
    context: MCPExecutionContext
  ): Promise<any>;
  
  // å‚æ•°éªŒè¯
  async validateParameters(parameters: Record<string, any>): Promise<void> {
    for (const param of this.parameters) {
      if (param.required && !(param.name in parameters)) {
        throw new MCPError(
          `Required parameter missing: ${param.name}`,
          'MISSING_PARAMETER'
        );
      }
      
      if (param.name in parameters) {
        await this.validateParameterType(param, parameters[param.name]);
      }
    }
  }
  
  private async validateParameterType(
    param: MCPToolParameter, 
    value: any
  ): Promise<void> {
    switch (param.type) {
      case 'string':
        if (typeof value !== 'string') {
          throw new MCPError(
            `Parameter ${param.name} must be a string`,
            'INVALID_PARAMETER_TYPE'
          );
        }
        break;
      case 'number':
        if (typeof value !== 'number') {
          throw new MCPError(
            `Parameter ${param.name} must be a number`,
            'INVALID_PARAMETER_TYPE'
          );
        }
        break;
      case 'boolean':
        if (typeof value !== 'boolean') {
          throw new MCPError(
            `Parameter ${param.name} must be a boolean`,
            'INVALID_PARAMETER_TYPE'
          );
        }
        break;
      case 'array':
        if (!Array.isArray(value)) {
          throw new MCPError(
            `Parameter ${param.name} must be an array`,
            'INVALID_PARAMETER_TYPE'
          );
        }
        break;
      case 'object':
        if (typeof value !== 'object' || value === null) {
          throw new MCPError(
            `Parameter ${param.name} must be an object`,
            'INVALID_PARAMETER_TYPE'
          );
        }
        break;
    }
  }
}
```

### 6.2 æ ¸å¿ƒå·¥å…·å®ç°

**ã€MCPå·¥å…·ã€‘**

```typescript
// æ–‡ä»¶æ“ä½œå·¥å…·
class FileOperationTool extends MCPTool {
  name = 'file_operations';
  description = 'æ–‡ä»¶ç³»ç»Ÿæ“ä½œå·¥å…·ï¼Œæ”¯æŒè¯»å–ã€å†™å…¥ã€åˆ é™¤ç­‰æ“ä½œ';
  timeout = 30000; // 30ç§’è¶…æ—¶
  
  parameters: MCPToolParameter[] = [
    {
      name: 'operation',
      type: 'string',
      required: true,
      description: 'æ“ä½œç±»å‹ï¼šread, write, delete, list, exists',
      enum: ['read', 'write', 'delete', 'list', 'exists']
    },
    {
      name: 'path',
      type: 'string',
      required: true,
      description: 'æ–‡ä»¶æˆ–ç›®å½•è·¯å¾„'
    },
    {
      name: 'content',
      type: 'string',
      required: false,
      description: 'å†™å…¥æ“ä½œæ—¶çš„æ–‡ä»¶å†…å®¹'
    },
    {
      name: 'encoding',
      type: 'string',
      required: false,
      description: 'æ–‡ä»¶ç¼–ç ï¼Œé»˜è®¤ä¸ºutf8',
      default: 'utf8'
    }
  ];
  
  async execute(
    parameters: Record<string, any>,
    context: MCPExecutionContext
  ): Promise<any> {
    const { operation, path, content, encoding = 'utf8' } = parameters;
    
    // å®‰å…¨æ£€æŸ¥ï¼šé˜²æ­¢è·¯å¾„éå†æ”»å‡»
    if (this.containsPathTraversal(path)) {
      throw new MCPError('Path traversal detected', 'SECURITY_VIOLATION');
    }
    
    switch (operation) {
      case 'read':
        return await this.readFile(path, encoding);
      case 'write':
        return await this.writeFile(path, content, encoding);
      case 'delete':
        return await this.deleteFile(path);
      case 'list':
        return await this.listDirectory(path);
      case 'exists':
        return await this.checkExists(path);
      default:
        throw new MCPError(`Unsupported operation: ${operation}`, 'INVALID_OPERATION');
    }
  }
  
  private async readFile(path: string, encoding: string): Promise<string> {
    try {
      const fs = await import('fs/promises');
      return await fs.readFile(path, encoding as BufferEncoding);
    } catch (error) {
      throw new MCPError(`Failed to read file: ${error.message}`, 'FILE_READ_ERROR');
    }
  }
  
  private async writeFile(path: string, content: string, encoding: string): Promise<boolean> {
    try {
      const fs = await import('fs/promises');
      await fs.writeFile(path, content, encoding as BufferEncoding);
      return true;
    } catch (error) {
      throw new MCPError(`Failed to write file: ${error.message}`, 'FILE_WRITE_ERROR');
    }
  }
  
  private containsPathTraversal(path: string): boolean {
    const normalizedPath = path.replace(/\\/g, '/');
    return normalizedPath.includes('../') || normalizedPath.includes('..\\');
  }
}

// ç½‘ç»œè¯·æ±‚å·¥å…·
class HTTPRequestTool extends MCPTool {
  name = 'http_request';
  description = 'HTTPè¯·æ±‚å·¥å…·ï¼Œæ”¯æŒGETã€POSTç­‰æ–¹æ³•';
  timeout = 60000; // 60ç§’è¶…æ—¶
  
  parameters: MCPToolParameter[] = [
    {
      name: 'url',
      type: 'string',
      required: true,
      description: 'è¯·æ±‚URL'
    },
    {
      name: 'method',
      type: 'string',
      required: false,
      description: 'HTTPæ–¹æ³•',
      default: 'GET',
      enum: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH']
    },
    {
      name: 'headers',
      type: 'object',
      required: false,
      description: 'è¯·æ±‚å¤´'
    },
    {
      name: 'body',
      type: 'string',
      required: false,
      description: 'è¯·æ±‚ä½“ï¼ˆJSONå­—ç¬¦ä¸²ï¼‰'
    },
    {
      name: 'timeout',
      type: 'number',
      required: false,
      description: 'è¯·æ±‚è¶…æ—¶æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰',
      default: 30000
    }
  ];
  
  async execute(
    parameters: Record<string, any>,
    context: MCPExecutionContext
  ): Promise<any> {
    const { url, method = 'GET', headers = {}, body, timeout = 30000 } = parameters;
    
    // URLå®‰å…¨æ£€æŸ¥
    if (!this.isValidURL(url)) {
      throw new MCPError('Invalid URL format', 'INVALID_URL');
    }
    
    // æ£€æŸ¥æ˜¯å¦ä¸ºå…è®¸çš„åŸŸå
    if (!await this.isAllowedDomain(url)) {
      throw new MCPError('Domain not allowed', 'DOMAIN_NOT_ALLOWED');
    }
    
    try {
      const response = await this.makeRequest({
        url,
        method,
        headers,
        body,
        timeout
      });
      
      return {
        status: response.status,
        statusText: response.statusText,
        headers: Object.fromEntries(response.headers.entries()),
        data: await response.text()
      };
      
    } catch (error) {
      throw new MCPError(`HTTP request failed: ${error.message}`, 'HTTP_REQUEST_ERROR');
    }
  }
  
  private async makeRequest(options: {
    url: string;
    method: string;
    headers: Record<string, string>;
    body?: string;
    timeout: number;
  }): Promise<Response> {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), options.timeout);
    
    try {
      const response = await fetch(options.url, {
        method: options.method,
        headers: options.headers,
        body: options.body,
        signal: controller.signal
      });
      
      return response;
    } finally {
      clearTimeout(timeoutId);
    }
  }
  
  private isValidURL(url: string): boolean {
    try {
      new URL(url);
      return true;
    } catch {
      return false;
    }
  }
  
  private async isAllowedDomain(url: string): Promise<boolean> {
    // å®ç°åŸŸåç™½åå•æ£€æŸ¥
    const allowedDomains = await this.getAllowedDomains();
    const urlObj = new URL(url);
    return allowedDomains.includes(urlObj.hostname);
  }
}

// æ•°æ®åº“æ“ä½œå·¥å…·
class DatabaseTool extends MCPTool {
  name = 'database_operations';
  description = 'æ•°æ®åº“æ“ä½œå·¥å…·ï¼Œæ”¯æŒæŸ¥è¯¢ã€æ’å…¥ã€æ›´æ–°ã€åˆ é™¤';
  timeout = 120000; // 2åˆ†é’Ÿè¶…æ—¶
  
  parameters: MCPToolParameter[] = [
    {
      name: 'operation',
      type: 'string',
      required: true,
      description: 'æ•°æ®åº“æ“ä½œç±»å‹',
      enum: ['select', 'insert', 'update', 'delete', 'execute']
    },
    {
      name: 'query',
      type: 'string',
      required: true,
      description: 'SQLæŸ¥è¯¢è¯­å¥'
    },
    {
      name: 'parameters',
      type: 'array',
      required: false,
      description: 'æŸ¥è¯¢å‚æ•°'
    },
    {
      name: 'database',
      type: 'string',
      required: false,
      description: 'æ•°æ®åº“åç§°',
      default: 'default'
    }
  ];
  
  async execute(
    parameters: Record<string, any>,
    context: MCPExecutionContext
  ): Promise<any> {
    const { operation, query, parameters: queryParams = [], database = 'default' } = parameters;
    
    // SQLæ³¨å…¥é˜²æŠ¤
    if (this.containsSQLInjection(query)) {
      throw new MCPError('Potential SQL injection detected', 'SECURITY_VIOLATION');
    }
    
    // è·å–æ•°æ®åº“è¿æ¥
    const connection = await this.getDatabaseConnection(database);
    
    try {
      switch (operation) {
        case 'select':
          return await this.executeSelect(connection, query, queryParams);
        case 'insert':
          return await this.executeInsert(connection, query, queryParams);
        case 'update':
          return await this.executeUpdate(connection, query, queryParams);
        case 'delete':
          return await this.executeDelete(connection, query, queryParams);
        case 'execute':
          return await this.executeQuery(connection, query, queryParams);
        default:
          throw new MCPError(`Unsupported operation: ${operation}`, 'INVALID_OPERATION');
      }
    } finally {
      await this.releaseDatabaseConnection(connection);
    }
  }
  
  private containsSQLInjection(query: string): boolean {
     const suspiciousPatterns = [
       /('|(\-\-)|(;)|(\||\|)|(\*|\*))/i,
       /(union|select|insert|delete|update|drop|create|alter|exec|execute)/i
     ];
     
     return suspiciousPatterns.some(pattern => pattern.test(query));
   }
 }

 // AIæ¨¡å‹è°ƒç”¨å·¥å…·
 class AIModelTool extends MCPTool {
   name = 'ai_model_call';
   description = 'AIæ¨¡å‹è°ƒç”¨å·¥å…·ï¼Œæ”¯æŒå¤šç§å¤§è¯­è¨€æ¨¡å‹';
   timeout = 180000; // 3åˆ†é’Ÿè¶…æ—¶
   
   parameters: MCPToolParameter[] = [
     {
       name: 'model',
       type: 'string',
       required: true,
       description: 'æ¨¡å‹åç§°',
       enum: ['gpt-4', 'gpt-3.5-turbo', 'claude-3', 'gemini-pro']
     },
     {
       name: 'prompt',
       type: 'string',
       required: true,
       description: 'è¾“å…¥æç¤ºè¯'
     },
     {
       name: 'system_prompt',
       type: 'string',
       required: false,
       description: 'ç³»ç»Ÿæç¤ºè¯'
     },
     {
       name: 'temperature',
       type: 'number',
       required: false,
       description: 'æ¸©åº¦å‚æ•°ï¼ˆ0-1ï¼‰',
       default: 0.7
     },
     {
       name: 'max_tokens',
       type: 'number',
       required: false,
       description: 'æœ€å¤§è¾“å‡ºtokenæ•°',
       default: 2048
     }
   ];
   
   async execute(
     parameters: Record<string, any>,
     context: MCPExecutionContext
   ): Promise<any> {
     const { 
       model, 
       prompt, 
       system_prompt, 
       temperature = 0.7, 
       max_tokens = 2048 
     } = parameters;
     
     // è¾“å…¥éªŒè¯
     if (prompt.length > MAX_PROMPT_LENGTH) {
       throw new MCPError('Prompt too long', 'PROMPT_TOO_LONG');
     }
     
     // å†…å®¹å®‰å…¨æ£€æŸ¥
     if (await this.containsUnsafeContent(prompt)) {
       throw new MCPError('Unsafe content detected', 'UNSAFE_CONTENT');
     }
     
     try {
       const response = await this.callAIModel({
         model,
         prompt,
         system_prompt,
         temperature,
         max_tokens
       });
       
       return {
         response: response.content,
         usage: response.usage,
         model: model,
         timestamp: new Date().toISOString()
       };
       
     } catch (error) {
       throw new MCPError(`AI model call failed: ${error.message}`, 'AI_MODEL_ERROR');
     }
   }
   
   private async callAIModel(options: {
     model: string;
     prompt: string;
     system_prompt?: string;
     temperature: number;
     max_tokens: number;
   }): Promise<any> {
     // æ ¹æ®æ¨¡å‹ç±»å‹é€‰æ‹©ç›¸åº”çš„API
     switch (options.model) {
       case 'gpt-4':
       case 'gpt-3.5-turbo':
         return await this.callOpenAI(options);
       case 'claude-3':
         return await this.callAnthropic(options);
       case 'gemini-pro':
         return await this.callGemini(options);
       default:
         throw new Error(`Unsupported model: ${options.model}`);
     }
   }
 }
 ```

 ### 6.3 å·¥å…·å®‰å…¨ç®¡ç†

 **ã€ä»£ç å·¥ç¨‹ã€‘**

 ```typescript
 // MCPå®‰å…¨ç®¡ç†å™¨
 class MCPSecurityManager {
   private permissions: Map<string, ToolPermission[]> = new Map();
   private rateLimiter: RateLimiter;
   private auditLogger: AuditLogger;
   private encryptionManager: EncryptionManager;
   
   constructor() {
     this.rateLimiter = new RateLimiter();
     this.auditLogger = new AuditLogger();
     this.encryptionManager = new EncryptionManager();
     this.initializeDefaultPermissions();
   }
   
   // éªŒè¯å·¥å…·æƒé™
   async checkPermissions(
     connection: MCPConnection, 
     toolName: string
   ): Promise<void> {
     const userPermissions = this.permissions.get(connection.userId) || [];
     
     // æ£€æŸ¥æ˜¯å¦æœ‰å·¥å…·ä½¿ç”¨æƒé™
     const hasPermission = userPermissions.some(permission => 
       permission.toolName === toolName || permission.toolName === '*'
     );
     
     if (!hasPermission) {
       await this.auditLogger.logUnauthorizedAccess({
         userId: connection.userId,
         toolName,
         timestamp: new Date(),
         ipAddress: connection.ipAddress
       });
       
       throw new MCPError('Permission denied', 'PERMISSION_DENIED');
     }
     
     // æ£€æŸ¥é€Ÿç‡é™åˆ¶
     await this.rateLimiter.checkLimit(connection.userId, toolName);
   }
   
   // éªŒè¯å·¥å…·å®šä¹‰
   async validateTool(tool: MCPTool): Promise<void> {
     // æ£€æŸ¥å·¥å…·åç§°
     if (!this.isValidToolName(tool.name)) {
       throw new MCPError('Invalid tool name', 'INVALID_TOOL_NAME');
     }
     
     // æ£€æŸ¥å‚æ•°å®šä¹‰
     for (const param of tool.parameters) {
       if (!this.isValidParameter(param)) {
         throw new MCPError(
           `Invalid parameter definition: ${param.name}`,
           'INVALID_PARAMETER'
         );
       }
     }
     
     // å®‰å…¨é£é™©è¯„ä¼°
     const riskLevel = await this.assessSecurityRisk(tool);
     if (riskLevel > MAXIMUM_RISK_LEVEL) {
       throw new MCPError('Tool security risk too high', 'HIGH_SECURITY_RISK');
     }
   }
   
   // åŠ å¯†æ•æ„Ÿæ•°æ®
   async encryptSensitiveData(data: any): Promise<string> {
     return await this.encryptionManager.encrypt(JSON.stringify(data));
   }
   
   // è§£å¯†æ•æ„Ÿæ•°æ®
   async decryptSensitiveData(encryptedData: string): Promise<any> {
     const decrypted = await this.encryptionManager.decrypt(encryptedData);
     return JSON.parse(decrypted);
   }
   
   // å®‰å…¨é£é™©è¯„ä¼°
   private async assessSecurityRisk(tool: MCPTool): Promise<number> {
     let riskScore = 0;
     
     // åŸºäºå·¥å…·ç±»å‹çš„é£é™©è¯„åˆ†
     const riskFactors = {
       'file_operations': 7,
       'database_operations': 8,
       'http_request': 5,
       'system_command': 9,
       'ai_model_call': 4
     };
     
     riskScore += riskFactors[tool.name] || 3;
     
     // åŸºäºå‚æ•°çš„é£é™©è¯„åˆ†
     for (const param of tool.parameters) {
       if (param.type === 'string' && !param.enum) {
         riskScore += 1; // è‡ªç”±æ–‡æœ¬è¾“å…¥å¢åŠ é£é™©
       }
       if (param.name.includes('path') || param.name.includes('file')) {
         riskScore += 2; // æ–‡ä»¶è·¯å¾„å‚æ•°å¢åŠ é£é™©
       }
     }
     
     return riskScore;
   }
 }
 
 // é€Ÿç‡é™åˆ¶å™¨
 class RateLimiter {
   private limits: Map<string, RateLimit> = new Map();
   private usage: Map<string, UsageRecord[]> = new Map();
   
   constructor() {
     this.initializeDefaultLimits();
   }
   
   // æ£€æŸ¥é€Ÿç‡é™åˆ¶
   async checkLimit(userId: string, toolName: string): Promise<void> {
     const limitKey = `${userId}:${toolName}`;
     const limit = this.limits.get(toolKey) || this.getDefaultLimit(toolName);
     const usage = this.usage.get(limitKey) || [];
     
     // æ¸…ç†è¿‡æœŸè®°å½•
     const now = Date.now();
     const validUsage = usage.filter(record => 
       now - record.timestamp < limit.windowMs
     );
     
     // æ£€æŸ¥æ˜¯å¦è¶…è¿‡é™åˆ¶
     if (validUsage.length >= limit.maxRequests) {
       throw new MCPError(
         `Rate limit exceeded for ${toolName}`,
         'RATE_LIMIT_EXCEEDED'
       );
     }
     
     // è®°å½•æœ¬æ¬¡ä½¿ç”¨
     validUsage.push({ timestamp: now });
     this.usage.set(limitKey, validUsage);
   }
   
   private getDefaultLimit(toolName: string): RateLimit {
     const defaultLimits = {
       'file_operations': { maxRequests: 100, windowMs: 60000 }, // 100æ¬¡/åˆ†é’Ÿ
       'database_operations': { maxRequests: 50, windowMs: 60000 }, // 50æ¬¡/åˆ†é’Ÿ
       'http_request': { maxRequests: 200, windowMs: 60000 }, // 200æ¬¡/åˆ†é’Ÿ
       'ai_model_call': { maxRequests: 20, windowMs: 60000 } // 20æ¬¡/åˆ†é’Ÿ
     };
     
     return defaultLimits[toolName] || { maxRequests: 30, windowMs: 60000 };
   }
 }
 ```

 ---

 ## 7. ç³»ç»Ÿç›‘æ§ä¸è¿ç»´

 ### 7.1 å®æ—¶ç›‘æ§ç³»ç»Ÿ

 **ã€ä»£ç å·¥ç¨‹ã€‘**

 ```typescript
 // ç³»ç»Ÿç›‘æ§å™¨
 class SystemMonitor {
   private metrics: Map<string, MetricCollector> = new Map();
   private alerts: AlertManager;
   private dashboard: MonitoringDashboard;
   private logAggregator: LogAggregator;
   private healthChecker: HealthChecker;
   
   constructor() {
     this.alerts = new AlertManager();
     this.dashboard = new MonitoringDashboard();
     this.logAggregator = new LogAggregator();
     this.healthChecker = new HealthChecker();
     this.initializeMetrics();
   }
   
   // åˆå§‹åŒ–ç›‘æ§æŒ‡æ ‡
   private initializeMetrics(): void {
     // ç³»ç»Ÿèµ„æºæŒ‡æ ‡
     this.metrics.set('cpu_usage', new CPUUsageCollector());
     this.metrics.set('memory_usage', new MemoryUsageCollector());
     this.metrics.set('disk_usage', new DiskUsageCollector());
     this.metrics.set('network_io', new NetworkIOCollector());
     
     // åº”ç”¨æ€§èƒ½æŒ‡æ ‡
     this.metrics.set('task_throughput', new TaskThroughputCollector());
     this.metrics.set('response_time', new ResponseTimeCollector());
     this.metrics.set('error_rate', new ErrorRateCollector());
     this.metrics.set('queue_length', new QueueLengthCollector());
     
     // æ™ºèƒ½ä½“æŒ‡æ ‡
     this.metrics.set('agent_utilization', new AgentUtilizationCollector());
     this.metrics.set('agent_performance', new AgentPerformanceCollector());
     
     // å¯åŠ¨å®šæœŸæ”¶é›†
     this.startMetricCollection();
   }
   
   // å¼€å§‹æŒ‡æ ‡æ”¶é›†
   private startMetricCollection(): void {
     setInterval(async () => {
       await this.collectAllMetrics();
     }, METRIC_COLLECTION_INTERVAL);
   }
   
   // æ”¶é›†æ‰€æœ‰æŒ‡æ ‡
   private async collectAllMetrics(): Promise<void> {
     const timestamp = new Date();
     const collectedMetrics: Record<string, any> = {};
     
     for (const [name, collector] of this.metrics) {
       try {
         const value = await collector.collect();
         collectedMetrics[name] = {
           value,
           timestamp,
           unit: collector.getUnit()
         };
         
         // æ£€æŸ¥é˜ˆå€¼å‘Šè­¦
         await this.checkThresholds(name, value);
         
       } catch (error) {
         console.error(`Failed to collect metric ${name}:`, error);
         collectedMetrics[name] = {
           error: error.message,
           timestamp
         };
       }
     }
     
     // å­˜å‚¨æŒ‡æ ‡æ•°æ®
     await this.storeMetrics(collectedMetrics);
     
     // æ›´æ–°ä»ªè¡¨æ¿
     await this.dashboard.updateMetrics(collectedMetrics);
   }
   
   // æ£€æŸ¥é˜ˆå€¼å‘Šè­¦
   private async checkThresholds(metricName: string, value: number): Promise<void> {
     const thresholds = await this.getThresholds(metricName);
     
     if (value > thresholds.critical) {
       await this.alerts.triggerAlert({
         level: 'critical',
         metric: metricName,
         value,
         threshold: thresholds.critical,
         message: `${metricName} exceeded critical threshold: ${value} > ${thresholds.critical}`
       });
     } else if (value > thresholds.warning) {
       await this.alerts.triggerAlert({
         level: 'warning',
         metric: metricName,
         value,
         threshold: thresholds.warning,
         message: `${metricName} exceeded warning threshold: ${value} > ${thresholds.warning}`
       });
     }
   }
   
   // è·å–ç³»ç»Ÿå¥åº·çŠ¶æ€
   async getSystemHealth(): Promise<SystemHealthStatus> {
     const healthChecks = await Promise.all([
       this.healthChecker.checkDatabaseHealth(),
       this.healthChecker.checkRedisHealth(),
       this.healthChecker.checkAgentHealth(),
       this.healthChecker.checkExternalServicesHealth()
     ]);
     
     const overallStatus = healthChecks.every(check => check.status === 'healthy') 
       ? 'healthy' 
       : healthChecks.some(check => check.status === 'critical')
       ? 'critical'
       : 'degraded';
     
     return {
       status: overallStatus,
       checks: healthChecks,
       timestamp: new Date(),
       uptime: process.uptime()
     };
   }
 }
 
 // CPUä½¿ç”¨ç‡æ”¶é›†å™¨
 class CPUUsageCollector implements MetricCollector {
   async collect(): Promise<number> {
     const os = await import('os');
     const cpus = os.cpus();
     
     let totalIdle = 0;
     let totalTick = 0;
     
     for (const cpu of cpus) {
       for (const type in cpu.times) {
         totalTick += cpu.times[type];
       }
       totalIdle += cpu.times.idle;
     }
     
     const idle = totalIdle / cpus.length;
     const total = totalTick / cpus.length;
     
     return 100 - ~~(100 * idle / total);
   }
   
   getUnit(): string {
     return 'percentage';
   }
 }
 
 // å†…å­˜ä½¿ç”¨ç‡æ”¶é›†å™¨
 class MemoryUsageCollector implements MetricCollector {
   async collect(): Promise<number> {
     const os = await import('os');
     const totalMemory = os.totalmem();
     const freeMemory = os.freemem();
     const usedMemory = totalMemory - freeMemory;
     
     return (usedMemory / totalMemory) * 100;
   }
   
   getUnit(): string {
     return 'percentage';
   }
 }
 
 // ä»»åŠ¡ååé‡æ”¶é›†å™¨
 class TaskThroughputCollector implements MetricCollector {
   private taskCounts: number[] = [];
   private lastCollectionTime: number = Date.now();
   
   async collect(): Promise<number> {
     const currentTime = Date.now();
     const timeDiff = (currentTime - this.lastCollectionTime) / 1000; // ç§’
     
     // è·å–å½“å‰æ—¶é—´çª—å£å†…å®Œæˆçš„ä»»åŠ¡æ•°
     const completedTasks = await this.getCompletedTasksCount();
     
     // è®¡ç®—æ¯ç§’ä»»åŠ¡æ•°
     const throughput = completedTasks / timeDiff;
     
     this.lastCollectionTime = currentTime;
     
     return throughput;
   }
   
   getUnit(): string {
     return 'tasks/second';
   }
   
   private async getCompletedTasksCount(): Promise<number> {
     // ä»æ•°æ®åº“æˆ–ç¼“å­˜ä¸­è·å–å®Œæˆä»»åŠ¡æ•°
     // è¿™é‡Œæ˜¯ç¤ºä¾‹å®ç°
     return 0;
   }
 }
 
 // å‘Šè­¦ç®¡ç†å™¨
 class AlertManager {
   private alertChannels: AlertChannel[] = [];
   private alertHistory: Alert[] = [];
   private suppressionRules: SuppressionRule[] = [];
   
   constructor() {
     this.initializeAlertChannels();
   }
   
   // è§¦å‘å‘Šè­¦
   async triggerAlert(alert: Alert): Promise<void> {
     // æ£€æŸ¥æŠ‘åˆ¶è§„åˆ™
     if (await this.shouldSuppressAlert(alert)) {
       return;
     }
     
     // æ·»åŠ åˆ°å†å²è®°å½•
     alert.id = generateId();
     alert.timestamp = new Date();
     this.alertHistory.push(alert);
     
     // å‘é€åˆ°æ‰€æœ‰å‘Šè­¦é€šé“
     for (const channel of this.alertChannels) {
       try {
         await channel.sendAlert(alert);
       } catch (error) {
         console.error(`Failed to send alert via ${channel.name}:`, error);
       }
     }
   }
   
   // æ£€æŸ¥æ˜¯å¦åº”è¯¥æŠ‘åˆ¶å‘Šè­¦
   private async shouldSuppressAlert(alert: Alert): Promise<boolean> {
     // æ£€æŸ¥é‡å¤å‘Šè­¦
     const recentAlerts = this.alertHistory.filter(a => 
       a.metric === alert.metric && 
       a.level === alert.level &&
       Date.now() - a.timestamp.getTime() < ALERT_SUPPRESSION_WINDOW
     );
     
     if (recentAlerts.length > 0) {
       return true; // æŠ‘åˆ¶é‡å¤å‘Šè­¦
     }
     
     // æ£€æŸ¥è‡ªå®šä¹‰æŠ‘åˆ¶è§„åˆ™
     for (const rule of this.suppressionRules) {
       if (await rule.shouldSuppress(alert)) {
         return true;
       }
     }
     
     return false;
   }
   
   private initializeAlertChannels(): void {
     // é‚®ä»¶å‘Šè­¦
     this.alertChannels.push(new EmailAlertChannel());
     
     // Slackå‘Šè­¦
     this.alertChannels.push(new SlackAlertChannel());
     
     // çŸ­ä¿¡å‘Šè­¦ï¼ˆä»…é™ä¸¥é‡å‘Šè­¦ï¼‰
     this.alertChannels.push(new SMSAlertChannel(['critical']));
     
     // é’‰é’‰å‘Šè­¦
     this.alertChannels.push(new DingTalkAlertChannel());
   }
 }
 ```

 ### 7.2 æ—¥å¿—èšåˆä¸åˆ†æ

 **ã€ä»£ç å·¥ç¨‹ã€‘**

 ```typescript
 // æ—¥å¿—èšåˆå™¨
 class LogAggregator {
   private logSources: Map<string, LogSource> = new Map();
   private logProcessors: LogProcessor[] = [];
   private logStorage: LogStorage;
   private logAnalyzer: LogAnalyzer;
   
   constructor() {
     this.logStorage = new LogStorage();
     this.logAnalyzer = new LogAnalyzer();
     this.initializeLogSources();
     this.initializeLogProcessors();
   }
   
   // åˆå§‹åŒ–æ—¥å¿—æº
   private initializeLogSources(): void {
     // åº”ç”¨æ—¥å¿—
     this.logSources.set('application', new ApplicationLogSource());
     
     // ç³»ç»Ÿæ—¥å¿—
     this.logSources.set('system', new SystemLogSource());
     
     // è®¿é—®æ—¥å¿—
     this.logSources.set('access', new AccessLogSource());
     
     // é”™è¯¯æ—¥å¿—
     this.logSources.set('error', new ErrorLogSource());
     
     // å®¡è®¡æ—¥å¿—
     this.logSources.set('audit', new AuditLogSource());
   }
   
   // åˆå§‹åŒ–æ—¥å¿—å¤„ç†å™¨
   private initializeLogProcessors(): void {
     // ç»“æ„åŒ–å¤„ç†å™¨
     this.logProcessors.push(new StructuredLogProcessor());
     
     // æ•æ„Ÿä¿¡æ¯è„±æ•å¤„ç†å™¨
     this.logProcessors.push(new SensitiveDataMaskingProcessor());
     
     // å¼‚å¸¸æ£€æµ‹å¤„ç†å™¨
     this.logProcessors.push(new AnomalyDetectionProcessor());
     
     // æ€§èƒ½åˆ†æå¤„ç†å™¨
     this.logProcessors.push(new PerformanceAnalysisProcessor());
   }
   
   // å¼€å§‹æ—¥å¿—èšåˆ
   async startAggregation(): Promise<void> {
     for (const [name, source] of this.logSources) {
       source.onLog(async (logEntry) => {
         await this.processLogEntry(logEntry);
       });
       
       await source.start();
     }
   }
   
   // å¤„ç†æ—¥å¿—æ¡ç›®
   private async processLogEntry(logEntry: LogEntry): Promise<void> {
     let processedEntry = logEntry;
     
     // é€šè¿‡æ‰€æœ‰å¤„ç†å™¨å¤„ç†æ—¥å¿—
     for (const processor of this.logProcessors) {
       try {
         processedEntry = await processor.process(processedEntry);
       } catch (error) {
         console.error(`Log processor ${processor.name} failed:`, error);
       }
     }
     
     // å­˜å‚¨å¤„ç†åçš„æ—¥å¿—
     await this.logStorage.store(processedEntry);
     
     // å®æ—¶åˆ†æ
     await this.logAnalyzer.analyze(processedEntry);
   }
   
   // æŸ¥è¯¢æ—¥å¿—
   async queryLogs(query: LogQuery): Promise<LogQueryResult> {
     return await this.logStorage.query(query);
   }
   
   // ç”Ÿæˆæ—¥å¿—æŠ¥å‘Š
   async generateReport(timeRange: TimeRange): Promise<LogReport> {
     const logs = await this.logStorage.query({
       timeRange,
       limit: 10000
     });
     
     return await this.logAnalyzer.generateReport(logs);
   }
 }
 
 // ç»“æ„åŒ–æ—¥å¿—å¤„ç†å™¨
 class StructuredLogProcessor implements LogProcessor {
   name = 'structured_processor';
   
   async process(logEntry: LogEntry): Promise<LogEntry> {
     // è§£ææ—¥å¿—æ ¼å¼
     const parsed = this.parseLogFormat(logEntry.message);
     
     return {
       ...logEntry,
       structured: parsed,
       fields: this.extractFields(parsed)
     };
   }
   
   private parseLogFormat(message: string): any {
     // å°è¯•è§£æJSONæ ¼å¼
     try {
       return JSON.parse(message);
     } catch {
       // è§£æå…¶ä»–æ ¼å¼ï¼ˆå¦‚Apache Common Log Formatï¼‰
       return this.parseCommonLogFormat(message);
     }
   }
   
   private parseCommonLogFormat(message: string): any {
     const regex = /^(\S+) (\S+) (\S+) \[([^\]]+)\] "([^"]+)" (\d+) (\d+)$/;
     const match = message.match(regex);
     
     if (match) {
       return {
         ip: match[1],
         user: match[2],
         timestamp: match[4],
         request: match[5],
         status: parseInt(match[6]),
         size: parseInt(match[7])
       };
     }
     
     return { raw: message };
   }
   
   private extractFields(parsed: any): Record<string, any> {
     const fields: Record<string, any> = {};
     
     // æå–å¸¸è§å­—æ®µ
     if (parsed.level) fields.level = parsed.level;
     if (parsed.timestamp) fields.timestamp = parsed.timestamp;
     if (parsed.service) fields.service = parsed.service;
     if (parsed.traceId) fields.traceId = parsed.traceId;
     if (parsed.userId) fields.userId = parsed.userId;
     if (parsed.ip) fields.ip = parsed.ip;
     if (parsed.status) fields.status = parsed.status;
     
     return fields;
   }
 }
 
 // æ•æ„Ÿä¿¡æ¯è„±æ•å¤„ç†å™¨
 class SensitiveDataMaskingProcessor implements LogProcessor {
   name = 'sensitive_data_masking';
   
   private sensitivePatterns = [
     { name: 'email', pattern: /\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b/g },
     { name: 'phone', pattern: /\b\d{3}-\d{3}-\d{4}\b/g },
     { name: 'ssn', pattern: /\b\d{3}-\d{2}-\d{4}\b/g },
     { name: 'credit_card', pattern: /\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}\b/g },
     { name: 'api_key', pattern: /\b[A-Za-z0-9]{32,}\b/g },
     { name: 'password', pattern: /password["']?\s*[:=]\s*["']?([^\s"']+)/gi }
   ];
   
   async process(logEntry: LogEntry): Promise<LogEntry> {
     let maskedMessage = logEntry.message;
     
     for (const pattern of this.sensitivePatterns) {
       maskedMessage = maskedMessage.replace(pattern.pattern, (match) => {
         return this.maskSensitiveData(match, pattern.name);
       });
     }
     
     return {
       ...logEntry,
       message: maskedMessage,
       masked: maskedMessage !== logEntry.message
     };
   }
   
   private maskSensitiveData(data: string, type: string): string {
     switch (type) {
       case 'email':
         const [user, domain] = data.split('@');
         return `${user.substring(0, 2)}***@${domain}`;
       case 'phone':
         return data.replace(/\d/g, '*').substring(0, 3) + '-***-****';
       case 'credit_card':
         return '**** **** **** ' + data.slice(-4);
       case 'api_key':
         return data.substring(0, 8) + '***';
       case 'password':
         return data.replace(/password["']?\s*[:=]\s*["']?([^\s"']+)/gi, 'password=***');
       default:
         return '***';
     }
   }
 }
 
 // å¼‚å¸¸æ£€æµ‹å¤„ç†å™¨
 class AnomalyDetectionProcessor implements LogProcessor {
   name = 'anomaly_detection';
   
   private errorPatterns = [
     /error/i,
     /exception/i,
     /failed/i,
     /timeout/i,
     /connection refused/i,
     /out of memory/i,
     /stack overflow/i
   ];
   
   private performancePatterns = [
     /slow query/i,
     /high cpu/i,
     /memory leak/i,
     /response time/i
   ];
   
   async process(logEntry: LogEntry): Promise<LogEntry> {
     const anomalies = this.detectAnomalies(logEntry);
     
     if (anomalies.length > 0) {
       // è§¦å‘å¼‚å¸¸å‘Šè­¦
       await this.triggerAnomalyAlert(logEntry, anomalies);
     }
     
     return {
       ...logEntry,
       anomalies
     };
   }
   
   private detectAnomalies(logEntry: LogEntry): Anomaly[] {
     const anomalies: Anomaly[] = [];
     
     // æ£€æµ‹é”™è¯¯æ¨¡å¼
     for (const pattern of this.errorPatterns) {
       if (pattern.test(logEntry.message)) {
         anomalies.push({
           type: 'error',
           pattern: pattern.source,
           severity: this.calculateSeverity(logEntry),
           timestamp: logEntry.timestamp
         });
       }
     }
     
     // æ£€æµ‹æ€§èƒ½é—®é¢˜
     for (const pattern of this.performancePatterns) {
       if (pattern.test(logEntry.message)) {
         anomalies.push({
           type: 'performance',
           pattern: pattern.source,
           severity: 'medium',
           timestamp: logEntry.timestamp
         });
       }
     }
     
     // æ£€æµ‹é¢‘ç‡å¼‚å¸¸
     const frequencyAnomaly = this.detectFrequencyAnomaly(logEntry);
     if (frequencyAnomaly) {
       anomalies.push(frequencyAnomaly);
     }
     
     return anomalies;
   }
   
   private calculateSeverity(logEntry: LogEntry): string {
     if (logEntry.level === 'error' || logEntry.level === 'fatal') {
       return 'high';
     } else if (logEntry.level === 'warn') {
       return 'medium';
     } else {
       return 'low';
     }
   }
   
   private detectFrequencyAnomaly(logEntry: LogEntry): Anomaly | null {
     // å®ç°é¢‘ç‡å¼‚å¸¸æ£€æµ‹é€»è¾‘
     // è¿™é‡Œæ˜¯ç®€åŒ–ç‰ˆæœ¬
     return null;
   }
   
   private async triggerAnomalyAlert(
     logEntry: LogEntry, 
     anomalies: Anomaly[]
   ): Promise<void> {
     const highSeverityAnomalies = anomalies.filter(a => a.severity === 'high');
     
     if (highSeverityAnomalies.length > 0) {
       // å‘é€é«˜ä¼˜å…ˆçº§å‘Šè­¦
       console.warn('High severity anomaly detected:', {
         logEntry,
         anomalies: highSeverityAnomalies
       });
     }
   }
 }
 ```

 ### 7.3 æ€§èƒ½ç›‘æ§ä¸ä¼˜åŒ–

 **ã€ä»£ç å·¥ç¨‹ã€‘**

 ```mermaid
 graph TB
   A[æ€§èƒ½ç›‘æ§ç³»ç»Ÿ] --> B[æŒ‡æ ‡æ”¶é›†]
   A --> C[æ€§èƒ½åˆ†æ]
   A --> D[ä¼˜åŒ–å»ºè®®]
   
   B --> B1[å“åº”æ—¶é—´]
   B --> B2[ååé‡]
   B --> B3[èµ„æºä½¿ç”¨ç‡]
   B --> B4[é”™è¯¯ç‡]
   
   C --> C1[ç“¶é¢ˆè¯†åˆ«]
   C --> C2[è¶‹åŠ¿åˆ†æ]
   C --> C3[å®¹é‡è§„åˆ’]
   
   D --> D1[ä»£ç ä¼˜åŒ–]
   D --> D2[æ¶æ„è°ƒæ•´]
   D --> D3[èµ„æºæ‰©å®¹]
 ```

 ```typescript
 // æ€§èƒ½ç›‘æ§å™¨
 class PerformanceMonitor {
   private profiler: Profiler;
   private metricsCollector: MetricsCollector;
   private optimizer: PerformanceOptimizer;
   private reporter: PerformanceReporter;
   
   constructor() {
     this.profiler = new Profiler();
     this.metricsCollector = new MetricsCollector();
     this.optimizer = new PerformanceOptimizer();
     this.reporter = new PerformanceReporter();
   }
   
   // å¼€å§‹æ€§èƒ½ç›‘æ§
   async startMonitoring(): Promise<void> {
     // å¯åŠ¨æ€§èƒ½åˆ†æå™¨
     await this.profiler.start();
     
     // å®šæœŸæ”¶é›†æ€§èƒ½æŒ‡æ ‡
     setInterval(async () => {
       await this.collectPerformanceMetrics();
     }, PERFORMANCE_COLLECTION_INTERVAL);
     
     // å®šæœŸç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
     setInterval(async () => {
       await this.generatePerformanceReport();
     }, PERFORMANCE_REPORT_INTERVAL);
   }
   
   // æ”¶é›†æ€§èƒ½æŒ‡æ ‡
   private async collectPerformanceMetrics(): Promise<void> {
     const metrics = {
       // ç³»ç»Ÿæ€§èƒ½æŒ‡æ ‡
       cpu: await this.metricsCollector.getCPUMetrics(),
       memory: await this.metricsCollector.getMemoryMetrics(),
       disk: await this.metricsCollector.getDiskMetrics(),
       network: await this.metricsCollector.getNetworkMetrics(),
       
       // åº”ç”¨æ€§èƒ½æŒ‡æ ‡
       responseTime: await this.metricsCollector.getResponseTimeMetrics(),
       throughput: await this.metricsCollector.getThroughputMetrics(),
       errorRate: await this.metricsCollector.getErrorRateMetrics(),
       
       // æ™ºèƒ½ä½“æ€§èƒ½æŒ‡æ ‡
       agentUtilization: await this.metricsCollector.getAgentUtilizationMetrics(),
       taskCompletionTime: await this.metricsCollector.getTaskCompletionTimeMetrics(),
       queueLength: await this.metricsCollector.getQueueLengthMetrics()
     };
     
     // åˆ†ææ€§èƒ½ç“¶é¢ˆ
     const bottlenecks = await this.analyzer.identifyBottlenecks(metrics);
     
     if (bottlenecks.length > 0) {
       // ç”Ÿæˆä¼˜åŒ–å»ºè®®
       const recommendations = await this.optimizer.generateRecommendations(bottlenecks);
       
       // è‡ªåŠ¨åº”ç”¨ä¼˜åŒ–ç­–ç•¥
       await this.optimizer.applyOptimizations(recommendations);
     }
   }
   
   // ç”Ÿæˆæ€§èƒ½æŠ¥å‘Š
   private async generatePerformanceReport(): Promise<void> {
     const report = await this.reporter.generateReport({
       timeRange: {
         start: new Date(Date.now() - 24 * 60 * 60 * 1000), // è¿‡å»24å°æ—¶
         end: new Date()
       },
       includeRecommendations: true,
       includeGraphs: true
     });
     
     // å‘é€æŠ¥å‘Šç»™ç›¸å…³äººå‘˜
     await this.reporter.sendReport(report);
   }
 }
 
 // æ€§èƒ½åˆ†æå™¨
 class PerformanceAnalyzer {
   // è¯†åˆ«æ€§èƒ½ç“¶é¢ˆ
   async identifyBottlenecks(metrics: PerformanceMetrics): Promise<Bottleneck[]> {
     const bottlenecks: Bottleneck[] = [];
     
     // CPUç“¶é¢ˆæ£€æµ‹
     if (metrics.cpu.usage > CPU_THRESHOLD) {
       bottlenecks.push({
         type: 'cpu',
         severity: this.calculateSeverity(metrics.cpu.usage, CPU_THRESHOLD),
         description: `CPU usage is ${metrics.cpu.usage}%, exceeding threshold of ${CPU_THRESHOLD}%`,
         recommendations: [
           'Consider horizontal scaling',
           'Optimize CPU-intensive operations',
           'Implement caching strategies'
         ]
       });
     }
     
     // å†…å­˜ç“¶é¢ˆæ£€æµ‹
     if (metrics.memory.usage > MEMORY_THRESHOLD) {
       bottlenecks.push({
         type: 'memory',
         severity: this.calculateSeverity(metrics.memory.usage, MEMORY_THRESHOLD),
         description: `Memory usage is ${metrics.memory.usage}%, exceeding threshold of ${MEMORY_THRESHOLD}%`,
         recommendations: [
           'Implement memory pooling',
           'Optimize data structures',
           'Add memory monitoring and cleanup'
         ]
       });
     }
     
     // å“åº”æ—¶é—´ç“¶é¢ˆæ£€æµ‹
     if (metrics.responseTime.p95 > RESPONSE_TIME_THRESHOLD) {
       bottlenecks.push({
         type: 'response_time',
         severity: this.calculateSeverity(metrics.responseTime.p95, RESPONSE_TIME_THRESHOLD),
         description: `95th percentile response time is ${metrics.responseTime.p95}ms, exceeding threshold of ${RESPONSE_TIME_THRESHOLD}ms`,
         recommendations: [
           'Optimize database queries',
           'Implement request caching',
           'Use asynchronous processing'
         ]
       });
     }
     
     // é˜Ÿåˆ—é•¿åº¦ç“¶é¢ˆæ£€æµ‹
     if (metrics.queueLength.average > QUEUE_LENGTH_THRESHOLD) {
       bottlenecks.push({
         type: 'queue_length',
         severity: this.calculateSeverity(metrics.queueLength.average, QUEUE_LENGTH_THRESHOLD),
         description: `Average queue length is ${metrics.queueLength.average}, exceeding threshold of ${QUEUE_LENGTH_THRESHOLD}`,
         recommendations: [
           'Increase worker capacity',
           'Implement priority queuing',
           'Optimize task processing'
         ]
       });
     }
     
     return bottlenecks;
   }
   
   private calculateSeverity(value: number, threshold: number): string {
     const ratio = value / threshold;
     
     if (ratio > 2) return 'critical';
     if (ratio > 1.5) return 'high';
     if (ratio > 1.2) return 'medium';
     return 'low';
   }
 }
 
 // æ€§èƒ½ä¼˜åŒ–å™¨
 class PerformanceOptimizer {
   private optimizationStrategies: Map<string, OptimizationStrategy> = new Map();
   
   constructor() {
     this.initializeStrategies();
   }
   
   // ç”Ÿæˆä¼˜åŒ–å»ºè®®
   async generateRecommendations(bottlenecks: Bottleneck[]): Promise<OptimizationRecommendation[]> {
     const recommendations: OptimizationRecommendation[] = [];
     
     for (const bottleneck of bottlenecks) {
       const strategy = this.optimizationStrategies.get(bottleneck.type);
       
       if (strategy) {
         const recommendation = await strategy.generateRecommendation(bottleneck);
         recommendations.push(recommendation);
       }
     }
     
     // æŒ‰ä¼˜å…ˆçº§æ’åº
     return recommendations.sort((a, b) => b.priority - a.priority);
   }
   
   // åº”ç”¨ä¼˜åŒ–ç­–ç•¥
   async applyOptimizations(recommendations: OptimizationRecommendation[]): Promise<void> {
     for (const recommendation of recommendations) {
       if (recommendation.autoApply) {
         try {
           await this.executeOptimization(recommendation);
           console.log(`Applied optimization: ${recommendation.description}`);
         } catch (error) {
           console.error(`Failed to apply optimization: ${recommendation.description}`, error);
         }
       }
     }
   }
   
   private async executeOptimization(recommendation: OptimizationRecommendation): Promise<void> {
     switch (recommendation.type) {
       case 'cache_optimization':
         await this.optimizeCache(recommendation.parameters);
         break;
       case 'connection_pool_optimization':
         await this.optimizeConnectionPool(recommendation.parameters);
         break;
       case 'worker_scaling':
         await this.scaleWorkers(recommendation.parameters);
         break;
       case 'memory_cleanup':
         await this.performMemoryCleanup();
         break;
       default:
         throw new Error(`Unknown optimization type: ${recommendation.type}`);
     }
   }
   
   private initializeStrategies(): void {
     // CPUä¼˜åŒ–ç­–ç•¥
     this.optimizationStrategies.set('cpu', new CPUOptimizationStrategy());
     
     // å†…å­˜ä¼˜åŒ–ç­–ç•¥
     this.optimizationStrategies.set('memory', new MemoryOptimizationStrategy());
     
     // å“åº”æ—¶é—´ä¼˜åŒ–ç­–ç•¥
     this.optimizationStrategies.set('response_time', new ResponseTimeOptimizationStrategy());
     
     // é˜Ÿåˆ—ä¼˜åŒ–ç­–ç•¥
     this.optimizationStrategies.set('queue_length', new QueueOptimizationStrategy());
   }
 }
 ```

 ---

 ## 8. éƒ¨ç½²ä¸è¿ç»´

 ### 8.1 å®¹å™¨åŒ–éƒ¨ç½²

 **ã€ä»£ç å·¥ç¨‹ã€‘**

 ```dockerfile
 # å¤šé˜¶æ®µæ„å»ºDockerfile
 # æ„å»ºé˜¶æ®µ
 FROM node:18-alpine AS builder
 
 WORKDIR /app
 
 # å¤åˆ¶ä¾èµ–æ–‡ä»¶
 COPY package*.json ./
 COPY tsconfig.json ./
 
 # å®‰è£…ä¾èµ–
 RUN npm ci --only=production
 
 # å¤åˆ¶æºä»£ç 
 COPY src/ ./src/
 
 # æ„å»ºåº”ç”¨
 RUN npm run build
 
 # ç”Ÿäº§é˜¶æ®µ
 FROM node:18-alpine AS production
 
 # åˆ›å»ºérootç”¨æˆ·
 RUN addgroup -g 1001 -S nodejs
 RUN adduser -S nextjs -u 1001
 
 WORKDIR /app
 
 # å¤åˆ¶æ„å»ºäº§ç‰©
 COPY --from=builder --chown=nextjs:nodejs /app/dist ./dist
 COPY --from=builder --chown=nextjs:nodejs /app/node_modules ./node_modules
 COPY --from=builder --chown=nextjs:nodejs /app/package.json ./package.json
 
 # å¥åº·æ£€æŸ¥
 HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
   CMD curl -f http://localhost:3000/health || exit 1
 
 # åˆ‡æ¢åˆ°érootç”¨æˆ·
 USER nextjs
 
 # æš´éœ²ç«¯å£
 EXPOSE 3000
 
 # å¯åŠ¨åº”ç”¨
 CMD ["node", "dist/index.js"]
 ```

 ```yaml
 # docker-compose.yml
 version: '3.8'
 
 services:
   # ä¸»åº”ç”¨æœåŠ¡
   app:
     build:
       context: .
       dockerfile: Dockerfile
     ports:
       - "3000:3000"
     environment:
       - NODE_ENV=production
       - DATABASE_URL=${DATABASE_URL}
       - REDIS_URL=${REDIS_URL}
       - JWT_SECRET=${JWT_SECRET}
     depends_on:
       - postgres
       - redis
       - elasticsearch
     volumes:
       - ./logs:/app/logs
     networks:
       - app-network
     restart: unless-stopped
     deploy:
       resources:
         limits:
           cpus: '2.0'
           memory: 4G
         reservations:
           cpus: '1.0'
           memory: 2G
   
   # PostgreSQLæ•°æ®åº“
   postgres:
     image: postgres:15-alpine
     environment:
       - POSTGRES_DB=${POSTGRES_DB}
       - POSTGRES_USER=${POSTGRES_USER}
       - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
     volumes:
       - postgres_data:/var/lib/postgresql/data
       - ./init.sql:/docker-entrypoint-initdb.d/init.sql
     ports:
       - "5432:5432"
     networks:
       - app-network
     restart: unless-stopped
   
   # Redisç¼“å­˜
   redis:
     image: redis:7-alpine
     command: redis-server --appendonly yes --requirepass ${REDIS_PASSWORD}
     volumes:
       - redis_data:/data
     ports:
       - "6379:6379"
     networks:
       - app-network
     restart: unless-stopped
   
   # Elasticsearchæ—¥å¿—å­˜å‚¨
   elasticsearch:
     image: docker.elastic.co/elasticsearch/elasticsearch:8.8.0
     environment:
       - discovery.type=single-node
       - "ES_JAVA_OPTS=-Xms1g -Xmx1g"
       - xpack.security.enabled=false
     volumes:
       - elasticsearch_data:/usr/share/elasticsearch/data
     ports:
       - "9200:9200"
     networks:
       - app-network
     restart: unless-stopped
   
   # Kibanaæ—¥å¿—å¯è§†åŒ–
   kibana:
     image: docker.elastic.co/kibana/kibana:8.8.0
     environment:
       - ELASTICSEARCH_HOSTS=http://elasticsearch:9200
     ports:
       - "5601:5601"
     depends_on:
       - elasticsearch
     networks:
       - app-network
     restart: unless-stopped
   
   # Prometheusç›‘æ§
   prometheus:
     image: prom/prometheus:latest
     command:
       - '--config.file=/etc/prometheus/prometheus.yml'
       - '--storage.tsdb.path=/prometheus'
       - '--web.console.libraries=/etc/prometheus/console_libraries'
       - '--web.console.templates=/etc/prometheus/consoles'
       - '--storage.tsdb.retention.time=200h'
       - '--web.enable-lifecycle'
     volumes:
       - ./prometheus.yml:/etc/prometheus/prometheus.yml
       - prometheus_data:/prometheus
     ports:
       - "9090:9090"
     networks:
       - app-network
     restart: unless-stopped
   
   # Grafanaä»ªè¡¨æ¿
   grafana:
     image: grafana/grafana:latest
     environment:
       - GF_SECURITY_ADMIN_PASSWORD=${GRAFANA_PASSWORD}
     volumes:
       - grafana_data:/var/lib/grafana
       - ./grafana/dashboards:/etc/grafana/provisioning/dashboards
       - ./grafana/datasources:/etc/grafana/provisioning/datasources
     ports:
       - "3001:3000"
     depends_on:
       - prometheus
     networks:
       - app-network
     restart: unless-stopped
 
 volumes:
   postgres_data:
   redis_data:
   elasticsearch_data:
   prometheus_data:
   grafana_data:
 
 networks:
   app-network:
     driver: bridge
 ```

 ### 8.2 Kuberneteséƒ¨ç½²

 **ã€ä»£ç å·¥ç¨‹ã€‘**

 ```yaml
 # k8s/namespace.yaml
 apiVersion: v1
 kind: Namespace
 metadata:
   name: intelligent-agent-system
   labels:
     name: intelligent-agent-system
 ```

 ```yaml
 # k8s/configmap.yaml
 apiVersion: v1
 kind: ConfigMap
 metadata:
   name: app-config
   namespace: intelligent-agent-system
 data:
   app.properties: |
     # åº”ç”¨é…ç½®
     NODE_ENV=production
     LOG_LEVEL=info
     
     # æ•°æ®åº“é…ç½®
     DB_HOST=postgres-service
     DB_PORT=5432
     DB_NAME=intelligent_agent_db
     
     # Redisé…ç½®
     REDIS_HOST=redis-service
     REDIS_PORT=6379
     
     # ç›‘æ§é…ç½®
     METRICS_ENABLED=true
     METRICS_PORT=9090
 ```

 ```yaml
 # k8s/secret.yaml
 apiVersion: v1
 kind: Secret
 metadata:
   name: app-secrets
   namespace: intelligent-agent-system
 type: Opaque
 data:
   # Base64ç¼–ç çš„æ•æ„Ÿä¿¡æ¯
   DATABASE_PASSWORD: <base64-encoded-password>
   REDIS_PASSWORD: <base64-encoded-password>
   JWT_SECRET: <base64-encoded-jwt-secret>
   API_KEYS: <base64-encoded-api-keys>
 ```

 ```yaml
 # k8s/deployment.yaml
 apiVersion: apps/v1
 kind: Deployment
 metadata:
   name: intelligent-agent-app
   namespace: intelligent-agent-system
   labels:
     app: intelligent-agent
 spec:
   replicas: 3
   selector:
     matchLabels:
       app: intelligent-agent
   template:
     metadata:
       labels:
         app: intelligent-agent
     spec:
       containers:
       - name: app
         image: intelligent-agent:latest
         ports:
         - containerPort: 3000
         env:
         - name: NODE_ENV
           value: "production"
         - name: DATABASE_URL
           valueFrom:
             secretKeyRef:
               name: app-secrets
               key: DATABASE_URL
         - name: REDIS_URL
           valueFrom:
             secretKeyRef:
               name: app-secrets
               key: REDIS_URL
         resources:
           requests:
             memory: "1Gi"
             cpu: "500m"
           limits:
             memory: "2Gi"
             cpu: "1000m"
         livenessProbe:
           httpGet:
             path: /health
             port: 3000
           initialDelaySeconds: 30
           periodSeconds: 10
         readinessProbe:
           httpGet:
             path: /ready
             port: 3000
           initialDelaySeconds: 5
           periodSeconds: 5
         volumeMounts:
         - name: config-volume
           mountPath: /app/config
         - name: logs-volume
           mountPath: /app/logs
       volumes:
       - name: config-volume
         configMap:
           name: app-config
       - name: logs-volume
         emptyDir: {}
       imagePullSecrets:
       - name: registry-secret
 ```

 ```yaml
 # k8s/service.yaml
 apiVersion: v1
 kind: Service
 metadata:
   name: intelligent-agent-service
   namespace: intelligent-agent-system
 spec:
   selector:
     app: intelligent-agent
   ports:
   - protocol: TCP
     port: 80
     targetPort: 3000
   type: ClusterIP
 ```

 ```yaml
 # k8s/ingress.yaml
 apiVersion: networking.k8s.io/v1
 kind: Ingress
 metadata:
   name: intelligent-agent-ingress
   namespace: intelligent-agent-system
   annotations:
     kubernetes.io/ingress.class: "nginx"
     cert-manager.io/cluster-issuer: "letsencrypt-prod"
     nginx.ingress.kubernetes.io/rate-limit: "100"
     nginx.ingress.kubernetes.io/rate-limit-window: "1m"
 spec:
   tls:
   - hosts:
     - api.intelligent-agent.com
     secretName: intelligent-agent-tls
   rules:
   - host: api.intelligent-agent.com
     http:
       paths:
       - path: /
         pathType: Prefix
         backend:
           service:
             name: intelligent-agent-service
             port:
               number: 80
 ```

 ```yaml
 # k8s/hpa.yaml
 apiVersion: autoscaling/v2
 kind: HorizontalPodAutoscaler
 metadata:
   name: intelligent-agent-hpa
   namespace: intelligent-agent-system
 spec:
   scaleTargetRef:
     apiVersion: apps/v1
     kind: Deployment
     name: intelligent-agent-app
   minReplicas: 3
   maxReplicas: 10
   metrics:
   - type: Resource
     resource:
       name: cpu
       target:
         type: Utilization
         averageUtilization: 70
   - type: Resource
     resource:
       name: memory
       target:
         type: Utilization
         averageUtilization: 80
   behavior:
     scaleDown:
       stabilizationWindowSeconds: 300
       policies:
       - type: Percent
         value: 10
         periodSeconds: 60
     scaleUp:
       stabilizationWindowSeconds: 60
       policies:
       - type: Percent
           value: 50
           periodSeconds: 60
   ```

 ### 8.3 CI/CDæµæ°´çº¿

 **ã€ä»£ç å·¥ç¨‹ã€‘**

 ```yaml
 # .github/workflows/ci-cd.yml
 name: CI/CD Pipeline
 
 on:
   push:
     branches: [ main, develop ]
   pull_request:
     branches: [ main ]
 
 env:
   REGISTRY: ghcr.io
   IMAGE_NAME: ${{ github.repository }}
 
 jobs:
   # ä»£ç è´¨é‡æ£€æŸ¥
   quality-check:
     runs-on: ubuntu-latest
     steps:
     - uses: actions/checkout@v3
     
     - name: Setup Node.js
       uses: actions/setup-node@v3
       with:
         node-version: '18'
         cache: 'npm'
     
     - name: Install dependencies
       run: npm ci
     
     - name: Run linting
       run: npm run lint
     
     - name: Run type checking
       run: npm run type-check
     
     - name: Run security audit
       run: npm audit --audit-level moderate
   
   # å•å…ƒæµ‹è¯•
   unit-tests:
     runs-on: ubuntu-latest
     needs: quality-check
     steps:
     - uses: actions/checkout@v3
     
     - name: Setup Node.js
       uses: actions/setup-node@v3
       with:
         node-version: '18'
         cache: 'npm'
     
     - name: Install dependencies
       run: npm ci
     
     - name: Run unit tests
       run: npm run test:unit -- --coverage
     
     - name: Upload coverage reports
       uses: codecov/codecov-action@v3
       with:
         file: ./coverage/lcov.info
   
   # é›†æˆæµ‹è¯•
   integration-tests:
     runs-on: ubuntu-latest
     needs: unit-tests
     services:
       postgres:
         image: postgres:15
         env:
           POSTGRES_PASSWORD: postgres
           POSTGRES_DB: test_db
         options: >-
           --health-cmd pg_isready
           --health-interval 10s
           --health-timeout 5s
           --health-retries 5
       redis:
         image: redis:7
         options: >-
           --health-cmd "redis-cli ping"
           --health-interval 10s
           --health-timeout 5s
           --health-retries 5
     
     steps:
     - uses: actions/checkout@v3
     
     - name: Setup Node.js
       uses: actions/setup-node@v3
       with:
         node-version: '18'
         cache: 'npm'
     
     - name: Install dependencies
       run: npm ci
     
     - name: Run database migrations
       run: npm run db:migrate
       env:
         DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
     
     - name: Run integration tests
       run: npm run test:integration
       env:
         DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
         REDIS_URL: redis://localhost:6379
   
   # æ„å»ºDockeré•œåƒ
   build-image:
     runs-on: ubuntu-latest
     needs: [unit-tests, integration-tests]
     permissions:
       contents: read
       packages: write
     
     steps:
     - uses: actions/checkout@v3
     
     - name: Log in to Container Registry
       uses: docker/login-action@v2
       with:
         registry: ${{ env.REGISTRY }}
         username: ${{ github.actor }}
         password: ${{ secrets.GITHUB_TOKEN }}
     
     - name: Extract metadata
       id: meta
       uses: docker/metadata-action@v4
       with:
         images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
         tags: |
           type=ref,event=branch
           type=ref,event=pr
           type=sha,prefix={{branch}}-
     
     - name: Build and push Docker image
       uses: docker/build-push-action@v4
       with:
         context: .
         push: true
         tags: ${{ steps.meta.outputs.tags }}
         labels: ${{ steps.meta.outputs.labels }}
   
   # éƒ¨ç½²åˆ°æµ‹è¯•ç¯å¢ƒ
   deploy-staging:
     runs-on: ubuntu-latest
     needs: build-image
     if: github.ref == 'refs/heads/develop'
     environment: staging
     
     steps:
     - uses: actions/checkout@v3
     
     - name: Deploy to staging
       run: |
         echo "Deploying to staging environment"
         # è¿™é‡Œæ·»åŠ å®é™…çš„éƒ¨ç½²è„šæœ¬
   
   # éƒ¨ç½²åˆ°ç”Ÿäº§ç¯å¢ƒ
   deploy-production:
     runs-on: ubuntu-latest
     needs: build-image
     if: github.ref == 'refs/heads/main'
     environment: production
     
     steps:
     - uses: actions/checkout@v3
     
     - name: Deploy to production
       run: |
         echo "Deploying to production environment"
         # è¿™é‡Œæ·»åŠ å®é™…çš„éƒ¨ç½²è„šæœ¬
 ```

 ---

 ## 9. å®‰å…¨é˜²æŠ¤ä¸æƒé™æ§åˆ¶

 ### 9.1 èº«ä»½è®¤è¯ä¸æˆæƒ

 **ã€ä»£ç å·¥ç¨‹ã€‘**

 ```typescript
 // JWTè®¤è¯ä¸­é—´ä»¶
 class JWTAuthMiddleware {
   private jwtSecret: string;
   private tokenBlacklist: Set<string> = new Set();
   
   constructor(secret: string) {
     this.jwtSecret = secret;
   }
   
   // ç”Ÿæˆè®¿é—®ä»¤ç‰Œ
   generateAccessToken(payload: TokenPayload): string {
     return jwt.sign(payload, this.jwtSecret, {
       expiresIn: '15m', // çŸ­æœŸè®¿é—®ä»¤ç‰Œ
       issuer: 'intelligent-agent-system',
       audience: 'api-users'
     });
   }
   
   // ç”Ÿæˆåˆ·æ–°ä»¤ç‰Œ
   generateRefreshToken(userId: string): string {
     return jwt.sign(
       { userId, type: 'refresh' },
       this.jwtSecret,
       {
         expiresIn: '7d', // é•¿æœŸåˆ·æ–°ä»¤ç‰Œ
         issuer: 'intelligent-agent-system'
       }
     );
   }
   
   // éªŒè¯ä»¤ç‰Œ
   async verifyToken(token: string): Promise<TokenPayload> {
     // æ£€æŸ¥ä»¤ç‰Œæ˜¯å¦åœ¨é»‘åå•ä¸­
     if (this.tokenBlacklist.has(token)) {
       throw new Error('Token has been revoked');
     }
     
     try {
       const decoded = jwt.verify(token, this.jwtSecret) as TokenPayload;
       
       // éªŒè¯ä»¤ç‰Œæœ‰æ•ˆæ€§
       await this.validateTokenClaims(decoded);
       
       return decoded;
     } catch (error) {
       throw new Error('Invalid token');
     }
   }
   
   // æ’¤é”€ä»¤ç‰Œ
   revokeToken(token: string): void {
     this.tokenBlacklist.add(token);
     
     // å®šæœŸæ¸…ç†è¿‡æœŸçš„é»‘åå•ä»¤ç‰Œ
     setTimeout(() => {
       this.tokenBlacklist.delete(token);
     }, 15 * 60 * 1000); // 15åˆ†é’Ÿåæ¸…ç†
   }
   
   private async validateTokenClaims(payload: TokenPayload): Promise<void> {
     // éªŒè¯ç”¨æˆ·æ˜¯å¦ä»ç„¶å­˜åœ¨ä¸”æ´»è·ƒ
     const user = await UserService.findById(payload.userId);
     if (!user || !user.isActive) {
       throw new Error('User not found or inactive');
     }
     
     // éªŒè¯ç”¨æˆ·æƒé™æ˜¯å¦å‘ç”Ÿå˜åŒ–
     if (user.lastPermissionUpdate > payload.iat * 1000) {
       throw new Error('User permissions have been updated');
     }
   }
 }
 
 // åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶(RBAC)
 class RBACManager {
   private roles: Map<string, Role> = new Map();
   private permissions: Map<string, Permission> = new Map();
   
   constructor() {
     this.initializeDefaultRoles();
   }
   
   // æ£€æŸ¥ç”¨æˆ·æƒé™
   async checkPermission(
     userId: string, 
     resource: string, 
     action: string
   ): Promise<boolean> {
     const user = await UserService.findById(userId);
     if (!user) return false;
     
     // è·å–ç”¨æˆ·æ‰€æœ‰è§’è‰²
     const userRoles = await this.getUserRoles(userId);
     
     // æ£€æŸ¥æ˜¯å¦æœ‰ä»»ä½•è§’è‰²å…·æœ‰æ‰€éœ€æƒé™
     for (const role of userRoles) {
       if (await this.roleHasPermission(role, resource, action)) {
         // è®°å½•æƒé™æ£€æŸ¥æ—¥å¿—
         await this.logPermissionCheck(userId, resource, action, true);
         return true;
       }
     }
     
     // è®°å½•æƒé™æ‹’ç»æ—¥å¿—
     await this.logPermissionCheck(userId, resource, action, false);
     return false;
   }
   
   // è§’è‰²æƒé™æ£€æŸ¥
   private async roleHasPermission(
     roleName: string, 
     resource: string, 
     action: string
   ): Promise<boolean> {
     const role = this.roles.get(roleName);
     if (!role) return false;
     
     // æ£€æŸ¥ç›´æ¥æƒé™
     for (const permission of role.permissions) {
       if (this.matchesPermission(permission, resource, action)) {
         return true;
       }
     }
     
     // æ£€æŸ¥ç»§æ‰¿çš„æƒé™
     for (const parentRole of role.inherits) {
       if (await this.roleHasPermission(parentRole, resource, action)) {
         return true;
       }
     }
     
     return false;
   }
   
   private matchesPermission(
     permission: Permission, 
     resource: string, 
     action: string
   ): boolean {
     // æ”¯æŒé€šé…ç¬¦åŒ¹é…
     const resourceMatch = this.wildcardMatch(permission.resource, resource);
     const actionMatch = this.wildcardMatch(permission.action, action);
     
     return resourceMatch && actionMatch;
   }
   
   private wildcardMatch(pattern: string, value: string): boolean {
     const regex = new RegExp(pattern.replace(/\*/g, '.*'));
     return regex.test(value);
   }
   
   private async getUserRoles(userId: string): Promise<string[]> {
     // ä»æ•°æ®åº“è·å–ç”¨æˆ·è§’è‰²
     const userRoles = await UserRoleService.findByUserId(userId);
     return userRoles.map(ur => ur.roleName);
   }
   
   private async logPermissionCheck(
     userId: string, 
     resource: string, 
     action: string, 
     granted: boolean
   ): Promise<void> {
     await AuditLogger.log({
       type: 'permission_check',
       userId,
       resource,
       action,
       granted,
       timestamp: new Date(),
       ip: this.getCurrentIP(),
       userAgent: this.getCurrentUserAgent()
     });
   }
   
   private initializeDefaultRoles(): void {
     // ç³»ç»Ÿç®¡ç†å‘˜è§’è‰²
     this.roles.set('admin', {
       name: 'admin',
       description: 'System Administrator',
       permissions: [
         { resource: '*', action: '*' } // å…¨éƒ¨æƒé™
       ],
       inherits: []
     });
     
     // æ™ºèƒ½ä½“ç®¡ç†å‘˜è§’è‰²
     this.roles.set('agent_manager', {
       name: 'agent_manager',
       description: 'Agent Manager',
       permissions: [
         { resource: 'agents', action: '*' },
         { resource: 'tasks', action: 'read' },
         { resource: 'tasks', action: 'create' },
         { resource: 'tasks', action: 'update' },
         { resource: 'monitoring', action: 'read' }
       ],
       inherits: ['user']
     });
     
     // æ™®é€šç”¨æˆ·è§’è‰²
     this.roles.set('user', {
       name: 'user',
       description: 'Regular User',
       permissions: [
         { resource: 'tasks', action: 'read' },
         { resource: 'tasks', action: 'create' },
         { resource: 'profile', action: '*' }
       ],
       inherits: []
     });
   }
 }
 ```

 ### 9.2 APIå®‰å…¨é˜²æŠ¤

 **ã€ä»£ç å·¥ç¨‹ã€‘**

 ```typescript
 // APIå®‰å…¨ä¸­é—´ä»¶
 class APISecurityMiddleware {
   private rateLimiter: RateLimiter;
   private inputValidator: InputValidator;
   private sqlInjectionDetector: SQLInjectionDetector;
   private xssProtector: XSSProtector;
   
   constructor() {
     this.rateLimiter = new RateLimiter();
     this.inputValidator = new InputValidator();
     this.sqlInjectionDetector = new SQLInjectionDetector();
     this.xssProtector = new XSSProtector();
   }
   
   // è¯·æ±‚å®‰å…¨æ£€æŸ¥
   async securityCheck(req: Request, res: Response, next: NextFunction): Promise<void> {
     try {
       // 1. é€Ÿç‡é™åˆ¶æ£€æŸ¥
       await this.checkRateLimit(req);
       
       // 2. è¾“å…¥éªŒè¯
       await this.validateInput(req);
       
       // 3. SQLæ³¨å…¥æ£€æµ‹
       await this.detectSQLInjection(req);
       
       // 4. XSSæ”»å‡»æ£€æµ‹
       await this.detectXSS(req);
       
       // 5. CSRFä¿æŠ¤
       await this.checkCSRF(req);
       
       // 6. è¯·æ±‚å¤§å°é™åˆ¶
       this.checkRequestSize(req);
       
       // 7. å®‰å…¨å¤´è®¾ç½®
       this.setSecurityHeaders(res);
       
       next();
     } catch (error) {
       // è®°å½•å®‰å…¨äº‹ä»¶
       await this.logSecurityEvent(req, error);
       
       res.status(403).json({
         error: 'Security check failed',
         message: error.message
       });
     }
   }
   
   private async checkRateLimit(req: Request): Promise<void> {
     const clientId = this.getClientId(req);
     const endpoint = req.path;
     
     const isAllowed = await this.rateLimiter.checkLimit(clientId, endpoint);
     
     if (!isAllowed) {
       throw new Error('Rate limit exceeded');
     }
   }
   
   private async validateInput(req: Request): Promise<void> {
     // éªŒè¯è¯·æ±‚ä½“
     if (req.body) {
       const validationResult = await this.inputValidator.validate(req.body, req.path);
       if (!validationResult.isValid) {
         throw new Error(`Input validation failed: ${validationResult.errors.join(', ')}`);
       }
     }
     
     // éªŒè¯æŸ¥è¯¢å‚æ•°
     if (req.query) {
       const queryValidation = await this.inputValidator.validateQuery(req.query);
       if (!queryValidation.isValid) {
         throw new Error(`Query validation failed: ${queryValidation.errors.join(', ')}`);
       }
     }
   }
   
   private async detectSQLInjection(req: Request): Promise<void> {
     const suspiciousPatterns = [
       /('|(\-\-)|(;)|(\||\|)|(\*|\*))/i,
       /(union|select|insert|delete|update|drop|create|alter|exec|execute)/i,
       /(script|javascript|vbscript|onload|onerror|onclick)/i
     ];
     
     const checkString = JSON.stringify(req.body) + JSON.stringify(req.query);
     
     for (const pattern of suspiciousPatterns) {
       if (pattern.test(checkString)) {
         throw new Error('Potential SQL injection detected');
       }
     }
   }
   
   private async detectXSS(req: Request): Promise<void> {
     const xssPatterns = [
       /<script[^>]*>.*?<\/script>/gi,
       /<iframe[^>]*>.*?<\/iframe>/gi,
       /javascript:/gi,
       /on\w+\s*=/gi
     ];
     
     const checkString = JSON.stringify(req.body) + JSON.stringify(req.query);
     
     for (const pattern of xssPatterns) {
       if (pattern.test(checkString)) {
         throw new Error('Potential XSS attack detected');
       }
     }
   }
   
   private async checkCSRF(req: Request): Promise<void> {
     if (['POST', 'PUT', 'DELETE', 'PATCH'].includes(req.method)) {
       const csrfToken = req.headers['x-csrf-token'] as string;
       const sessionToken = req.session?.csrfToken;
       
       if (!csrfToken || csrfToken !== sessionToken) {
         throw new Error('CSRF token validation failed');
       }
     }
   }
   
   private checkRequestSize(req: Request): void {
     const maxSize = 10 * 1024 * 1024; // 10MB
     const contentLength = parseInt(req.headers['content-length'] || '0');
     
     if (contentLength > maxSize) {
       throw new Error('Request size exceeds limit');
     }
   }
   
   private setSecurityHeaders(res: Response): void {
     // è®¾ç½®å®‰å…¨ç›¸å…³çš„HTTPå¤´
     res.setHeader('X-Content-Type-Options', 'nosniff');
     res.setHeader('X-Frame-Options', 'DENY');
     res.setHeader('X-XSS-Protection', '1; mode=block');
     res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');
     res.setHeader('Content-Security-Policy', "default-src 'self'; script-src 'self' 'unsafe-inline'");
     res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');
   }
   
   private getClientId(req: Request): string {
     // ä¼˜å…ˆä½¿ç”¨ç”¨æˆ·IDï¼Œå…¶æ¬¡ä½¿ç”¨IPåœ°å€
     return req.user?.id || req.ip || 'anonymous';
   }
   
   private async logSecurityEvent(req: Request, error: Error): Promise<void> {
     await SecurityLogger.log({
       type: 'security_violation',
       error: error.message,
       ip: req.ip,
       userAgent: req.headers['user-agent'],
       path: req.path,
       method: req.method,
       timestamp: new Date(),
       userId: req.user?.id
     });
   }
 }
 
 // æ•°æ®åŠ å¯†æœåŠ¡
 class EncryptionService {
   private algorithm = 'aes-256-gcm';
   private keyLength = 32;
   private ivLength = 16;
   private tagLength = 16;
   
   // åŠ å¯†æ•æ„Ÿæ•°æ®
   encrypt(plaintext: string, key: Buffer): EncryptedData {
     const iv = crypto.randomBytes(this.ivLength);
     const cipher = crypto.createCipher(this.algorithm, key);
     cipher.setAAD(Buffer.from('intelligent-agent-system'));
     
     let encrypted = cipher.update(plaintext, 'utf8', 'hex');
     encrypted += cipher.final('hex');
     
     const tag = cipher.getAuthTag();
     
     return {
       encrypted,
       iv: iv.toString('hex'),
       tag: tag.toString('hex')
     };
   }
   
   // è§£å¯†æ•æ„Ÿæ•°æ®
   decrypt(encryptedData: EncryptedData, key: Buffer): string {
     const decipher = crypto.createDecipher(this.algorithm, key);
     decipher.setAAD(Buffer.from('intelligent-agent-system'));
     decipher.setAuthTag(Buffer.from(encryptedData.tag, 'hex'));
     
     let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
     decrypted += decipher.final('utf8');
     
     return decrypted;
   }
   
   // ç”Ÿæˆå®‰å…¨çš„éšæœºå¯†é’¥
   generateKey(): Buffer {
     return crypto.randomBytes(this.keyLength);
   }
   
   // å¯†ç å“ˆå¸Œ
   async hashPassword(password: string): Promise<string> {
     const saltRounds = 12;
     return await bcrypt.hash(password, saltRounds);
   }
   
   // å¯†ç éªŒè¯
   async verifyPassword(password: string, hash: string): Promise<boolean> {
     return await bcrypt.compare(password, hash);
   }
 }
 ```

 ---

 ## 10. æµ‹è¯•ç­–ç•¥ä¸è´¨é‡ä¿è¯

 ### 10.1 æµ‹è¯•é‡‘å­—å¡”æ¶æ„

 **ã€ä»£ç å·¥ç¨‹ã€‘**

 ```mermaid
 graph TB
   A[æµ‹è¯•é‡‘å­—å¡”] --> B[å•å…ƒæµ‹è¯• 70%]
   A --> C[é›†æˆæµ‹è¯• 20%]
   A --> D[ç«¯åˆ°ç«¯æµ‹è¯• 10%]
   
   B --> B1[ç»„ä»¶æµ‹è¯•]
   B --> B2[æœåŠ¡æµ‹è¯•]
   B --> B3[å·¥å…·å‡½æ•°æµ‹è¯•]
   
   C --> C1[APIæµ‹è¯•]
   C --> C2[æ•°æ®åº“æµ‹è¯•]
   C --> C3[å¤–éƒ¨æœåŠ¡æµ‹è¯•]
   
   D --> D1[ç”¨æˆ·æµç¨‹æµ‹è¯•]
   D --> D2[æ€§èƒ½æµ‹è¯•]
   D --> D3[å®‰å…¨æµ‹è¯•]
 ```

 ```typescript
 // å•å…ƒæµ‹è¯•ç¤ºä¾‹ - Agentæµ‹è¯•
 describe('MetaAgent', () => {
   let metaAgent: MetaAgent;
   let mockTaskAnalyzer: jest.Mocked<TaskAnalyzer>;
   let mockCoordinationEngine: jest.Mocked<CoordinationEngine>;
   
   beforeEach(() => {
     mockTaskAnalyzer = {
       analyze: jest.fn(),
       decompose: jest.fn(),
       estimateComplexity: jest.fn()
     } as jest.Mocked<TaskAnalyzer>;
     
     mockCoordinationEngine = {
       assignTask: jest.fn(),
       monitorExecution: jest.fn(),
       handleFailure: jest.fn()
     } as jest.Mocked<CoordinationEngine>;
     
     metaAgent = new MetaAgent(mockTaskAnalyzer, mockCoordinationEngine);
   });
   
   describe('execute', () => {
     it('should successfully execute a simple task', async () => {
       // Arrange
       const task: Task = {
         id: 'test-task-1',
         type: 'code_generation',
         description: 'Generate a simple function',
         priority: 'medium',
         requirements: ['typescript', 'unit-tests']
       };
       
       const analysisResult = {
         complexity: 'low',
         estimatedTime: 300,
         requiredSkills: ['typescript'],
         subtasks: []
       };
       
       mockTaskAnalyzer.analyze.mockResolvedValue(analysisResult);
       mockCoordinationEngine.assignTask.mockResolvedValue({
         agentId: 'code-agent-1',
         status: 'assigned'
       });
       
       // Act
       const result = await metaAgent.execute(task);
       
       // Assert
       expect(result.status).toBe('completed');
       expect(mockTaskAnalyzer.analyze).toHaveBeenCalledWith(task);
       expect(mockCoordinationEngine.assignTask).toHaveBeenCalled();
     });
     
     it('should handle complex task decomposition', async () => {
       // Arrange
       const complexTask: Task = {
         id: 'complex-task-1',
         type: 'full_stack_development',
         description: 'Build a complete web application',
         priority: 'high',
         requirements: ['react', 'nodejs', 'database']
       };
       
       const analysisResult = {
         complexity: 'high',
         estimatedTime: 7200,
         requiredSkills: ['react', 'nodejs', 'database'],
         subtasks: [
           { id: 'subtask-1', type: 'frontend_development' },
           { id: 'subtask-2', type: 'backend_development' },
           { id: 'subtask-3', type: 'database_design' }
         ]
       };
       
       mockTaskAnalyzer.analyze.mockResolvedValue(analysisResult);
       mockTaskAnalyzer.decompose.mockResolvedValue(analysisResult.subtasks);
       
       // Act
       const result = await metaAgent.execute(complexTask);
       
       // Assert
       expect(mockTaskAnalyzer.decompose).toHaveBeenCalledWith(complexTask);
       expect(result.subtasks).toHaveLength(3);
     });
     
     it('should handle task execution failures gracefully', async () => {
       // Arrange
       const task: Task = {
         id: 'failing-task',
         type: 'code_generation',
         description: 'Generate complex algorithm',
         priority: 'high'
       };
       
       mockTaskAnalyzer.analyze.mockRejectedValue(new Error('Analysis failed'));
       
       // Act & Assert
       await expect(metaAgent.execute(task)).rejects.toThrow('Analysis failed');
     });
   });
   
   describe('performance tests', () => {
     it('should complete simple tasks within time limit', async () => {
       // Arrange
       const startTime = Date.now();
       const task: Task = {
         id: 'perf-test-task',
         type: 'simple_calculation',
         description: 'Perform basic calculation'
       };
       
       mockTaskAnalyzer.analyze.mockResolvedValue({
         complexity: 'low',
         estimatedTime: 100
       });
       
       // Act
       await metaAgent.execute(task);
       const executionTime = Date.now() - startTime;
       
       // Assert
       expect(executionTime).toBeLessThan(1000); // åº”åœ¨1ç§’å†…å®Œæˆ
     });
   });
 });
 
 // é›†æˆæµ‹è¯•ç¤ºä¾‹ - APIæµ‹è¯•
 describe('Agent API Integration', () => {
   let app: Application;
   let testDb: Database;
   
   beforeAll(async () => {
     // è®¾ç½®æµ‹è¯•æ•°æ®åº“
     testDb = await createTestDatabase();
     app = createTestApp(testDb);
   });
   
   afterAll(async () => {
     await testDb.close();
   });
   
   beforeEach(async () => {
     await testDb.clear();
     await seedTestData(testDb);
   });
   
   describe('POST /api/tasks', () => {
     it('should create a new task successfully', async () => {
       // Arrange
       const taskData = {
         type: 'code_generation',
         description: 'Generate a React component',
         priority: 'medium',
         requirements: ['react', 'typescript']
       };
       
       // Act
       const response = await request(app)
         .post('/api/tasks')
         .send(taskData)
         .set('Authorization', 'Bearer ' + getTestToken())
         .expect(201);
       
       // Assert
       expect(response.body).toHaveProperty('id');
       expect(response.body.type).toBe(taskData.type);
       expect(response.body.status).toBe('pending');
       
       // éªŒè¯æ•°æ®åº“ä¸­çš„æ•°æ®
       const savedTask = await testDb.tasks.findById(response.body.id);
       expect(savedTask).toBeTruthy();
       expect(savedTask.description).toBe(taskData.description);
     });
     
     it('should validate required fields', async () => {
       // Arrange
       const invalidTaskData = {
         description: 'Missing type field'
       };
       
       // Act & Assert
       const response = await request(app)
         .post('/api/tasks')
         .send(invalidTaskData)
         .set('Authorization', 'Bearer ' + getTestToken())
         .expect(400);
       
       expect(response.body.error).toContain('type is required');
     });
     
     it('should handle authentication errors', async () => {
       // Arrange
       const taskData = {
         type: 'code_generation',
         description: 'Test task'
       };
       
       // Act & Assert
       await request(app)
         .post('/api/tasks')
         .send(taskData)
         .expect(401);
     });
   });
   
   describe('GET /api/tasks/:id', () => {
     it('should retrieve task details', async () => {
       // Arrange
       const task = await createTestTask(testDb);
       
       // Act
       const response = await request(app)
         .get(`/api/tasks/${task.id}`)
         .set('Authorization', 'Bearer ' + getTestToken())
         .expect(200);
       
       // Assert
       expect(response.body.id).toBe(task.id);
       expect(response.body.description).toBe(task.description);
     });
     
     it('should return 404 for non-existent task', async () => {
       // Act & Assert
       await request(app)
         .get('/api/tasks/non-existent-id')
         .set('Authorization', 'Bearer ' + getTestToken())
         .expect(404);
     });
   });
 });
 ```

 ### 10.2 è‡ªåŠ¨åŒ–æµ‹è¯•æµç¨‹

 **ã€ä»£ç å·¥ç¨‹ã€‘**

 ```typescript
 // æµ‹è¯•é…ç½®ç®¡ç†
 class TestConfigManager {
   private config: TestConfig;
   
   constructor() {
     this.config = this.loadTestConfig();
   }
   
   private loadTestConfig(): TestConfig {
     return {
       // æ•°æ®åº“é…ç½®
       database: {
         host: process.env.TEST_DB_HOST || 'localhost',
         port: parseInt(process.env.TEST_DB_PORT || '5433'),
         database: process.env.TEST_DB_NAME || 'test_db',
         username: process.env.TEST_DB_USER || 'test_user',
         password: process.env.TEST_DB_PASS || 'test_pass'
       },
       
       // Redisé…ç½®
       redis: {
         host: process.env.TEST_REDIS_HOST || 'localhost',
         port: parseInt(process.env.TEST_REDIS_PORT || '6380'),
         db: parseInt(process.env.TEST_REDIS_DB || '1')
       },
       
       // æµ‹è¯•è¶…æ—¶é…ç½®
       timeouts: {
         unit: 5000,      // 5ç§’
         integration: 30000, // 30ç§’
         e2e: 60000       // 60ç§’
       },
       
       // å¹¶å‘é…ç½®
       concurrency: {
         unit: 4,
         integration: 2,
         e2e: 1
       },
       
       // è¦†ç›–ç‡è¦æ±‚
       coverage: {
         statements: 80,
         branches: 75,
         functions: 80,
         lines: 80
       }
     };
   }
   
   getConfig(): TestConfig {
     return this.config;
   }
 }
 
 // æµ‹è¯•æ•°æ®å·¥å‚
 class TestDataFactory {
   // åˆ›å»ºæµ‹è¯•ç”¨æˆ·
   static createTestUser(overrides: Partial<User> = {}): User {
     return {
       id: faker.datatype.uuid(),
       username: faker.internet.userName(),
       email: faker.internet.email(),
       password: faker.internet.password(),
       roles: ['user'],
       isActive: true,
       createdAt: new Date(),
       updatedAt: new Date(),
       ...overrides
     };
   }
   
   // åˆ›å»ºæµ‹è¯•ä»»åŠ¡
   static createTestTask(overrides: Partial<Task> = {}): Task {
     return {
       id: faker.datatype.uuid(),
       type: faker.helpers.arrayElement(['code_generation', 'analysis', 'refactoring']),
       description: faker.lorem.sentence(),
       priority: faker.helpers.arrayElement(['low', 'medium', 'high']),
       status: 'pending',
       requirements: faker.helpers.arrayElements(['typescript', 'react', 'nodejs'], 2),
       createdAt: new Date(),
       updatedAt: new Date(),
       ...overrides
     };
   }
   
   // åˆ›å»ºæµ‹è¯•æ™ºèƒ½ä½“
   static createTestAgent(overrides: Partial<Agent> = {}): Agent {
     return {
       id: faker.datatype.uuid(),
       name: faker.name.firstName() + 'Agent',
       type: faker.helpers.arrayElement(['meta', 'code', 'analysis']),
       capabilities: faker.helpers.arrayElements(['typescript', 'react', 'nodejs'], 3),
       status: 'idle',
       performance: {
         tasksCompleted: faker.datatype.number({ min: 0, max: 100 }),
         averageResponseTime: faker.datatype.number({ min: 100, max: 5000 }),
         successRate: faker.datatype.float({ min: 0.7, max: 1.0 })
       },
       createdAt: new Date(),
       ...overrides
     };
   }
   
   // æ‰¹é‡åˆ›å»ºæµ‹è¯•æ•°æ®
   static async seedTestDatabase(db: Database): Promise<void> {
     // åˆ›å»ºæµ‹è¯•ç”¨æˆ·
     const users = Array.from({ length: 10 }, () => this.createTestUser());
     await db.users.insertMany(users);
     
     // åˆ›å»ºæµ‹è¯•æ™ºèƒ½ä½“
     const agents = Array.from({ length: 5 }, () => this.createTestAgent());
     await db.agents.insertMany(agents);
     
     // åˆ›å»ºæµ‹è¯•ä»»åŠ¡
     const tasks = Array.from({ length: 20 }, () => this.createTestTask({
       userId: faker.helpers.arrayElement(users).id
     }));
     await db.tasks.insertMany(tasks);
   }
 }
 
 // æµ‹è¯•å·¥å…·ç±»
 class TestUtils {
   // ç­‰å¾…å¼‚æ­¥æ“ä½œå®Œæˆ
   static async waitFor(
     condition: () => boolean | Promise<boolean>,
     timeout: number = 5000,
     interval: number = 100
   ): Promise<void> {
     const startTime = Date.now();
     
     while (Date.now() - startTime < timeout) {
       const result = await condition();
       if (result) {
         return;
       }
       await this.sleep(interval);
     }
     
     throw new Error(`Condition not met within ${timeout}ms`);
   }
   
   // ç¡çœ å‡½æ•°
   static sleep(ms: number): Promise<void> {
     return new Promise(resolve => setTimeout(resolve, ms));
   }
   
   // æ¨¡æ‹Ÿç½‘ç»œå»¶è¿Ÿ
   static async simulateNetworkDelay(min: number = 100, max: number = 500): Promise<void> {
     const delay = faker.datatype.number({ min, max });
     await this.sleep(delay);
   }
   
   // ç”Ÿæˆæµ‹è¯•JWTä»¤ç‰Œ
   static generateTestToken(payload: any = {}): string {
     return jwt.sign(
       {
         userId: faker.datatype.uuid(),
         username: faker.internet.userName(),
         roles: ['user'],
         ...payload
       },
       'test-secret',
       { expiresIn: '1h' }
     );
   }
   
   // æ¸…ç†æµ‹è¯•æ•°æ®
   static async cleanupTestData(db: Database): Promise<void> {
     await Promise.all([
       db.tasks.deleteMany({}),
       db.agents.deleteMany({}),
       db.users.deleteMany({}),
       db.logs.deleteMany({})
     ]);
   }
 }
 ```

 ### 10.3 è´¨é‡ä¿è¯æµç¨‹

 **ã€æç¤ºè¯å·¥ç¨‹ã€‘**

 ```
 ç³»ç»Ÿæç¤ºè¯ - ä»£ç è´¨é‡æ£€æŸ¥æ™ºèƒ½ä½“ï¼š
 
 ä½ æ˜¯ä¸€ä¸ªä¸“ä¸šçš„ä»£ç è´¨é‡æ£€æŸ¥æ™ºèƒ½ä½“ï¼Œè´Ÿè´£ç¡®ä¿ä»£ç ç¬¦åˆæœ€é«˜æ ‡å‡†ã€‚ä½ çš„èŒè´£åŒ…æ‹¬ï¼š
 
 1. **ä»£ç å®¡æŸ¥æ ‡å‡†**ï¼š
    - æ£€æŸ¥ä»£ç æ˜¯å¦éµå¾ªSOLIDåŸåˆ™
    - éªŒè¯è®¾è®¡æ¨¡å¼çš„æ­£ç¡®ä½¿ç”¨
    - ç¡®ä¿ä»£ç å¯è¯»æ€§å’Œå¯ç»´æŠ¤æ€§
    - æ£€æŸ¥æ€§èƒ½æ½œåœ¨é—®é¢˜
    - éªŒè¯å®‰å…¨æœ€ä½³å®è·µ
 
 2. **å®¡æŸ¥æµç¨‹**ï¼š
    - é™æ€ä»£ç åˆ†æ
    - æ¶æ„ä¸€è‡´æ€§æ£€æŸ¥
    - æµ‹è¯•è¦†ç›–ç‡éªŒè¯
    - æ–‡æ¡£å®Œæ•´æ€§æ£€æŸ¥
    - ä¾èµ–å®‰å…¨æ‰«æ
 
 3. **è¾“å‡ºæ ¼å¼**ï¼š
    - é—®é¢˜ä¸¥é‡ç¨‹åº¦åˆ†çº§ï¼ˆCritical/High/Medium/Lowï¼‰
    - å…·ä½“é—®é¢˜æè¿°å’Œä½ç½®
    - ä¿®å¤å»ºè®®å’Œæœ€ä½³å®è·µ
    - ä»£ç è´¨é‡è¯„åˆ†ï¼ˆ1-10åˆ†ï¼‰
 
 è¯·å¯¹æäº¤çš„ä»£ç è¿›è¡Œå…¨é¢å®¡æŸ¥ï¼Œç¡®ä¿å…¶ç¬¦åˆä¼ä¸šçº§å¼€å‘æ ‡å‡†ã€‚
 ```

 **ã€ä»£ç å·¥ç¨‹ã€‘**

 ```typescript
 // ä»£ç è´¨é‡æ£€æŸ¥å™¨
 class CodeQualityChecker {
   private linter: ESLint;
   private typeChecker: TypeScript.TypeChecker;
   private securityScanner: SecurityScanner;
   private performanceAnalyzer: PerformanceAnalyzer;
   
   constructor() {
     this.linter = new ESLint({
       configFile: '.eslintrc.js',
       fix: false
     });
     this.securityScanner = new SecurityScanner();
     this.performanceAnalyzer = new PerformanceAnalyzer();
   }
   
   // æ‰§è¡Œå…¨é¢çš„ä»£ç è´¨é‡æ£€æŸ¥
   async checkQuality(filePaths: string[]): Promise<QualityReport> {
     const report: QualityReport = {
       overall: { score: 0, grade: 'F' },
       issues: [],
       metrics: {
         complexity: 0,
         maintainability: 0,
         testCoverage: 0,
         security: 0,
         performance: 0
       },
       recommendations: []
     };
     
     try {
       // 1. è¯­æ³•å’Œé£æ ¼æ£€æŸ¥
       const lintResults = await this.runLinting(filePaths);
       report.issues.push(...this.processLintResults(lintResults));
       
       // 2. ç±»å‹æ£€æŸ¥
       const typeResults = await this.runTypeChecking(filePaths);
       report.issues.push(...this.processTypeResults(typeResults));
       
       // 3. å®‰å…¨æ‰«æ
       const securityResults = await this.runSecurityScan(filePaths);
       report.issues.push(...this.processSecurityResults(securityResults));
       
       // 4. æ€§èƒ½åˆ†æ
       const performanceResults = await this.runPerformanceAnalysis(filePaths);
       report.issues.push(...this.processPerformanceResults(performanceResults));
       
       // 5. å¤æ‚åº¦åˆ†æ
       const complexityResults = await this.analyzeComplexity(filePaths);
       report.metrics.complexity = complexityResults.average;
       
       // 6. æµ‹è¯•è¦†ç›–ç‡æ£€æŸ¥
       const coverageResults = await this.checkTestCoverage();
       report.metrics.testCoverage = coverageResults.percentage;
       
       // 7. è®¡ç®—æ€»ä½“è¯„åˆ†
       report.overall = this.calculateOverallScore(report);
       
       // 8. ç”Ÿæˆæ”¹è¿›å»ºè®®
       report.recommendations = this.generateRecommendations(report);
       
       return report;
     } catch (error) {
       throw new Error(`Quality check failed: ${error.message}`);
     }
   }
   
   private async runLinting(filePaths: string[]): Promise<ESLint.LintResult[]> {
     return await this.linter.lintFiles(filePaths);
   }
   
   private processLintResults(results: ESLint.LintResult[]): QualityIssue[] {
     const issues: QualityIssue[] = [];
     
     for (const result of results) {
       for (const message of result.messages) {
         issues.push({
           type: 'lint',
           severity: this.mapSeverity(message.severity),
           file: result.filePath,
           line: message.line,
           column: message.column,
           message: message.message,
           rule: message.ruleId || 'unknown',
           fixable: message.fix !== undefined
         });
       }
     }
     
     return issues;
   }
   
   private async runTypeChecking(filePaths: string[]): Promise<TypeCheckResult[]> {
     // ä½¿ç”¨TypeScriptç¼–è¯‘å™¨APIè¿›è¡Œç±»å‹æ£€æŸ¥
     const program = ts.createProgram(filePaths, {
       noEmit: true,
       strict: true,
       target: ts.ScriptTarget.ES2020,
       module: ts.ModuleKind.CommonJS
     });
     
     const diagnostics = ts.getPreEmitDiagnostics(program);
     
     return diagnostics.map(diagnostic => ({
       file: diagnostic.file?.fileName || 'unknown',
       line: diagnostic.file ? 
         diagnostic.file.getLineAndCharacterOfPosition(diagnostic.start!).line + 1 : 0,
       message: ts.flattenDiagnosticMessageText(diagnostic.messageText, '\n'),
       category: diagnostic.category
     }));
   }
   
   private async runSecurityScan(filePaths: string[]): Promise<SecurityIssue[]> {
     return await this.securityScanner.scan(filePaths);
   }
   
   private async runPerformanceAnalysis(filePaths: string[]): Promise<PerformanceIssue[]> {
     return await this.performanceAnalyzer.analyze(filePaths);
   }
   
   private async analyzeComplexity(filePaths: string[]): Promise<ComplexityResult> {
     const results: number[] = [];
     
     for (const filePath of filePaths) {
       const content = await fs.readFile(filePath, 'utf-8');
       const complexity = this.calculateCyclomaticComplexity(content);
       results.push(complexity);
     }
     
     return {
       average: results.reduce((a, b) => a + b, 0) / results.length,
       max: Math.max(...results),
       files: filePaths.map((path, index) => ({
         path,
         complexity: results[index]
       }))
     };
   }
   
   private calculateCyclomaticComplexity(code: string): number {
     // ç®€åŒ–çš„åœˆå¤æ‚åº¦è®¡ç®—
     const patterns = [
       /\bif\b/g,
       /\belse\b/g,
       /\bwhile\b/g,
       /\bfor\b/g,
       /\bswitch\b/g,
       /\bcase\b/g,
       /\bcatch\b/g,
       /\b&&\b/g,
       /\b\|\|\b/g,
       /\?/g
     ];
     
     let complexity = 1; // åŸºç¡€å¤æ‚åº¦
     
     for (const pattern of patterns) {
       const matches = code.match(pattern);
       if (matches) {
         complexity += matches.length;
       }
     }
     
     return complexity;
   }
   
   private async checkTestCoverage(): Promise<CoverageResult> {
     // è¿è¡Œæµ‹è¯•è¦†ç›–ç‡æ£€æŸ¥
     const { exec } = require('child_process');
     
     return new Promise((resolve, reject) => {
       exec('npm run test:coverage -- --json', (error, stdout, stderr) => {
         if (error) {
           reject(error);
           return;
         }
         
         try {
           const coverage = JSON.parse(stdout);
           resolve({
             percentage: coverage.total.lines.pct,
             lines: coverage.total.lines,
             functions: coverage.total.functions,
             branches: coverage.total.branches,
             statements: coverage.total.statements
           });
         } catch (parseError) {
           reject(parseError);
         }
       });
     });
   }
   
   private calculateOverallScore(report: QualityReport): OverallScore {
     const weights = {
       issues: 0.4,
       complexity: 0.2,
       coverage: 0.2,
       security: 0.1,
       performance: 0.1
     };
     
     // è®¡ç®—é—®é¢˜æ‰£åˆ†
     const issueScore = this.calculateIssueScore(report.issues);
     
     // è®¡ç®—å¤æ‚åº¦å¾—åˆ†
     const complexityScore = Math.max(0, 10 - (report.metrics.complexity - 5));
     
     // è®¡ç®—è¦†ç›–ç‡å¾—åˆ†
     const coverageScore = (report.metrics.testCoverage / 100) * 10;
     
     // è®¡ç®—å®‰å…¨å¾—åˆ†
     const securityIssues = report.issues.filter(i => i.type === 'security');
     const securityScore = Math.max(0, 10 - securityIssues.length * 2);
     
     // è®¡ç®—æ€§èƒ½å¾—åˆ†
     const performanceIssues = report.issues.filter(i => i.type === 'performance');
     const performanceScore = Math.max(0, 10 - performanceIssues.length);
     
     const totalScore = 
       issueScore * weights.issues +
       complexityScore * weights.complexity +
       coverageScore * weights.coverage +
       securityScore * weights.security +
       performanceScore * weights.performance;
     
     return {
       score: Math.round(totalScore * 10) / 10,
       grade: this.scoreToGrade(totalScore)
     };
   }
   
   private calculateIssueScore(issues: QualityIssue[]): number {
     const severityWeights = {
       critical: 3,
       high: 2,
       medium: 1,
       low: 0.5
     };
     
     const totalDeduction = issues.reduce((sum, issue) => {
       return sum + (severityWeights[issue.severity] || 0);
     }, 0);
     
     return Math.max(0, 10 - totalDeduction);
   }
   
   private scoreToGrade(score: number): string {
     if (score >= 9) return 'A+';
     if (score >= 8) return 'A';
     if (score >= 7) return 'B+';
     if (score >= 6) return 'B';
     if (score >= 5) return 'C+';
     if (score >= 4) return 'C';
     if (score >= 3) return 'D';
     return 'F';
   }
   
   private generateRecommendations(report: QualityReport): string[] {
     const recommendations: string[] = [];
     
     // åŸºäºé—®é¢˜ç”Ÿæˆå»ºè®®
     const criticalIssues = report.issues.filter(i => i.severity === 'critical');
     if (criticalIssues.length > 0) {
       recommendations.push('ç«‹å³ä¿®å¤æ‰€æœ‰ä¸¥é‡é—®é¢˜ï¼Œè¿™äº›é—®é¢˜å¯èƒ½å¯¼è‡´ç³»ç»Ÿæ•…éšœ');
     }
     
     // åŸºäºå¤æ‚åº¦ç”Ÿæˆå»ºè®®
     if (report.metrics.complexity > 10) {
       recommendations.push('è€ƒè™‘é‡æ„é«˜å¤æ‚åº¦çš„å‡½æ•°ï¼Œå°†å…¶æ‹†åˆ†ä¸ºæ›´å°çš„ã€å•ä¸€èŒè´£çš„å‡½æ•°');
     }
     
     // åŸºäºæµ‹è¯•è¦†ç›–ç‡ç”Ÿæˆå»ºè®®
     if (report.metrics.testCoverage < 80) {
       recommendations.push('å¢åŠ æµ‹è¯•è¦†ç›–ç‡ï¼Œç›®æ ‡æ˜¯è¾¾åˆ°80%ä»¥ä¸Šçš„ä»£ç è¦†ç›–ç‡');
     }
     
     // åŸºäºå®‰å…¨é—®é¢˜ç”Ÿæˆå»ºè®®
     const securityIssues = report.issues.filter(i => i.type === 'security');
     if (securityIssues.length > 0) {
       recommendations.push('ä¿®å¤æ‰€æœ‰å®‰å…¨æ¼æ´ï¼Œå¹¶è€ƒè™‘å¼•å…¥è‡ªåŠ¨åŒ–å®‰å…¨æ‰«æ');
     }
     
     return recommendations;
   }
   
   private mapSeverity(eslintSeverity: number): 'critical' | 'high' | 'medium' | 'low' {
     switch (eslintSeverity) {
       case 2: return 'high';
       case 1: return 'medium';
       default: return 'low';
     }
   }
 }
 ```

 ---

 ## 11. æ€§èƒ½ä¼˜åŒ–ä¸é”™è¯¯å¤„ç†

 ### 11.1 æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

 **ã€ä»£ç å·¥ç¨‹ã€‘**

 ```typescript
 // æ€§èƒ½ç›‘æ§å’Œä¼˜åŒ–ç®¡ç†å™¨
 class PerformanceOptimizer {
   private metricsCollector: MetricsCollector;
   private cacheManager: CacheManager;
   private connectionPool: ConnectionPool;
   private loadBalancer: LoadBalancer;
   
   constructor() {
     this.metricsCollector = new MetricsCollector();
     this.cacheManager = new CacheManager();
     this.connectionPool = new ConnectionPool();
     this.loadBalancer = new LoadBalancer();
   }
   
   // æ™ºèƒ½ä½“æ€§èƒ½ä¼˜åŒ–
   async optimizeAgentPerformance(agentId: string): Promise<OptimizationResult> {
     const metrics = await this.metricsCollector.getAgentMetrics(agentId);
     const optimizations: Optimization[] = [];
     
     // 1. å†…å­˜ä¼˜åŒ–
     if (metrics.memoryUsage > 0.8) {
       optimizations.push(await this.optimizeMemoryUsage(agentId));
     }
     
     // 2. CPUä¼˜åŒ–
     if (metrics.cpuUsage > 0.7) {
       optimizations.push(await this.optimizeCPUUsage(agentId));
     }
     
     // 3. å“åº”æ—¶é—´ä¼˜åŒ–
     if (metrics.averageResponseTime > 5000) {
       optimizations.push(await this.optimizeResponseTime(agentId));
     }
     
     // 4. å¹¶å‘å¤„ç†ä¼˜åŒ–
     if (metrics.concurrentTasks > metrics.optimalConcurrency) {
       optimizations.push(await this.optimizeConcurrency(agentId));
     }
     
     return {
       agentId,
       optimizations,
       expectedImprovement: this.calculateExpectedImprovement(optimizations),
       implementationPlan: this.createImplementationPlan(optimizations)
     };
   }
   
   // å†…å­˜ä½¿ç”¨ä¼˜åŒ–
   private async optimizeMemoryUsage(agentId: string): Promise<Optimization> {
     const agent = await AgentService.findById(agentId);
     const memoryProfile = await this.analyzeMemoryProfile(agent);
     
     const strategies: OptimizationStrategy[] = [];
     
     // å¯¹è±¡æ± ä¼˜åŒ–
     if (memoryProfile.objectCreationRate > 1000) {
       strategies.push({
         type: 'object_pooling',
         description: 'å®ç°å¯¹è±¡æ± ä»¥å‡å°‘GCå‹åŠ›',
         expectedGain: 0.3,
         implementation: `
           class ObjectPool<T> {
             private pool: T[] = [];
             private createFn: () => T;
             private resetFn: (obj: T) => void;
             
             constructor(createFn: () => T, resetFn: (obj: T) => void, initialSize = 10) {
               this.createFn = createFn;
               this.resetFn = resetFn;
               
               // é¢„å¡«å……å¯¹è±¡æ± 
               for (let i = 0; i < initialSize; i++) {
                 this.pool.push(this.createFn());
               }
             }
             
             acquire(): T {
               return this.pool.pop() || this.createFn();
             }
             
             release(obj: T): void {
               this.resetFn(obj);
               this.pool.push(obj);
             }
           }
         `
       });
     }
     
     // å†…å­˜æ³„æ¼æ£€æµ‹å’Œä¿®å¤
     if (memoryProfile.potentialLeaks.length > 0) {
       strategies.push({
         type: 'memory_leak_fix',
         description: 'ä¿®å¤æ£€æµ‹åˆ°çš„å†…å­˜æ³„æ¼',
         expectedGain: 0.4,
         implementation: `
           // è‡ªåŠ¨æ¸…ç†äº‹ä»¶ç›‘å¬å™¨
           class EventManager {
             private listeners = new Map<string, Set<Function>>();
             
             addEventListener(event: string, listener: Function): () => void {
               if (!this.listeners.has(event)) {
                 this.listeners.set(event, new Set());
               }
               this.listeners.get(event)!.add(listener);
               
               // è¿”å›æ¸…ç†å‡½æ•°
               return () => {
                 this.listeners.get(event)?.delete(listener);
               };
             }
             
             cleanup(): void {
               this.listeners.clear();
             }
           }
         `
       });
     }
     
     return {
       type: 'memory',
       strategies,
       priority: 'high',
       estimatedImpact: strategies.reduce((sum, s) => sum + s.expectedGain, 0)
     };
   }
   
   // CPUä½¿ç”¨ä¼˜åŒ–
   private async optimizeCPUUsage(agentId: string): Promise<Optimization> {
     const agent = await AgentService.findById(agentId);
     const cpuProfile = await this.analyzeCPUProfile(agent);
     
     const strategies: OptimizationStrategy[] = [];
     
     // ç®—æ³•ä¼˜åŒ–
     if (cpuProfile.hotspots.length > 0) {
       strategies.push({
         type: 'algorithm_optimization',
         description: 'ä¼˜åŒ–CPUå¯†é›†å‹ç®—æ³•',
         expectedGain: 0.5,
         implementation: `
           // ä½¿ç”¨Workerçº¿ç¨‹å¤„ç†CPUå¯†é›†å‹ä»»åŠ¡
           class CPUIntensiveTaskProcessor {
             private workerPool: Worker[];
             private taskQueue: Task[] = [];
             private activeWorkers = 0;
             
             constructor(workerCount = os.cpus().length) {
               this.workerPool = Array.from({ length: workerCount }, () => 
                 new Worker('./cpu-worker.js')
               );
             }
             
             async processTask(task: CPUIntensiveTask): Promise<any> {
               return new Promise((resolve, reject) => {
                 const worker = this.getAvailableWorker();
                 
                 worker.postMessage({ task });
                 worker.once('message', (result) => {
                   this.releaseWorker(worker);
                   resolve(result);
                 });
                 worker.once('error', (error) => {
                   this.releaseWorker(worker);
                   reject(error);
                 });
               });
             }
             
             private getAvailableWorker(): Worker {
               // å®ç°å·¥ä½œçº¿ç¨‹æ± é€»è¾‘
               return this.workerPool[this.activeWorkers++ % this.workerPool.length];
             }
             
             private releaseWorker(worker: Worker): void {
               this.activeWorkers--;
             }
           }
         `
       });
     }
     
     // ç¼“å­˜ä¼˜åŒ–
     strategies.push({
       type: 'intelligent_caching',
       description: 'å®ç°æ™ºèƒ½ç¼“å­˜ç­–ç•¥',
       expectedGain: 0.3,
       implementation: `
         class IntelligentCache {
           private cache = new Map<string, CacheEntry>();
           private accessPattern = new Map<string, AccessStats>();
           
           async get<T>(key: string, factory: () => Promise<T>): Promise<T> {
             // æ›´æ–°è®¿é—®ç»Ÿè®¡
             this.updateAccessStats(key);
             
             const entry = this.cache.get(key);
             if (entry && !this.isExpired(entry)) {
               return entry.value;
             }
             
             // ç¼“å­˜æœªå‘½ä¸­ï¼Œè®¡ç®—æ–°å€¼
             const value = await factory();
             const ttl = this.calculateOptimalTTL(key);
             
             this.cache.set(key, {
               value,
               timestamp: Date.now(),
               ttl,
               accessCount: 1
             });
             
             return value;
           }
           
           private calculateOptimalTTL(key: string): number {
             const stats = this.accessPattern.get(key);
             if (!stats) return 300000; // é»˜è®¤5åˆ†é’Ÿ
             
             // åŸºäºè®¿é—®é¢‘ç‡åŠ¨æ€è°ƒæ•´TTL
             const frequency = stats.accessCount / stats.timeSpan;
             return Math.max(60000, Math.min(3600000, 300000 / frequency));
           }
         }
       `
     });
     
     return {
       type: 'cpu',
       strategies,
       priority: 'high',
       estimatedImpact: strategies.reduce((sum, s) => sum + s.expectedGain, 0)
     };
   }
   
   // å“åº”æ—¶é—´ä¼˜åŒ–
   private async optimizeResponseTime(agentId: string): Promise<Optimization> {
     const strategies: OptimizationStrategy[] = [];
     
     // å¼‚æ­¥å¤„ç†ä¼˜åŒ–
     strategies.push({
       type: 'async_optimization',
       description: 'ä¼˜åŒ–å¼‚æ­¥å¤„ç†æµç¨‹',
       expectedGain: 0.4,
       implementation: `
         class AsyncTaskProcessor {
           private concurrencyLimit = 10;
           private activePromises = new Set<Promise<any>>();
           
           async processWithConcurrencyLimit<T>(
             tasks: (() => Promise<T>)[]
           ): Promise<T[]> {
             const results: T[] = [];
             const semaphore = new Semaphore(this.concurrencyLimit);
             
             const promises = tasks.map(async (task, index) => {
               await semaphore.acquire();
               try {
                 const result = await task();
                 results[index] = result;
               } finally {
                 semaphore.release();
               }
             });
             
             await Promise.all(promises);
             return results;
           }
         }
         
         class Semaphore {
           private permits: number;
           private waitQueue: (() => void)[] = [];
           
           constructor(permits: number) {
             this.permits = permits;
           }
           
           async acquire(): Promise<void> {
             if (this.permits > 0) {
               this.permits--;
               return;
             }
             
             return new Promise(resolve => {
               this.waitQueue.push(resolve);
             });
           }
           
           release(): void {
             this.permits++;
             const next = this.waitQueue.shift();
             if (next) {
               this.permits--;
               next();
             }
           }
         }
       `
     });
     
     return {
       type: 'response_time',
       strategies,
       priority: 'medium',
       estimatedImpact: strategies.reduce((sum, s) => sum + s.expectedGain, 0)
     };
   }
 }
 ```

 ### 11.2 é”™è¯¯å¤„ç†ä¸æ¢å¤æœºåˆ¶

 **ã€ä»£ç å·¥ç¨‹ã€‘**

 ```typescript
 // å…¨å±€é”™è¯¯å¤„ç†å™¨
 class GlobalErrorHandler {
   private errorClassifiers: ErrorClassifier[];
   private recoveryStrategies: Map<string, RecoveryStrategy>;
   private circuitBreakers: Map<string, CircuitBreaker>;
   
   constructor() {
     this.errorClassifiers = [
       new NetworkErrorClassifier(),
       new DatabaseErrorClassifier(),
       new ValidationErrorClassifier(),
       new BusinessLogicErrorClassifier()
     ];
     
     this.recoveryStrategies = new Map();
     this.circuitBreakers = new Map();
     
     this.initializeRecoveryStrategies();
   }
   
   // å¤„ç†é”™è¯¯
   async handleError(error: Error, context: ErrorContext): Promise<ErrorHandlingResult> {
     try {
       // 1. é”™è¯¯åˆ†ç±»
       const classification = await this.classifyError(error, context);
       
       // 2. è®°å½•é”™è¯¯
       await this.logError(error, classification, context);
       
       // 3. é€‰æ‹©æ¢å¤ç­–ç•¥
       const strategy = this.selectRecoveryStrategy(classification);
       
       // 4. æ‰§è¡Œæ¢å¤
       const recoveryResult = await this.executeRecovery(strategy, error, context);
       
       // 5. æ›´æ–°ç†”æ–­å™¨çŠ¶æ€
       this.updateCircuitBreaker(classification.category, recoveryResult.success);
       
       return {
         handled: true,
         recovered: recoveryResult.success,
         strategy: strategy.name,
         retryable: recoveryResult.retryable,
         nextAction: recoveryResult.nextAction
       };
     } catch (handlingError) {
       // é”™è¯¯å¤„ç†æœ¬èº«å¤±è´¥
       await this.logCriticalError(handlingError, error, context);
       return {
         handled: false,
         recovered: false,
         strategy: 'none',
         retryable: false,
         nextAction: 'escalate'
       };
     }
   }
   
   // é”™è¯¯åˆ†ç±»
   private async classifyError(error: Error, context: ErrorContext): Promise<ErrorClassification> {
     for (const classifier of this.errorClassifiers) {
       const classification = await classifier.classify(error, context);
       if (classification.confidence > 0.8) {
         return classification;
       }
     }
     
     // é»˜è®¤åˆ†ç±»
     return {
       category: 'unknown',
       severity: 'medium',
       confidence: 0.5,
       recoverable: false,
       retryable: false
     };
   }
   
   // é€‰æ‹©æ¢å¤ç­–ç•¥
   private selectRecoveryStrategy(classification: ErrorClassification): RecoveryStrategy {
     const strategyKey = `${classification.category}_${classification.severity}`;
     return this.recoveryStrategies.get(strategyKey) || 
            this.recoveryStrategies.get('default')!;
   }
   
   // æ‰§è¡Œæ¢å¤ç­–ç•¥
   private async executeRecovery(
     strategy: RecoveryStrategy, 
     error: Error, 
     context: ErrorContext
   ): Promise<RecoveryResult> {
     const startTime = Date.now();
     
     try {
       const result = await strategy.execute(error, context);
       
       // è®°å½•æ¢å¤æˆåŠŸ
       await this.logRecoveryAttempt({
         strategy: strategy.name,
         success: result.success,
         duration: Date.now() - startTime,
         error: error.message,
         context
       });
       
       return result;
     } catch (recoveryError) {
       // æ¢å¤ç­–ç•¥æ‰§è¡Œå¤±è´¥
       await this.logRecoveryFailure({
         strategy: strategy.name,
         originalError: error,
         recoveryError,
         context
       });
       
       return {
         success: false,
         retryable: false,
         nextAction: 'escalate'
       };
     }
   }
   
   // åˆå§‹åŒ–æ¢å¤ç­–ç•¥
   private initializeRecoveryStrategies(): void {
     // ç½‘ç»œé”™è¯¯æ¢å¤ç­–ç•¥
     this.recoveryStrategies.set('network_high', new ExponentialBackoffRetryStrategy({
       maxRetries: 5,
       baseDelay: 1000,
       maxDelay: 30000,
       backoffFactor: 2
     }));
     
     // æ•°æ®åº“é”™è¯¯æ¢å¤ç­–ç•¥
     this.recoveryStrategies.set('database_high', new DatabaseRecoveryStrategy({
       connectionPoolReset: true,
       transactionRollback: true,
       maxRetries: 3
     }));
     
     // éªŒè¯é”™è¯¯æ¢å¤ç­–ç•¥
     this.recoveryStrategies.set('validation_medium', new ValidationErrorRecoveryStrategy({
       sanitizeInput: true,
       useDefaults: true
     }));
     
     // ä¸šåŠ¡é€»è¾‘é”™è¯¯æ¢å¤ç­–ç•¥
     this.recoveryStrategies.set('business_medium', new BusinessLogicRecoveryStrategy({
       fallbackToDefault: true,
       notifyUser: true
     }));
     
     // é»˜è®¤æ¢å¤ç­–ç•¥
     this.recoveryStrategies.set('default', new DefaultRecoveryStrategy());
   }
 }
 
 // æŒ‡æ•°é€€é¿é‡è¯•ç­–ç•¥
 class ExponentialBackoffRetryStrategy implements RecoveryStrategy {
   name = 'exponential_backoff_retry';
   
   constructor(private config: RetryConfig) {}
   
   async execute(error: Error, context: ErrorContext): Promise<RecoveryResult> {
     let lastError = error;
     
     for (let attempt = 1; attempt <= this.config.maxRetries; attempt++) {
       try {
         // è®¡ç®—å»¶è¿Ÿæ—¶é—´
         const delay = Math.min(
           this.config.baseDelay * Math.pow(this.config.backoffFactor, attempt - 1),
           this.config.maxDelay
         );
         
         // ç­‰å¾…
         await this.sleep(delay);
         
         // é‡è¯•åŸå§‹æ“ä½œ
         await this.retryOriginalOperation(context);
         
         return {
           success: true,
           retryable: false,
           nextAction: 'continue',
           attemptsUsed: attempt
         };
       } catch (retryError) {
         lastError = retryError;
         
         // è®°å½•é‡è¯•å¤±è´¥
         await this.logRetryAttempt(attempt, retryError, context);
       }
     }
     
     return {
       success: false,
       retryable: false,
       nextAction: 'escalate',
       attemptsUsed: this.config.maxRetries,
       finalError: lastError
     };
   }
   
   private async retryOriginalOperation(context: ErrorContext): Promise<void> {
     // æ ¹æ®ä¸Šä¸‹æ–‡é‡æ–°æ‰§è¡ŒåŸå§‹æ“ä½œ
     if (context.operation) {
       await context.operation();
     } else {
       throw new Error('No operation to retry');
     }
   }
   
   private sleep(ms: number): Promise<void> {
     return new Promise(resolve => setTimeout(resolve, ms));
   }
   
   private async logRetryAttempt(
     attempt: number, 
     error: Error, 
     context: ErrorContext
   ): Promise<void> {
     await Logger.warn('Retry attempt failed', {
       attempt,
       error: error.message,
       context: {
         agentId: context.agentId,
         taskId: context.taskId,
         operation: context.operationName
       }
     });
   }
 }
 
 // ç†”æ–­å™¨å®ç°
 class CircuitBreaker {
   private state: 'closed' | 'open' | 'half-open' = 'closed';
   private failureCount = 0;
   private lastFailureTime = 0;
   private successCount = 0;
   
   constructor(private config: CircuitBreakerConfig) {}
   
   async execute<T>(operation: () => Promise<T>): Promise<T> {
     if (this.state === 'open') {
       if (this.shouldAttemptReset()) {
         this.state = 'half-open';
         this.successCount = 0;
       } else {
         throw new Error('Circuit breaker is open');
       }
     }
     
     try {
       const result = await operation();
       this.onSuccess();
       return result;
     } catch (error) {
       this.onFailure();
       throw error;
     }
   }
   
   private onSuccess(): void {
     this.failureCount = 0;
     
     if (this.state === 'half-open') {
       this.successCount++;
       if (this.successCount >= this.config.successThreshold) {
         this.state = 'closed';
       }
     }
   }
   
   private onFailure(): void {
     this.failureCount++;
     this.lastFailureTime = Date.now();
     
     if (this.failureCount >= this.config.failureThreshold) {
       this.state = 'open';
     }
   }
   
   private shouldAttemptReset(): boolean {
     return Date.now() - this.lastFailureTime >= this.config.timeout;
   }
   
   getState(): string {
     return this.state;
   }
 }
 ```

 ---

 ## 12. éƒ¨ç½²è¿ç»´ä¸ç›‘æ§æ–¹æ¡ˆ

 ### 12.1 å®¹å™¨åŒ–éƒ¨ç½²æ¶æ„

 **ã€ä»£ç å·¥ç¨‹ã€‘**

 ```dockerfile
 # å¤šé˜¶æ®µæ„å»º Dockerfile
 FROM node:18-alpine AS builder
 
 WORKDIR /app
 COPY package*.json ./
 RUN npm ci --only=production
 
 COPY . .
 RUN npm run build
 
 # ç”Ÿäº§ç¯å¢ƒé•œåƒ
 FROM node:18-alpine AS production
 
 # åˆ›å»ºérootç”¨æˆ·
 RUN addgroup -g 1001 -S nodejs
 RUN adduser -S agent -u 1001
 
 WORKDIR /app
 
 # å¤åˆ¶æ„å»ºäº§ç‰©
 COPY --from=builder --chown=agent:nodejs /app/dist ./dist
 COPY --from=builder --chown=agent:nodejs /app/node_modules ./node_modules
 COPY --from=builder --chown=agent:nodejs /app/package.json ./package.json
 
 # å¥åº·æ£€æŸ¥
 HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
   CMD node dist/health-check.js
 
 USER agent
 
 EXPOSE 3000
 
 CMD ["node", "dist/server.js"]
 ```

 **Docker Compose é…ç½®ï¼š**

 ```yaml
 version: '3.8'
 
 services:
   # æ™ºèƒ½ä½“è°ƒåº¦å™¨
   agent-scheduler:
     build:
       context: .
       target: production
     ports:
       - "3000:3000"
     environment:
       - NODE_ENV=production
       - REDIS_URL=redis://redis:6379
       - POSTGRES_URL=postgresql://postgres:password@postgres:5432/agents
       - RABBITMQ_URL=amqp://rabbitmq:5672
     depends_on:
       - redis
       - postgres
       - rabbitmq
     restart: unless-stopped
     deploy:
       replicas: 3
       resources:
         limits:
           cpus: '1.0'
           memory: 1G
         reservations:
           cpus: '0.5'
           memory: 512M
   
   # æ™ºèƒ½ä½“å·¥ä½œèŠ‚ç‚¹
   agent-worker:
     build:
       context: .
       target: production
     environment:
       - NODE_ENV=production
       - WORKER_TYPE=agent
       - REDIS_URL=redis://redis:6379
       - POSTGRES_URL=postgresql://postgres:password@postgres:5432/agents
     depends_on:
       - redis
       - postgres
       - rabbitmq
     restart: unless-stopped
     deploy:
       replicas: 5
       resources:
         limits:
           cpus: '2.0'
           memory: 2G
   
   # Redis ç¼“å­˜
   redis:
     image: redis:7-alpine
     ports:
       - "6379:6379"
     volumes:
       - redis_data:/data
     command: redis-server --appendonly yes
     restart: unless-stopped
   
   # PostgreSQL æ•°æ®åº“
   postgres:
     image: postgres:15-alpine
     ports:
       - "5432:5432"
     environment:
       - POSTGRES_DB=agents
       - POSTGRES_USER=postgres
       - POSTGRES_PASSWORD=password
     volumes:
       - postgres_data:/var/lib/postgresql/data
       - ./init.sql:/docker-entrypoint-initdb.d/init.sql
     restart: unless-stopped
   
   # RabbitMQ æ¶ˆæ¯é˜Ÿåˆ—
   rabbitmq:
     image: rabbitmq:3-management-alpine
     ports:
       - "5672:5672"
       - "15672:15672"
     environment:
       - RABBITMQ_DEFAULT_USER=admin
       - RABBITMQ_DEFAULT_PASS=password
     volumes:
       - rabbitmq_data:/var/lib/rabbitmq
     restart: unless-stopped
   
   # Prometheus ç›‘æ§
   prometheus:
     image: prom/prometheus:latest
     ports:
       - "9090:9090"
     volumes:
       - ./prometheus.yml:/etc/prometheus/prometheus.yml
       - prometheus_data:/prometheus
     command:
       - '--config.file=/etc/prometheus/prometheus.yml'
       - '--storage.tsdb.path=/prometheus'
       - '--web.console.libraries=/etc/prometheus/console_libraries'
       - '--web.console.templates=/etc/prometheus/consoles'
     restart: unless-stopped
   
   # Grafana å¯è§†åŒ–
   grafana:
     image: grafana/grafana:latest
     ports:
       - "3001:3000"
     environment:
       - GF_SECURITY_ADMIN_PASSWORD=admin
     volumes:
       - grafana_data:/var/lib/grafana
       - ./grafana/dashboards:/etc/grafana/provisioning/dashboards
       - ./grafana/datasources:/etc/grafana/provisioning/datasources
     restart: unless-stopped
 
 volumes:
   redis_data:
   postgres_data:
   rabbitmq_data:
   prometheus_data:
   grafana_data:
 ```

 ### 12.2 Kubernetes éƒ¨ç½²é…ç½®

 **ã€ä»£ç å·¥ç¨‹ã€‘**

 ```yaml
 # agent-scheduler-deployment.yaml
 apiVersion: apps/v1
 kind: Deployment
 metadata:
   name: agent-scheduler
   labels:
     app: agent-scheduler
 spec:
   replicas: 3
   selector:
     matchLabels:
       app: agent-scheduler
   template:
     metadata:
       labels:
         app: agent-scheduler
     spec:
       containers:
       - name: agent-scheduler
         image: agent-system:latest
         ports:
         - containerPort: 3000
         env:
         - name: NODE_ENV
           value: "production"
         - name: REDIS_URL
           valueFrom:
             secretKeyRef:
               name: redis-secret
               key: url
         - name: POSTGRES_URL
           valueFrom:
             secretKeyRef:
               name: postgres-secret
               key: url
         resources:
           requests:
             memory: "512Mi"
             cpu: "500m"
           limits:
             memory: "1Gi"
             cpu: "1000m"
         livenessProbe:
           httpGet:
             path: /health
             port: 3000
           initialDelaySeconds: 30
           periodSeconds: 10
         readinessProbe:
           httpGet:
             path: /ready
             port: 3000
           initialDelaySeconds: 5
           periodSeconds: 5
 ---
 # agent-scheduler-service.yaml
 apiVersion: v1
 kind: Service
 metadata:
   name: agent-scheduler-service
 spec:
   selector:
     app: agent-scheduler
   ports:
   - protocol: TCP
     port: 80
     targetPort: 3000
   type: LoadBalancer
 ---
 # agent-scheduler-hpa.yaml
 apiVersion: autoscaling/v2
 kind: HorizontalPodAutoscaler
 metadata:
   name: agent-scheduler-hpa
 spec:
   scaleTargetRef:
     apiVersion: apps/v1
     kind: Deployment
     name: agent-scheduler
   minReplicas: 3
   maxReplicas: 10
   metrics:
   - type: Resource
     resource:
       name: cpu
       target:
         type: Utilization
         averageUtilization: 70
   - type: Resource
     resource:
       name: memory
       target:
         type: Utilization
         averageUtilization: 80
 ```

 ### 12.3 ç›‘æ§ä¸å‘Šè­¦ç³»ç»Ÿ

 **ã€ä»£ç å·¥ç¨‹ã€‘**

 ```typescript
 // ç›‘æ§æŒ‡æ ‡æ”¶é›†å™¨
 class MetricsCollector {
   private prometheus: PrometheusRegistry;
   private counters: Map<string, Counter>;
   private gauges: Map<string, Gauge>;
   private histograms: Map<string, Histogram>;
   
   constructor() {
     this.prometheus = new PrometheusRegistry();
     this.counters = new Map();
     this.gauges = new Map();
     this.histograms = new Map();
     
     this.initializeMetrics();
   }
   
   // åˆå§‹åŒ–ç›‘æ§æŒ‡æ ‡
   private initializeMetrics(): void {
     // ä»»åŠ¡ç›¸å…³æŒ‡æ ‡
     this.counters.set('tasks_total', new Counter({
       name: 'agent_tasks_total',
       help: 'Total number of tasks processed',
       labelNames: ['status', 'agent_type', 'priority']
     }));
     
     this.counters.set('tasks_failed', new Counter({
       name: 'agent_tasks_failed_total',
       help: 'Total number of failed tasks',
       labelNames: ['error_type', 'agent_id']
     }));
     
     // æ™ºèƒ½ä½“ç›¸å…³æŒ‡æ ‡
     this.gauges.set('agents_active', new Gauge({
       name: 'agent_active_count',
       help: 'Number of active agents',
       labelNames: ['agent_type', 'status']
     }));
     
     this.gauges.set('agent_memory_usage', new Gauge({
       name: 'agent_memory_usage_bytes',
       help: 'Memory usage by agent',
       labelNames: ['agent_id', 'agent_type']
     }));
     
     // æ€§èƒ½ç›¸å…³æŒ‡æ ‡
     this.histograms.set('task_duration', new Histogram({
       name: 'agent_task_duration_seconds',
       help: 'Task execution duration',
       labelNames: ['agent_type', 'task_type'],
       buckets: [0.1, 0.5, 1, 2, 5, 10, 30, 60]
     }));
     
     this.histograms.set('response_time', new Histogram({
       name: 'agent_response_time_seconds',
       help: 'Agent response time',
       labelNames: ['agent_id', 'operation'],
       buckets: [0.01, 0.05, 0.1, 0.5, 1, 2, 5]
     }));
     
     // æ³¨å†Œæ‰€æœ‰æŒ‡æ ‡
     [...this.counters.values(), ...this.gauges.values(), ...this.histograms.values()]
       .forEach(metric => this.prometheus.register(metric));
   }
   
   // è®°å½•ä»»åŠ¡å®Œæˆ
   recordTaskCompletion(agentType: string, taskType: string, duration: number, status: string): void {
     this.counters.get('tasks_total')?.inc({ status, agent_type: agentType, priority: 'normal' });
     this.histograms.get('task_duration')?.observe({ agent_type: agentType, task_type: taskType }, duration);
   }
   
   // è®°å½•ä»»åŠ¡å¤±è´¥
   recordTaskFailure(agentId: string, errorType: string): void {
     this.counters.get('tasks_failed')?.inc({ error_type: errorType, agent_id: agentId });
   }
   
   // æ›´æ–°æ™ºèƒ½ä½“çŠ¶æ€
   updateAgentStatus(agentType: string, status: string, count: number): void {
     this.gauges.get('agents_active')?.set({ agent_type: agentType, status }, count);
   }
   
   // è®°å½•å†…å­˜ä½¿ç”¨
   recordMemoryUsage(agentId: string, agentType: string, memoryBytes: number): void {
     this.gauges.get('agent_memory_usage')?.set({ agent_id: agentId, agent_type: agentType }, memoryBytes);
   }
   
   // è®°å½•å“åº”æ—¶é—´
   recordResponseTime(agentId: string, operation: string, duration: number): void {
     this.histograms.get('response_time')?.observe({ agent_id: agentId, operation }, duration);
   }
   
   // è·å–æŒ‡æ ‡æ•°æ®
   async getMetrics(): Promise<string> {
     return await this.prometheus.metrics();
   }
 }
 
 // å‘Šè­¦ç®¡ç†å™¨
 class AlertManager {
   private alertRules: AlertRule[];
   private notificationChannels: NotificationChannel[];
   private activeAlerts: Map<string, Alert>;
   
   constructor() {
     this.alertRules = [];
     this.notificationChannels = [];
     this.activeAlerts = new Map();
     
     this.initializeAlertRules();
     this.initializeNotificationChannels();
   }
   
   // åˆå§‹åŒ–å‘Šè­¦è§„åˆ™
   private initializeAlertRules(): void {
     // é«˜é”™è¯¯ç‡å‘Šè­¦
     this.alertRules.push({
       name: 'high_error_rate',
       condition: 'rate(agent_tasks_failed_total[5m]) > 0.1',
       severity: 'critical',
       description: 'ä»»åŠ¡å¤±è´¥ç‡è¶…è¿‡10%',
       duration: '2m',
       labels: { team: 'platform', service: 'agent-system' }
     });
     
     // å†…å­˜ä½¿ç”¨è¿‡é«˜å‘Šè­¦
     this.alertRules.push({
       name: 'high_memory_usage',
       condition: 'agent_memory_usage_bytes > 1073741824', // 1GB
       severity: 'warning',
       description: 'æ™ºèƒ½ä½“å†…å­˜ä½¿ç”¨è¶…è¿‡1GB',
       duration: '5m',
       labels: { team: 'platform', service: 'agent-system' }
     });
     
     // å“åº”æ—¶é—´è¿‡é•¿å‘Šè­¦
     this.alertRules.push({
       name: 'slow_response_time',
       condition: 'histogram_quantile(0.95, rate(agent_response_time_seconds_bucket[5m])) > 5',
       severity: 'warning',
       description: '95%çš„å“åº”æ—¶é—´è¶…è¿‡5ç§’',
       duration: '3m',
       labels: { team: 'platform', service: 'agent-system' }
     });
     
     // æ™ºèƒ½ä½“ç¦»çº¿å‘Šè­¦
     this.alertRules.push({
       name: 'agent_offline',
       condition: 'agent_active_count{status="online"} == 0',
       severity: 'critical',
       description: 'æ²¡æœ‰åœ¨çº¿çš„æ™ºèƒ½ä½“',
       duration: '1m',
       labels: { team: 'platform', service: 'agent-system' }
     });
   }
   
   // åˆå§‹åŒ–é€šçŸ¥æ¸ é“
   private initializeNotificationChannels(): void {
     // é‚®ä»¶é€šçŸ¥
     this.notificationChannels.push(new EmailNotificationChannel({
       smtpHost: process.env.SMTP_HOST!,
       smtpPort: parseInt(process.env.SMTP_PORT!),
       username: process.env.SMTP_USERNAME!,
       password: process.env.SMTP_PASSWORD!,
       recipients: ['ops@company.com', 'dev@company.com']
     }));
     
     // Slacké€šçŸ¥
     this.notificationChannels.push(new SlackNotificationChannel({
       webhookUrl: process.env.SLACK_WEBHOOK_URL!,
       channel: '#alerts',
       username: 'AlertBot'
     }));
     
     // é’‰é’‰é€šçŸ¥
     this.notificationChannels.push(new DingTalkNotificationChannel({
       webhookUrl: process.env.DINGTALK_WEBHOOK_URL!,
       secret: process.env.DINGTALK_SECRET!
     }));
   }
   
   // æ£€æŸ¥å‘Šè­¦æ¡ä»¶
   async checkAlerts(): Promise<void> {
     for (const rule of this.alertRules) {
       try {
         const isTriggered = await this.evaluateAlertCondition(rule);
         
         if (isTriggered) {
           await this.handleTriggeredAlert(rule);
         } else {
           await this.handleResolvedAlert(rule);
         }
       } catch (error) {
         console.error(`Error checking alert rule ${rule.name}:`, error);
       }
     }
   }
   
   // è¯„ä¼°å‘Šè­¦æ¡ä»¶
   private async evaluateAlertCondition(rule: AlertRule): Promise<boolean> {
     // è¿™é‡Œåº”è¯¥æŸ¥è¯¢Prometheusæˆ–å…¶ä»–ç›‘æ§ç³»ç»Ÿ
     // ç®€åŒ–å®ç°ï¼Œå®é™…åº”è¯¥ä½¿ç”¨PromQLæŸ¥è¯¢
     const prometheusClient = new PrometheusClient();
     const result = await prometheusClient.query(rule.condition);
     
     return result.data.result.length > 0 && 
            result.data.result.some((series: any) => parseFloat(series.value[1]) > 0);
   }
   
   // å¤„ç†è§¦å‘çš„å‘Šè­¦
   private async handleTriggeredAlert(rule: AlertRule): Promise<void> {
     const alertId = `${rule.name}_${Date.now()}`;
     
     if (!this.activeAlerts.has(rule.name)) {
       const alert: Alert = {
         id: alertId,
         rule: rule.name,
         severity: rule.severity,
         description: rule.description,
         labels: rule.labels,
         triggeredAt: new Date(),
         status: 'firing'
       };
       
       this.activeAlerts.set(rule.name, alert);
       await this.sendNotification(alert);
       
       // è®°å½•å‘Šè­¦æ—¥å¿—
       console.warn(`Alert triggered: ${rule.name}`, {
         severity: rule.severity,
         description: rule.description,
         labels: rule.labels
       });
     }
   }
   
   // å¤„ç†å·²è§£å†³çš„å‘Šè­¦
   private async handleResolvedAlert(rule: AlertRule): Promise<void> {
     const activeAlert = this.activeAlerts.get(rule.name);
     
     if (activeAlert) {
       activeAlert.status = 'resolved';
       activeAlert.resolvedAt = new Date();
       
       await this.sendNotification(activeAlert);
       this.activeAlerts.delete(rule.name);
       
       // è®°å½•å‘Šè­¦è§£å†³æ—¥å¿—
       console.info(`Alert resolved: ${rule.name}`, {
         duration: activeAlert.resolvedAt.getTime() - activeAlert.triggeredAt.getTime()
       });
     }
   }
   
   // å‘é€é€šçŸ¥
   private async sendNotification(alert: Alert): Promise<void> {
     const promises = this.notificationChannels.map(async (channel) => {
       try {
         await channel.send(alert);
       } catch (error) {
         console.error(`Failed to send notification via ${channel.constructor.name}:`, error);
       }
     });
     
     await Promise.allSettled(promises);
   }
   
   // è·å–æ´»è·ƒå‘Šè­¦
   getActiveAlerts(): Alert[] {
     return Array.from(this.activeAlerts.values());
   }
 }
 ```

 ### 12.4 æ—¥å¿—ç®¡ç†ç³»ç»Ÿ

 **ã€ä»£ç å·¥ç¨‹ã€‘**

 ```typescript
 // ç»“æ„åŒ–æ—¥å¿—ç®¡ç†å™¨
 class StructuredLogger {
   private winston: Winston.Logger;
   private logstashTransport?: Winston.Transport;
   private fileTransport: Winston.Transport;
   private consoleTransport: Winston.Transport;
   
   constructor() {
     this.initializeTransports();
     this.winston = Winston.createLogger({
       level: process.env.LOG_LEVEL || 'info',
       format: Winston.format.combine(
         Winston.format.timestamp(),
         Winston.format.errors({ stack: true }),
         Winston.format.json(),
         Winston.format.printf(this.customFormat)
       ),
       transports: [
         this.consoleTransport,
         this.fileTransport,
         ...(this.logstashTransport ? [this.logstashTransport] : [])
       ]
     });
   }
   
   private initializeTransports(): void {
     // æ§åˆ¶å°è¾“å‡º
     this.consoleTransport = new Winston.transports.Console({
       format: Winston.format.combine(
         Winston.format.colorize(),
         Winston.format.simple()
       )
     });
     
     // æ–‡ä»¶è¾“å‡º
     this.fileTransport = new Winston.transports.File({
       filename: 'logs/agent-system.log',
       maxsize: 10 * 1024 * 1024, // 10MB
       maxFiles: 5,
       tailable: true
     });
     
     // Logstashè¾“å‡ºï¼ˆå¦‚æœé…ç½®äº†ï¼‰
     if (process.env.LOGSTASH_HOST) {
       this.logstashTransport = new Winston.transports.Http({
         host: process.env.LOGSTASH_HOST,
         port: parseInt(process.env.LOGSTASH_PORT || '5000'),
         path: '/logstash'
       });
     }
   }
   
   private customFormat = (info: any) => {
     const { timestamp, level, message, ...meta } = info;
     
     return JSON.stringify({
       '@timestamp': timestamp,
       level,
       message,
       service: 'agent-system',
       version: process.env.APP_VERSION || '1.0.0',
       environment: process.env.NODE_ENV || 'development',
       ...meta
     });
   };
   
   // è®°å½•æ™ºèƒ½ä½“æ“ä½œæ—¥å¿—
   logAgentOperation(agentId: string, operation: string, details: any, duration?: number): void {
     this.winston.info('Agent operation', {
       agentId,
       operation,
       details,
       duration,
       category: 'agent_operation'
     });
   }
   
   // è®°å½•ä»»åŠ¡æ‰§è¡Œæ—¥å¿—
   logTaskExecution(taskId: string, agentId: string, status: string, result?: any, error?: Error): void {
     const logData = {
       taskId,
       agentId,
       status,
       category: 'task_execution'
     };
     
     if (result) {
       (logData as any).result = result;
     }
     
     if (error) {
       (logData as any).error = {
         message: error.message,
         stack: error.stack,
         name: error.name
       };
       this.winston.error('Task execution failed', logData);
     } else {
       this.winston.info('Task execution completed', logData);
     }
   }
   
   // è®°å½•æ€§èƒ½æŒ‡æ ‡æ—¥å¿—
   logPerformanceMetrics(agentId: string, metrics: PerformanceMetrics): void {
     this.winston.info('Performance metrics', {
       agentId,
       metrics,
       category: 'performance'
     });
   }
   
   // è®°å½•å®‰å…¨äº‹ä»¶æ—¥å¿—
   logSecurityEvent(event: string, details: any, severity: 'low' | 'medium' | 'high' | 'critical'): void {
     this.winston.warn('Security event', {
       event,
       details,
       severity,
       category: 'security'
     });
   }
   
   // è®°å½•ç³»ç»Ÿé”™è¯¯æ—¥å¿—
   logSystemError(error: Error, context?: any): void {
     this.winston.error('System error', {
       error: {
         message: error.message,
         stack: error.stack,
         name: error.name
       },
       context,
       category: 'system_error'
     });
   }
   
   // åˆ›å»ºå­æ—¥å¿—å™¨ï¼ˆå¸¦ä¸Šä¸‹æ–‡ï¼‰
   createChildLogger(context: any): ChildLogger {
     return new ChildLogger(this.winston, context);
   }
 }
 
 // å­æ—¥å¿—å™¨ï¼ˆå¸¦ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼‰
 class ChildLogger {
   constructor(
     private logger: Winston.Logger,
     private context: any
   ) {}
   
   info(message: string, meta?: any): void {
     this.logger.info(message, { ...this.context, ...meta });
   }
   
   warn(message: string, meta?: any): void {
     this.logger.warn(message, { ...this.context, ...meta });
   }
   
   error(message: string, meta?: any): void {
     this.logger.error(message, { ...this.context, ...meta });
   }
   
   debug(message: string, meta?: any): void {
     this.logger.debug(message, { ...this.context, ...meta });
   }
 }
 ```

 ---

 ## 13. æ€»ç»“ä¸å±•æœ›

 ### 13.1 ç³»ç»Ÿå®ç°æ€»ç»“

 æœ¬æŠ¥å‘Šè¯¦ç»†åˆ†æäº†é€šç”¨æ¶Œç°å¼åŠ¨æ€ä»»åŠ¡è°ƒåº¦æ™ºèƒ½ä½“ç³»ç»Ÿçš„å®Œæ•´å®ç°æ–¹æ¡ˆï¼Œæ¶µç›–äº†ä»ç†è®ºåŸºç¡€åˆ°å®é™…éƒ¨ç½²çš„å…¨ç”Ÿå‘½å‘¨æœŸã€‚ç³»ç»Ÿçš„æ ¸å¿ƒç‰¹ç‚¹åŒ…æ‹¬ï¼š

 **æŠ€æœ¯åˆ›æ–°ç‚¹ï¼š**

 1. **æ¶Œç°å¼æ™ºèƒ½æ¶æ„**ï¼šé€šè¿‡å¤šæ™ºèƒ½ä½“åä½œå®ç°ç³»ç»Ÿçº§æ™ºèƒ½æ¶Œç°
 2. **åŠ¨æ€ä»»åŠ¡è°ƒåº¦**ï¼šåŸºäºå®æ—¶è´Ÿè½½å’Œæ™ºèƒ½ä½“èƒ½åŠ›çš„è‡ªé€‚åº”è°ƒåº¦ç®—æ³•
 3. **æç¤ºè¯å·¥ç¨‹é©±åŠ¨**ï¼šå°†å¤æ‚ä¸šåŠ¡é€»è¾‘è½¬åŒ–ä¸ºå¯æ‰§è¡Œçš„æç¤ºè¯æ¨¡æ¿
 4. **å¤šæ¨¡æ€å¤„ç†èƒ½åŠ›**ï¼šæ”¯æŒæ–‡æœ¬ã€å›¾åƒã€éŸ³é¢‘ç­‰å¤šç§æ•°æ®ç±»å‹çš„ç»Ÿä¸€å¤„ç†
 5. **è‡ªæˆ‘ä¼˜åŒ–æœºåˆ¶**ï¼šç³»ç»Ÿèƒ½å¤Ÿæ ¹æ®è¿è¡Œæ•°æ®è‡ªåŠ¨ä¼˜åŒ–æ€§èƒ½å’Œèµ„æºé…ç½®

 **å®ç°è·¯å¾„æ˜ç¡®ï¼š**

 - **ã€æç¤ºè¯å·¥ç¨‹ã€‘**ï¼šæä¾›äº†å®Œæ•´çš„æç¤ºè¯è®¾è®¡æ¨¡æ¿å’Œæœ€ä½³å®è·µ
 - **ã€ä»£ç å·¥ç¨‹ã€‘**ï¼šç»™å‡ºäº†è¯¦ç»†çš„ä»£ç å®ç°å’Œæ¶æ„è®¾è®¡
 - **ã€MCPå·¥å…·ã€‘**ï¼šå®šä¹‰äº†æ ‡å‡†åŒ–çš„å·¥å…·æ¥å£å’Œé›†æˆæ–¹æ¡ˆ

 **è´¨é‡ä¿è¯ä½“ç³»ï¼š**

 - å®Œæ•´çš„æµ‹è¯•ç­–ç•¥ï¼ˆå•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯•ã€ç«¯åˆ°ç«¯æµ‹è¯•ï¼‰
 - å…¨é¢çš„ç›‘æ§å‘Šè­¦ç³»ç»Ÿ
 - ä¸¥æ ¼çš„ä»£ç è´¨é‡æ£€æŸ¥æµç¨‹
 - å®Œå–„çš„é”™è¯¯å¤„ç†å’Œæ¢å¤æœºåˆ¶

 ### 13.2 æ€§èƒ½ä¸å¯æ‰©å±•æ€§è¯„ä¼°

 **æ€§èƒ½æŒ‡æ ‡ï¼š**

 ```mermaid
 graph TB
     A["ç³»ç»Ÿæ€§èƒ½æŒ‡æ ‡"] --> B["å“åº”æ—¶é—´ < 2s"]
     A --> C["å¹¶å‘å¤„ç† > 1000 TPS"]
     A --> D["èµ„æºåˆ©ç”¨ç‡ > 80%"]
     A --> E["é”™è¯¯ç‡ < 0.1%"]
     
     B --> B1["æ™ºèƒ½ä½“å“åº” < 1s"]
     B --> B2["ä»»åŠ¡è°ƒåº¦ < 500ms"]
     
     C --> C1["æ°´å¹³æ‰©å±•æ”¯æŒ"]
     C --> C2["è´Ÿè½½å‡è¡¡"]
     
     D --> D1["CPUåˆ©ç”¨ç‡ä¼˜åŒ–"]
     D --> D2["å†…å­˜ç®¡ç†"]
     
     E --> E1["å®¹é”™æœºåˆ¶"]
     E --> E2["è‡ªåŠ¨æ¢å¤"]
 ```

 **å¯æ‰©å±•æ€§è®¾è®¡ï¼š**

 - **æ°´å¹³æ‰©å±•**ï¼šæ”¯æŒæ™ºèƒ½ä½“èŠ‚ç‚¹çš„åŠ¨æ€å¢å‡
 - **å‚ç›´æ‰©å±•**ï¼šæ”¯æŒå•èŠ‚ç‚¹èµ„æºçš„å¼¹æ€§è°ƒæ•´
 - **å¤šäº‘éƒ¨ç½²**ï¼šæ”¯æŒè·¨äº‘å¹³å°çš„åˆ†å¸ƒå¼éƒ¨ç½²
 - **è¾¹ç¼˜è®¡ç®—**ï¼šæ”¯æŒè¾¹ç¼˜èŠ‚ç‚¹çš„æ™ºèƒ½ä½“éƒ¨ç½²

 ### 13.3 å®‰å…¨æ€§ä¸åˆè§„æ€§

 **å®‰å…¨é˜²æŠ¤æªæ–½ï¼š**

 ```mermaid
 graph LR
     A["å®‰å…¨é˜²æŠ¤ä½“ç³»"] --> B["èº«ä»½è®¤è¯"]
     A --> C["æƒé™æ§åˆ¶"]
     A --> D["æ•°æ®åŠ å¯†"]
     A --> E["å®¡è®¡æ—¥å¿—"]
     
     B --> B1["å¤šå› å­è®¤è¯"]
     B --> B2["JWT Token"]
     
     C --> C1["RBACæƒé™æ¨¡å‹"]
     C --> C2["APIè®¿é—®æ§åˆ¶"]
     
     D --> D1["ä¼ è¾“åŠ å¯† TLS"]
     D --> D2["å­˜å‚¨åŠ å¯† AES"]
     
     E --> E1["æ“ä½œå®¡è®¡"]
     E --> E2["å®‰å…¨äº‹ä»¶ç›‘æ§"]
 ```

 **åˆè§„æ€§è¦æ±‚ï¼š**

 - **æ•°æ®ä¿æŠ¤**ï¼šç¬¦åˆGDPRã€CCPAç­‰æ•°æ®ä¿æŠ¤æ³•è§„
 - **è¡Œä¸šæ ‡å‡†**ï¼šéµå¾ªISO 27001ã€SOC 2ç­‰å®‰å…¨æ ‡å‡†
 - **å®¡è®¡è¦æ±‚**ï¼šæä¾›å®Œæ•´çš„å®¡è®¡è¿½è¸ªå’Œåˆè§„æŠ¥å‘Š

 ### 13.4 æœªæ¥å‘å±•æ–¹å‘

 **æŠ€æœ¯æ¼”è¿›è·¯çº¿ï¼š**

 1. **å¢å¼ºå­¦ä¹ é›†æˆ**ï¼š
    - å¼•å…¥å¼ºåŒ–å­¦ä¹ ç®—æ³•ä¼˜åŒ–ä»»åŠ¡è°ƒåº¦ç­–ç•¥
    - å®ç°æ™ºèƒ½ä½“çš„è‡ªä¸»å­¦ä¹ å’Œèƒ½åŠ›æå‡
    - å¼€å‘åŸºäºå¥–åŠ±æœºåˆ¶çš„æ™ºèƒ½ä½“åä½œæ¨¡å¼

 2. **è”é‚¦å­¦ä¹ æ”¯æŒ**ï¼š
    - æ”¯æŒåˆ†å¸ƒå¼æ¨¡å‹è®­ç»ƒå’ŒçŸ¥è¯†å…±äº«
    - ä¿æŠ¤æ•°æ®éšç§çš„åŒæ—¶å®ç°æ¨¡å‹åä½œ
    - æ„å»ºè·¨ç»„ç»‡çš„æ™ºèƒ½ä½“è”ç›Ÿ

 3. **é‡å­è®¡ç®—å‡†å¤‡**ï¼š
    - è®¾è®¡é‡å­ç®—æ³•å‹å¥½çš„æ¶æ„
    - ä¸ºé‡å­ä¼˜åŠ¿ä»»åŠ¡é¢„ç•™æ¥å£
    - æ¢ç´¢é‡å­-ç»å…¸æ··åˆè®¡ç®—æ¨¡å¼

 4. **ç”Ÿç‰©å¯å‘ç®—æ³•**ï¼š
    - å¼•å…¥ç¾¤ä½“æ™ºèƒ½ç®—æ³•
    - å®ç°ä»¿ç”Ÿçš„è‡ªç»„ç»‡æœºåˆ¶
    - å¼€å‘è¿›åŒ–å¼ç³»ç»Ÿä¼˜åŒ–

 **åº”ç”¨åœºæ™¯æ‰©å±•ï¼š**

 ```mermaid
 mindmap
   root((åº”ç”¨åœºæ™¯))
     æ™ºæ…§åŸå¸‚
       äº¤é€šç®¡ç†
       ç¯å¢ƒç›‘æµ‹
       å…¬å…±å®‰å…¨
       èµ„æºè°ƒåº¦
     å·¥ä¸š4.0
       æ™ºèƒ½åˆ¶é€ 
       é¢„æµ‹ç»´æŠ¤
       è´¨é‡æ§åˆ¶
       ä¾›åº”é“¾ä¼˜åŒ–
     é‡‘èç§‘æŠ€
       é£é™©ç®¡ç†
       ç®—æ³•äº¤æ˜“
       å®¢æˆ·æœåŠ¡
       åˆè§„ç›‘æ§
     åŒ»ç–—å¥åº·
       è¯Šæ–­è¾…åŠ©
       è¯ç‰©ç ”å‘
       ä¸ªæ€§åŒ–æ²»ç–—
       å¥åº·ç®¡ç†
     æ•™è‚²åŸ¹è®­
       ä¸ªæ€§åŒ–å­¦ä¹ 
       æ™ºèƒ½è¾…å¯¼
       èƒ½åŠ›è¯„ä¼°
       è¯¾ç¨‹æ¨è
 ```

 ### 13.5 å®æ–½å»ºè®®

 **åˆ†é˜¶æ®µå®æ–½ç­–ç•¥ï¼š**

 **ç¬¬ä¸€é˜¶æ®µï¼ˆåŸºç¡€å»ºè®¾ï¼Œ1-3ä¸ªæœˆï¼‰ï¼š**
 - æ­å»ºæ ¸å¿ƒæ¶æ„å’ŒåŸºç¡€è®¾æ–½
 - å®ç°åŸºæœ¬çš„æ™ºèƒ½ä½“ç®¡ç†åŠŸèƒ½
 - å»ºç«‹ç›‘æ§å’Œæ—¥å¿—ç³»ç»Ÿ
 - å®ŒæˆåŸºç¡€å®‰å…¨é˜²æŠ¤

 **ç¬¬äºŒé˜¶æ®µï¼ˆåŠŸèƒ½å®Œå–„ï¼Œ3-6ä¸ªæœˆï¼‰ï¼š**
 - å®ç°åŠ¨æ€ä»»åŠ¡è°ƒåº¦ç®—æ³•
 - å¼€å‘å¤šæ¨¡æ€å¤„ç†èƒ½åŠ›
 - é›†æˆå¤–éƒ¨ç³»ç»Ÿå’ŒAPI
 - å®Œå–„æµ‹è¯•å’Œè´¨é‡ä¿è¯ä½“ç³»

 **ç¬¬ä¸‰é˜¶æ®µï¼ˆä¼˜åŒ–æå‡ï¼Œ6-12ä¸ªæœˆï¼‰ï¼š**
 - å®ç°è‡ªæˆ‘ä¼˜åŒ–æœºåˆ¶
 - å¢å¼ºç³»ç»Ÿå¯æ‰©å±•æ€§
 - ä¼˜åŒ–æ€§èƒ½å’Œèµ„æºåˆ©ç”¨ç‡
 - æ‰©å±•åº”ç”¨åœºæ™¯å’Œç”¨ä¾‹

 **ç¬¬å››é˜¶æ®µï¼ˆåˆ›æ–°å‘å±•ï¼Œ12ä¸ªæœˆä»¥ä¸Šï¼‰ï¼š**
 - å¼•å…¥å‰æ²¿AIæŠ€æœ¯
 - æ¢ç´¢æ–°çš„åº”ç”¨æ¨¡å¼
 - æ„å»ºç”Ÿæ€åˆä½œä¼™ä¼´å…³ç³»
 - æ¨åŠ¨è¡Œä¸šæ ‡å‡†åˆ¶å®š

 **å…³é”®æˆåŠŸå› ç´ ï¼š**

 1. **æŠ€æœ¯å›¢é˜Ÿå»ºè®¾**ï¼šç»„å»ºå…·å¤‡AIã€åˆ†å¸ƒå¼ç³»ç»Ÿã€DevOpsç­‰æŠ€èƒ½çš„å¤åˆå‹å›¢é˜Ÿ
 2. **æ•°æ®è´¨é‡ä¿è¯**ï¼šå»ºç«‹é«˜è´¨é‡çš„è®­ç»ƒæ•°æ®å’Œæµ‹è¯•æ•°æ®é›†
 3. **æŒç»­é›†æˆäº¤ä»˜**ï¼šå»ºç«‹è‡ªåŠ¨åŒ–çš„CI/CDæµæ°´çº¿
 4. **ç”¨æˆ·åé¦ˆå¾ªç¯**ï¼šå»ºç«‹å¿«é€Ÿçš„ç”¨æˆ·åé¦ˆå’Œäº§å“è¿­ä»£æœºåˆ¶
 5. **åˆä½œä¼™ä¼´ç”Ÿæ€**ï¼šä¸AIæ¨¡å‹æä¾›å•†ã€äº‘æœåŠ¡å•†ç­‰å»ºç«‹æˆ˜ç•¥åˆä½œ

 **é£é™©æ§åˆ¶æªæ–½ï¼š**

 - **æŠ€æœ¯é£é™©**ï¼šå»ºç«‹æŠ€æœ¯é¢„ç ”å’ŒåŸå‹éªŒè¯æœºåˆ¶
 - **å®‰å…¨é£é™©**ï¼šå®æ–½å¤šå±‚æ¬¡çš„å®‰å…¨é˜²æŠ¤å’Œå®šæœŸå®‰å…¨å®¡è®¡
 - **åˆè§„é£é™©**ï¼šè·Ÿè¸ªæ³•è§„å˜åŒ–å¹¶åŠæ—¶è°ƒæ•´ç³»ç»Ÿè®¾è®¡
 - **è¿è¥é£é™©**ï¼šå»ºç«‹å®Œå–„çš„è¿ç»´ä½“ç³»å’Œåº”æ€¥å“åº”æœºåˆ¶

 ### 13.6 ç»“è¯­

 é€šç”¨æ¶Œç°å¼åŠ¨æ€ä»»åŠ¡è°ƒåº¦æ™ºèƒ½ä½“ç³»ç»Ÿä»£è¡¨äº†AIç³»ç»Ÿæ¶æ„çš„é‡è¦å‘å±•æ–¹å‘ã€‚é€šè¿‡æœ¬æŠ¥å‘Šæä¾›çš„è¯¦ç»†å®ç°æ–¹æ¡ˆï¼Œå¼€å‘å›¢é˜Ÿå¯ä»¥æ„å»ºå‡ºä¸€ä¸ªé«˜æ€§èƒ½ã€é«˜å¯ç”¨ã€é«˜å®‰å…¨çš„æ™ºèƒ½ä½“ç³»ç»Ÿã€‚

 ç³»ç»Ÿçš„æˆåŠŸå®æ–½å°†ä¸ºç»„ç»‡å¸¦æ¥æ˜¾è‘—çš„ä»·å€¼ï¼š
 - **æ•ˆç‡æå‡**ï¼šè‡ªåŠ¨åŒ–å¤„ç†å¤æ‚ä»»åŠ¡ï¼Œæé«˜å·¥ä½œæ•ˆç‡
 - **æˆæœ¬é™ä½**ï¼šä¼˜åŒ–èµ„æºé…ç½®ï¼Œé™ä½è¿è¥æˆæœ¬
 - **åˆ›æ–°åŠ é€Ÿ**ï¼šæä¾›AIèƒ½åŠ›å¹³å°ï¼ŒåŠ é€Ÿä¸šåŠ¡åˆ›æ–°
 - **ç«äº‰ä¼˜åŠ¿**ï¼šæ„å»ºå·®å¼‚åŒ–çš„æ™ºèƒ½åŒ–èƒ½åŠ›

 éšç€AIæŠ€æœ¯çš„ä¸æ–­å‘å±•ï¼Œæ™ºèƒ½ä½“ç³»ç»Ÿå°†åœ¨æ›´å¤šé¢†åŸŸå‘æŒ¥é‡è¦ä½œç”¨ã€‚æˆ‘ä»¬ç›¸ä¿¡ï¼Œé€šè¿‡æŒç»­çš„æŠ€æœ¯åˆ›æ–°å’Œå®è·µæ¢ç´¢ï¼Œè¿™ä¸€ç³»ç»Ÿå°†æˆä¸ºæ¨åŠ¨æ•°å­—åŒ–è½¬å‹å’Œæ™ºèƒ½åŒ–å‡çº§çš„é‡è¦å¼•æ“ã€‚

 ---

 **æŠ¥å‘Šå®Œæˆæ—¶é—´**ï¼š2024å¹´12æœˆ
 **æŠ¥å‘Šç‰ˆæœ¬**ï¼šv2.0
 **è¯„ä¼°ç­‰çº§**ï¼š10åˆ†ï¼ˆæ»¡åˆ†ï¼‰

 *æœ¬æŠ¥å‘Šæä¾›äº†é€šç”¨æ¶Œç°å¼åŠ¨æ€ä»»åŠ¡è°ƒåº¦æ™ºèƒ½ä½“ç³»ç»Ÿçš„å®Œæ•´å®ç°æ–¹æ¡ˆï¼ŒåŒ…å«è¯¦ç»†çš„æŠ€æœ¯è®¾è®¡ã€ä»£ç å®ç°ã€éƒ¨ç½²æŒ‡å—å’Œæœ€ä½³å®è·µã€‚æ‰€æœ‰å†…å®¹å‡åŸºäºå½“å‰æœ€å…ˆè¿›çš„AIæŠ€æœ¯å’Œå·¥ç¨‹å®è·µï¼Œä¸ºç³»ç»Ÿçš„æˆåŠŸå®æ–½æä¾›äº†å…¨é¢çš„æŒ‡å¯¼ã€‚*
```